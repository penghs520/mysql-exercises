# 第七阶段：存储过程与函数完整答案

## 核心知识点

### 1. 存储过程基础

**什么是存储过程?**
- 存储在数据库中的预编译SQL语句集合
- 可以接收参数,执行逻辑,返回结果
- 类似编程语言中的函数/方法

**存储过程 vs SQL语句:**
- **性能**: 预编译,执行更快
- **网络开销**: 减少客户端与服务器的通信
- **安全性**: 隐藏业务逻辑,控制权限
- **复用性**: 封装复杂逻辑,多处调用

**基本语法:**
```sql
DELIMITER $$

CREATE PROCEDURE procedure_name(
  IN param1 TYPE,      -- 输入参数
  OUT param2 TYPE,     -- 输出参数
  INOUT param3 TYPE    -- 输入输出参数
)
BEGIN
  -- SQL语句
  -- 变量声明
  -- 控制流程
END$$

DELIMITER ;
```

### 2. 参数类型

**IN (输入参数):**
- 调用时传入值
- 存储过程内部只读
- 最常用的参数类型

**OUT (输出参数):**
- 存储过程返回值
- 调用时传入变量,执行后获取结果
- 用于返回计算结果或状态

**INOUT (输入输出参数):**
- 既可以传入值,也可以返回值
- 较少使用,逻辑不清晰

### 3. 变量与流程控制

**声明变量:**
```sql
DECLARE variable_name TYPE [DEFAULT value];

-- 示例
DECLARE v_count INT DEFAULT 0;
DECLARE v_price DECIMAL(10,2);
DECLARE v_name VARCHAR(100);
```

**赋值:**
```sql
-- 方式1: SET
SET v_count = 10;

-- 方式2: SELECT INTO
SELECT COUNT(*) INTO v_count FROM orders;
```

**条件判断:**
```sql
IF condition THEN
  -- 语句
ELSEIF condition THEN
  -- 语句
ELSE
  -- 语句
END IF;
```

**循环:**
```sql
-- WHILE 循环
WHILE condition DO
  -- 语句
END WHILE;

-- LOOP 循环
label_name: LOOP
  -- 语句
  IF condition THEN
    LEAVE label_name;  -- 退出循环
  END IF;
END LOOP;
```

### 4. 异常处理

**DECLARE HANDLER 语法:**
```sql
DECLARE handler_action HANDLER
FOR condition_value
handler_statement;

-- handler_action:
--   CONTINUE: 继续执行
--   EXIT: 退出当前块

-- condition_value:
--   SQLEXCEPTION: SQL异常
--   NOT FOUND: 未找到数据
--   SQLWARNING: SQL警告
--   特定错误码: 1062 (重复键)
```

**示例:**
```sql
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
  ROLLBACK;
  SET p_success = FALSE;
  SET p_message = '操作失败';
END;
```

### 5. 触发器 (Trigger)

**触发器类型:**
- **BEFORE INSERT/UPDATE/DELETE**: 操作前触发
- **AFTER INSERT/UPDATE/DELETE**: 操作后触发

**NEW 和 OLD 关键字:**
- `NEW.column`: 新值(INSERT/UPDATE)
- `OLD.column`: 旧值(UPDATE/DELETE)

**使用场景:**
- 自动更新时间戳
- 数据验证
- 级联操作
- 审计日志

---

## 1. 完整下单流程存储过程

### 1.1 创建存储过程

```sql
DELIMITER $$

CREATE PROCEDURE CreateOrderComplete(
  IN p_user_id BIGINT,
  IN p_product_id BIGINT,
  IN p_quantity INT,
  IN p_address_id BIGINT,
  OUT p_order_id BIGINT,
  OUT p_success BOOLEAN,
  OUT p_message VARCHAR(200)
)
BEGIN
  -- 变量声明
  DECLARE v_price DECIMAL(10,2);
  DECLARE v_stock INT;
  DECLARE v_product_name VARCHAR(200);
  DECLARE v_total_amount DECIMAL(10,2);
  DECLARE v_receiver_name VARCHAR(50);
  DECLARE v_receiver_phone VARCHAR(20);
  DECLARE v_receiver_address VARCHAR(500);
  DECLARE v_order_no VARCHAR(50);

  -- 异常处理
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    ROLLBACK;
    SET p_success = FALSE;
    SET p_message = '订单创建失败，事务已回滚';
  END;

  -- 开启事务
  START TRANSACTION;

  -- 1. 验证用户
  IF NOT EXISTS(SELECT 1 FROM users WHERE id = p_user_id AND status = 1) THEN
    SET p_success = FALSE;
    SET p_message = '用户不存在或已禁用';
    ROLLBACK;
    LEAVE sp_label;
  END IF;

  -- 2. 获取商品信息并锁定
  SELECT price, stock, name INTO v_price, v_stock, v_product_name
  FROM products
  WHERE id = p_product_id AND status = 1
  FOR UPDATE;

  IF v_stock IS NULL THEN
    SET p_success = FALSE;
    SET p_message = '商品不存在或已下架';
    ROLLBACK;
    LEAVE sp_label;
  END IF;

  -- 3. 检查库存
  IF v_stock < p_quantity THEN
    SET p_success = FALSE;
    SET p_message = CONCAT('库存不足，当前库存: ', v_stock);
    ROLLBACK;
    LEAVE sp_label;
  END IF;

  -- 4. 获取收货地址
  SELECT receiver_name, phone, CONCAT(province, city, district, detail_address)
  INTO v_receiver_name, v_receiver_phone, v_receiver_address
  FROM user_addresses
  WHERE id = p_address_id AND user_id = p_user_id;

  IF v_receiver_name IS NULL THEN
    SET p_success = FALSE;
    SET p_message = '收货地址不存在';
    ROLLBACK;
    LEAVE sp_label;
  END IF;

  -- 5. 计算总金额
  SET v_total_amount = v_price * p_quantity;

  -- 6. 生成订单号
  SET v_order_no = CONCAT(
    'ORD',
    DATE_FORMAT(NOW(), '%Y%m%d%H%i%s'),
    LPAD(FLOOR(RAND() * 10000), 4, '0')
  );

  -- 7. 创建订单
  INSERT INTO orders (
    order_no, user_id, total_amount, pay_amount, freight, status,
    receiver_name, receiver_phone, receiver_address
  ) VALUES (
    v_order_no, p_user_id, v_total_amount, v_total_amount, 0, 0,
    v_receiver_name, v_receiver_phone, v_receiver_address
  );

  SET p_order_id = LAST_INSERT_ID();

  -- 8. 创建订单明细
  INSERT INTO order_items (
    order_id, product_id, product_name, price, quantity, total_amount
  ) VALUES (
    p_order_id, p_product_id, v_product_name, v_price, p_quantity, v_total_amount
  );

  -- 9. 扣减库存
  UPDATE products
  SET stock = stock - p_quantity
  WHERE id = p_product_id;

  -- 10. 提交事务
  COMMIT;

  SET p_success = TRUE;
  SET p_message = CONCAT('订单创建成功，订单号: ', v_order_no);

  sp_label: BEGIN END;
END$$

DELIMITER ;
```

**知识点:**
- `DECLARE`: 声明局部变量
- `EXIT HANDLER`: 异常自动回滚
- `FOR UPDATE`: 悲观锁,防止超卖
- `LAST_INSERT_ID()`: 获取自增主键
- `LEAVE`: 跳出存储过程

### 1.2 调用存储过程

```sql
-- 调用
CALL CreateOrderComplete(1, 1, 2, 1, @order_id, @success, @msg);

-- 查看结果
SELECT @order_id as 订单ID, @success as 是否成功, @msg as 消息;
```

---

## 2. 库存扣减存储过程

```sql
DELIMITER $$

CREATE PROCEDURE DeductStockSafe(
  IN p_product_id BIGINT,
  IN p_quantity INT,
  OUT p_success BOOLEAN,
  OUT p_message VARCHAR(100)
)
BEGIN
  DECLARE v_stock INT;

  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    ROLLBACK;
    SET p_success = FALSE;
    SET p_message = '库存扣减异常';
  END;

  START TRANSACTION;

  -- 查询并锁定
  SELECT stock INTO v_stock
  FROM products
  WHERE id = p_product_id
  FOR UPDATE;

  IF v_stock IS NULL THEN
    SET p_success = FALSE;
    SET p_message = '商品不存在';
    ROLLBACK;
  ELSEIF v_stock < p_quantity THEN
    SET p_success = FALSE;
    SET p_message = CONCAT('库存不足，剩余: ', v_stock);
    ROLLBACK;
  ELSE
    -- 扣减库存
    UPDATE products
    SET stock = stock - p_quantity
    WHERE id = p_product_id;

    SET p_success = TRUE;
    SET p_message = '库存扣减成功';
    COMMIT;
  END IF;
END$$

DELIMITER ;
```

**知识点:**
- 先查询后更新,防止超卖
- `FOR UPDATE` 锁定行
- `IF-ELSEIF-ELSE` 条件判断

---

## 3. 自定义函数

### 3.1 计算用户消费总额

```sql
DELIMITER $$

CREATE FUNCTION GetUserTotalSpending(p_user_id BIGINT)
RETURNS DECIMAL(10,2)
DETERMINISTIC
READS SQL DATA
BEGIN
  DECLARE v_total DECIMAL(10,2);

  SELECT IFNULL(SUM(pay_amount), 0) INTO v_total
  FROM orders
  WHERE user_id = p_user_id AND status = 3;

  RETURN v_total;
END$$

DELIMITER ;

-- 使用函数
SELECT
  id,
  username,
  GetUserTotalSpending(id) as total_spending
FROM users
LIMIT 10;
```

**知识点:**
- `RETURNS`: 指定返回类型
- `DETERMINISTIC`: 相同输入返回相同结果
- `READS SQL DATA`: 只读数据
- 函数可以在 SELECT 中使用

### 3.2 存储过程 vs 函数

| 对比项 | 存储过程 | 函数 |
|-------|---------|------|
| 返回值 | 可多个(OUT参数) | 只能一个(RETURN) |
| 调用方式 | CALL | SELECT中使用 |
| 事务 | 可以包含 | 不能包含 |
| DML操作 | 可以 | 受限 |
| 使用场景 | 复杂业务逻辑 | 计算/转换 |

---

## 4. 触发器

### 4.1 订单状态流转触发器

```sql
DELIMITER $$

CREATE TRIGGER tr_order_status_update
BEFORE UPDATE ON orders
FOR EACH ROW
BEGIN
  -- 待支付 -> 已支付
  IF OLD.status = 0 AND NEW.status = 1 AND NEW.payment_time IS NULL THEN
    SET NEW.payment_time = NOW();
  END IF;

  -- 已支付 -> 已发货
  IF OLD.status = 1 AND NEW.status = 2 AND NEW.delivery_time IS NULL THEN
    SET NEW.delivery_time = NOW();
  END IF;

  -- 已发货 -> 已完成
  IF OLD.status = 2 AND NEW.status = 3 AND NEW.finish_time IS NULL THEN
    SET NEW.finish_time = NOW();
  END IF;

  -- 更新修改时间
  SET NEW.updated_at = NOW();
END$$

DELIMITER ;
```

**知识点:**
- `BEFORE UPDATE`: 更新前触发
- `OLD.column`: 更新前的值
- `NEW.column`: 更新后的值
- 可以修改 `NEW.column` 的值

### 4.2 库存变动日志触发器

```sql
-- 创建库存日志表
CREATE TABLE stock_change_log (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  product_id BIGINT,
  old_stock INT,
  new_stock INT,
  change_amount INT,
  change_type VARCHAR(20),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建触发器
DELIMITER $$

CREATE TRIGGER tr_product_stock_update
AFTER UPDATE ON products
FOR EACH ROW
BEGIN
  IF OLD.stock != NEW.stock THEN
    INSERT INTO stock_change_log (
      product_id, old_stock, new_stock, change_amount, change_type
    ) VALUES (
      NEW.id,
      OLD.stock,
      NEW.stock,
      NEW.stock - OLD.stock,
      IF(NEW.stock > OLD.stock, '入库', '出库')
    );
  END IF;
END$$

DELIMITER ;
```

**知识点:**
- `AFTER UPDATE`: 更新后触发
- 自动记录库存变化
- 用于审计和追踪

---

## 关键学习点总结

### 1. 存储过程最佳实践

**异常处理:**
- ✅ 总是使用 `DECLARE HANDLER`
- ✅ 在 HANDLER 中回滚事务
- ✅ 返回清晰的错误信息

**事务控制:**
- ✅ 复杂操作使用事务保证原子性
- ✅ 异常时自动回滚
- ✅ 成功时显式 COMMIT

**参数验证:**
- ✅ 先验证输入参数
- ✅ 使用 IF 判断条件
- ✅ 早期返回(LEAVE)

**性能考虑:**
- ❌ 避免在存储过程中循环查询
- ❌ 避免过度使用游标
- ✅ 使用批量操作

### 2. 触发器使用建议

**适用场景:**
- ✅ 自动更新时间戳
- ✅ 数据验证和约束
- ✅ 审计日志记录
- ✅ 级联操作

**注意事项:**
- ⚠️ 触发器会降低写入性能
- ⚠️ 避免触发器嵌套(触发器调用触发器)
- ⚠️ 逻辑不要太复杂
- ⚠️ 避免在触发器中调用存储过程

### 3. 函数使用场景

**适合:**
- 数值计算
- 字符串转换
- 日期处理
- 简单逻辑判断

**不适合:**
- 复杂业务逻辑
- 需要事务的操作
- 多个返回值的场景

---

## 实践建议

1. **从简单开始**: 先写简单的存储过程,逐步增加复杂度
2. **测试充分**: 模拟各种场景,包括异常情况
3. **日志记录**: 在存储过程中记录关键操作
4. **文档注释**: 添加清晰的注释说明
5. **性能测试**: 对比存储过程和普通SQL的性能

**调试技巧:**
```sql
-- 临时调试输出
SELECT CONCAT('Debug: v_stock=', v_stock) as debug_info;

-- 查看存储过程定义
SHOW CREATE PROCEDURE CreateOrderComplete;

-- 删除存储过程
DROP PROCEDURE IF EXISTS CreateOrderComplete;
```

继续学习第八阶段!
