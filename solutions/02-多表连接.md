# 第二阶段：多表连接完整答案

## 3. RIGHT JOIN 右外连接

### 3.1 练习 RIGHT JOIN
```sql
-- 将 1.1 的查询改写为 RIGHT JOIN
-- 从订单表出发，右连接用户表
SELECT
  o.order_no,
  u.username,
  o.pay_amount,
  o.status
FROM users u
RIGHT JOIN orders o ON u.id = o.user_id
LIMIT 50;

-- 结果应该与 INNER JOIN 相同（因为orders.user_id有外键约束）
```

### 3.2 对比 LEFT 和 RIGHT
```sql
-- LEFT JOIN：以users为主表
SELECT u.username, o.order_no
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE u.id <= 10;
-- 结果：包含所有10个用户，即使没有订单

-- RIGHT JOIN：以orders为主表
SELECT u.username, o.order_no
FROM users u
RIGHT JOIN orders o ON u.id = o.user_id
WHERE o.id <= 10;
-- 结果：只包含前10个订单及其用户
```

---

## 6. 连接条件优化

### 6.1 使用 USING
```sql
-- 注意：USING要求两表的连接字段名完全相同
-- orders表的字段是user_id，users表的主键是id，所以不能用USING

-- 但对于order_items和orders可以用：
SELECT o.order_no, oi.product_name, oi.quantity
FROM order_items oi
JOIN orders o USING (order_id)
-- 等同于 ON oi.order_id = o.order_id
LIMIT 20;

-- 实际上MySQL中order_items.order_id指向orders.id
-- 所以这里不能直接用USING，需要用ON
SELECT o.order_no, oi.product_name, oi.quantity
FROM order_items oi
JOIN orders o ON oi.order_id = o.id
LIMIT 20;
```

### 6.2 多条件连接
```sql
-- 连接条件包含价格范围和状态
SELECT
  o.order_no,
  oi.product_name,
  oi.price,
  p.name,
  p.price as current_price
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id AND p.price > 100
WHERE o.status = 3
LIMIT 50;
```

---

## 7. 子查询与连接

### 7.1 用子查询替代连接
```sql
-- 方法1：使用 JOIN
SELECT DISTINCT u.username, u.email
FROM users u
JOIN orders o ON u.id = o.user_id
JOIN order_items oi ON o.id = oi.order_id
WHERE oi.product_id = 100;

-- 方法2：使用子查询
SELECT username, email
FROM users
WHERE id IN (
  SELECT user_id FROM orders WHERE id IN (
    SELECT order_id FROM order_items WHERE product_id = 100
  )
);

-- 对比：JOIN通常性能更好，但子查询更易读
```

### 7.2 连接替代子查询
```sql
-- 查询订单金额大于用户平均订单金额的订单
-- 使用JOIN实现
SELECT
  o1.order_no,
  o1.user_id,
  o1.pay_amount,
  avg_orders.avg_amount
FROM orders o1
JOIN (
  SELECT user_id, AVG(pay_amount) as avg_amount
  FROM orders
  GROUP BY user_id
) avg_orders ON o1.user_id = avg_orders.user_id
WHERE o1.pay_amount > avg_orders.avg_amount
ORDER BY o1.pay_amount DESC
LIMIT 50;
```

---

## 8. CROSS JOIN 交叉连接

### 8.1 笛卡尔积
```sql
-- 生成商品和颜色的组合
SELECT
  p.id,
  p.name,
  colors.color
FROM (
  SELECT id, name FROM products WHERE status = 1 LIMIT 5
) p
CROSS JOIN (
  SELECT '红色' as color
  UNION SELECT '黑色'
  UNION SELECT '白色'
  UNION SELECT '蓝色'
  UNION SELECT '灰色'
) colors
ORDER BY p.id, colors.color;

-- 结果：5个商品 × 5个颜色 = 25条记录
```

---

## 9. 综合实战

### 9.1 订单完整信息查询
```sql
-- 查询订单的完整信息
SET @order_no = (SELECT order_no FROM orders LIMIT 1);

SELECT
  -- 订单基本信息
  o.order_no,
  o.total_amount,
  o.pay_amount,
  CASE o.status
    WHEN 0 THEN '待支付'
    WHEN 1 THEN '已支付'
    WHEN 2 THEN '已发货'
    WHEN 3 THEN '已完成'
    WHEN 4 THEN '已取消'
  END as order_status,
  o.created_at,

  -- 买家信息
  u.username,
  u.email,
  u.phone,

  -- 收货地址
  o.receiver_name,
  o.receiver_phone,
  o.receiver_address,

  -- 订单商品明细
  GROUP_CONCAT(
    CONCAT(oi.product_name, ' x', oi.quantity, ' @', oi.price)
    SEPARATOR '; '
  ) as order_items,

  -- 支付信息
  p.payment_method,
  p.payment_no,
  p.paid_at

FROM orders o
JOIN users u ON o.user_id = u.id
LEFT JOIN order_items oi ON o.id = oi.order_id
LEFT JOIN payments p ON o.id = p.order_id
WHERE o.order_no = @order_no
GROUP BY o.id, o.order_no, o.total_amount, o.pay_amount, o.status,
         o.created_at, u.username, u.email, u.phone,
         o.receiver_name, o.receiver_phone, o.receiver_address,
         p.payment_method, p.payment_no, p.paid_at;
```

### 9.2 商品销售分析
```sql
SELECT
  c.name as category_name,
  COUNT(DISTINCT p.id) as product_count,
  SUM(oi.quantity) as total_quantity,
  SUM(oi.total_amount) as total_revenue,
  AVG(oi.price) as avg_price
FROM categories c
JOIN products p ON c.id = p.category_id
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.id AND o.status = 3
WHERE c.level = 1  -- 只看一级分类
GROUP BY c.id, c.name
HAVING total_revenue > 0
ORDER BY total_revenue DESC;
```

### 9.3 用户行为分析
```sql
SELECT
  u.username,
  COUNT(DISTINCT o.id) as order_count,
  COUNT(DISTINCT c.id) as cart_count,
  COUNT(DISTINCT pr.id) as review_count,
  u.created_at as register_time,
  MAX(o.created_at) as last_order_time
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
LEFT JOIN cart_items c ON u.id = c.user_id
LEFT JOIN product_reviews pr ON u.id = pr.user_id
WHERE EXISTS (SELECT 1 FROM orders WHERE user_id = u.id)  -- 只显示有购买行为的用户
GROUP BY u.id, u.username, u.created_at
ORDER BY order_count DESC
LIMIT 100;
```

### 9.4 复购率分析
```sql
SELECT
  u.id,
  u.username,
  COUNT(o.id) as purchase_count,
  MIN(o.created_at) as first_purchase,
  MAX(o.created_at) as last_purchase,
  DATEDIFF(MAX(o.created_at), MIN(o.created_at)) as customer_lifetime_days
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.status = 3
GROUP BY u.id, u.username
HAVING purchase_count >= 3
ORDER BY purchase_count DESC
LIMIT 50;
```

---

## 学习要点总结

### 1. JOIN类型的选择原则

```sql
-- INNER JOIN：只要匹配的数据
SELECT ... FROM A INNER JOIN B ON A.id = B.a_id;

-- LEFT JOIN：保留左表所有数据
SELECT ... FROM A LEFT JOIN B ON A.id = B.a_id;

-- RIGHT JOIN：保留右表所有数据（少用，用LEFT代替）
SELECT ... FROM A RIGHT JOIN B ON A.id = B.a_id;
-- 等同于：
SELECT ... FROM B LEFT JOIN A ON A.id = B.a_id;

-- CROSS JOIN：笛卡尔积
SELECT ... FROM A CROSS JOIN B;
```

### 2. JOIN性能优化技巧

1. **小表驱动大表**
   ```sql
   -- 好：小表在前
   FROM products (500行) JOIN order_items (50000行)

   -- 不好：大表在前
   FROM order_items (50000行) JOIN products (500行)
   ```

2. **确保连接字段有索引**
   ```sql
   -- 检查索引
   SHOW INDEX FROM orders WHERE Column_name = 'user_id';

   -- 如果没有，创建索引
   CREATE INDEX idx_user_id ON orders(user_id);
   ```

3. **避免SELECT ***
   ```sql
   -- 不好
   SELECT * FROM orders o JOIN users u ON ...;

   -- 好：只选需要的字段
   SELECT o.order_no, u.username, o.total_amount FROM ...;
   ```

4. **使用EXPLAIN分析**
   ```sql
   EXPLAIN SELECT ...;
   -- 观察：type, key, rows, Extra
   ```

### 3. 常见问题和解决方案

**问题1：LEFT JOIN变成INNER JOIN**
```sql
-- 错误写法：WHERE条件使LEFT JOIN失效
SELECT u.*, o.order_no
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.status = 1;  -- ❌ 这会过滤掉没有订单的用户

-- 正确写法：条件放在ON中
SELECT u.*, o.order_no
FROM users u
LEFT JOIN orders o ON u.id = o.user_id AND o.status = 1;  -- ✅
```

**问题2：重复数据**
```sql
-- 一对多关联会产生重复
SELECT u.username, o.order_no
FROM users u
JOIN orders o ON u.id = o.user_id;
-- 一个用户有多个订单，username会重复

-- 解决方案1：使用DISTINCT
SELECT DISTINCT u.username FROM ...;

-- 解决方案2：使用GROUP BY
SELECT u.username, COUNT(o.id) as order_count
FROM users u
JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.username;
```

**问题3：NULL值处理**
```sql
-- LEFT JOIN可能产生NULL
SELECT u.username, IFNULL(o.order_no, '无订单') as order_no
FROM users u
LEFT JOIN orders o ON u.id = o.user_id;
```

### 4. 何时使用JOIN vs 子查询

**使用JOIN的场景：**
- 需要返回多个表的字段
- 性能要求高
- 数据量大

**使用子查询的场景：**
- 只需要过滤条件
- 逻辑更清晰
- 一次性查询

```sql
-- JOIN：返回多个表的字段
SELECT u.username, o.order_no, o.total_amount
FROM users u
JOIN orders o ON u.id = o.user_id;

-- 子查询：只需要过滤
SELECT username FROM users
WHERE id IN (SELECT user_id FROM orders WHERE total_amount > 1000);
```

继续加油，进入第三阶段学习！
