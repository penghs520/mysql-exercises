# 第二阶段：多表连接完整答案

## 1. INNER JOIN 内连接

### 1.1 两表连接
```sql
-- 查询所有订单及对应的用户信息
SELECT
  o.order_no,
  u.username,
  o.pay_amount,
  o.status
FROM orders o
INNER JOIN users u ON o.user_id = u.id
LIMIT 50;
```

### 1.2 查看订单详情
```sql
-- 查询订单明细及对应的商品信息
SELECT
  oi.order_id,
  p.name AS product_name,
  oi.price,
  oi.quantity,
  oi.total_amount
FROM order_items oi
INNER JOIN products p ON oi.product_id = p.id
LIMIT 50;
```

### 1.3 三表连接
```sql
-- 查询订单、用户、支付信息
SELECT
  o.order_no,
  u.username,
  o.pay_amount,
  p.payment_method,
  p.paid_at
FROM orders o
INNER JOIN users u ON o.user_id = u.id
INNER JOIN payments p ON o.id = p.order_id
WHERE o.status >= 1  -- 已支付的订单
LIMIT 50;
```

### 1.4 四表连接
```sql
-- 查询完整的订单购买信息
SELECT
  u.username AS 用户名,
  o.order_no AS 订单号,
  p.name AS 商品名称,
  oi.quantity AS 购买数量,
  o.created_at AS 订单创建时间
FROM orders o
INNER JOIN users u ON o.user_id = u.id
INNER JOIN order_items oi ON o.id = oi.order_id
INNER JOIN products p ON oi.product_id = p.id
ORDER BY o.created_at DESC
LIMIT 30;
```

---

## 2. LEFT JOIN 左外连接

### 2.1 查询所有用户及其订单
```sql
-- 查询所有用户，包括没有下过订单的用户
SELECT
  u.username,
  u.email,
  COUNT(o.id) as order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.username, u.email
ORDER BY order_count DESC
LIMIT 50;
```

### 2.2 查询未支付的订单
```sql
-- 查询所有订单及支付信息，包括还未支付的订单
SELECT
  o.order_no,
  o.pay_amount,
  p.payment_no,
  CASE
    WHEN p.status IS NULL THEN '未支付'
    WHEN p.status = 0 THEN '待支付'
    WHEN p.status = 1 THEN '已支付'
    WHEN p.status = 2 THEN '支付失败'
  END as payment_status
FROM orders o
LEFT JOIN payments p ON o.id = p.order_id
WHERE o.status = 0 OR p.payment_no IS NULL
LIMIT 50;
```

### 2.3 找出没有购买记录的用户
```sql
-- 查询从未下过订单的用户
SELECT
  u.id,
  u.username,
  u.created_at
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.id IS NULL
LIMIT 50;
```

### 2.4 商品销售情况
```sql
-- 查询所有商品及其销售数量，包括从未被购买过的商品
SELECT
  p.id,
  p.name,
  IFNULL(SUM(oi.quantity), 0) as total_sold,
  IFNULL(SUM(oi.total_amount), 0) as total_revenue
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.id AND o.status = 3
GROUP BY p.id, p.name
ORDER BY total_sold DESC
LIMIT 50;
```

---

## 3. RIGHT JOIN 右外连接

### 3.1 练习 RIGHT JOIN
```sql
-- 将 1.1 的查询改写为 RIGHT JOIN
-- 从订单表出发，右连接用户表
SELECT
  o.order_no,
  u.username,
  o.pay_amount,
  o.status
FROM users u
RIGHT JOIN orders o ON u.id = o.user_id
LIMIT 50;

-- 结果应该与 INNER JOIN 相同（因为orders.user_id有外键约束）
```

### 3.2 对比 LEFT 和 RIGHT
```sql
-- LEFT JOIN：以users为主表
SELECT u.username, o.order_no
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
-- 结果：包含所有用户，即使没有订单

-- RIGHT JOIN：以orders为主表
SELECT u.username, o.order_no
FROM users u
RIGHT JOIN orders o ON u.id = o.user_id
-- 结果：只包含下过单的用户
```

---

## 6. 连接条件优化

### 6.1 使用 USING
```sql
-- USING 要求两表的连接字段名完全相同
-- 当字段名相同时，可以简化JOIN语法

-- USING的优点：
-- 1. 语法更简洁
-- 2. 结果集中不会重复显示连接字段
-- USING的限制：
-- 1. 字段名必须完全相同
-- 2. 只能用于等值连接
```

### 6.2 多条件连接
```sql
-- 连接条件包含价格范围和状态
SELECT
  o.order_no,
  oi.product_name,
  oi.price,
  p.name,
  p.price as current_price
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id AND p.price > 100
WHERE o.status = 3
LIMIT 50;
```

---

## 7. 子查询与连接

### 7.1 用子查询替代连接
```sql
-- 方法1：使用 JOIN
SELECT DISTINCT u.username, u.email
FROM users u
JOIN orders o ON u.id = o.user_id
JOIN order_items oi ON o.id = oi.order_id
WHERE oi.product_id = 100;

-- 方法2：使用子查询
SELECT username, email
FROM users
WHERE id IN (
  SELECT user_id FROM orders WHERE id IN (
    SELECT order_id FROM order_items WHERE product_id = 100
  )
);

-- 对比：JOIN通常性能更好，但子查询更易读
```

### 7.2 连接替代子查询
```sql
-- 查询订单金额大于用户平均订单金额的订单
-- 使用JOIN实现
SELECT
  o1.order_no,
  o1.user_id,
  o1.pay_amount,
  avg_orders.avg_amount
FROM orders o1
JOIN (
  SELECT user_id, AVG(pay_amount) as avg_amount
  FROM orders
  GROUP BY user_id
) avg_orders ON o1.user_id = avg_orders.user_id
WHERE o1.pay_amount > avg_orders.avg_amount
ORDER BY o1.pay_amount DESC
LIMIT 50;
```

---

## 8. CROSS JOIN 交叉连接

### 8.1 笛卡尔积
```sql
-- 生成商品和颜色的组合
SELECT
  p.id,
  p.name,
  colors.color
FROM (
  SELECT id, name FROM products WHERE status = 1 LIMIT 5
) p
CROSS JOIN (
  SELECT '红色' as color
  UNION SELECT '黑色'
  UNION SELECT '白色'
  UNION SELECT '蓝色'
  UNION SELECT '灰色'
) colors
ORDER BY p.id, colors.color;

-- 结果：5个商品 × 5个颜色 = 25条记录
```

---

## 9. 综合实战

### 9.1 订单完整信息查询
```sql
-- 查询订单的完整信息
SET @order_no = (SELECT order_no FROM orders LIMIT 1);

SELECT
  -- 订单基本信息
  o.order_no,
  o.total_amount,
  o.pay_amount,
  CASE o.status
    WHEN 0 THEN '待支付'
    WHEN 1 THEN '已支付'
    WHEN 2 THEN '已发货'
    WHEN 3 THEN '已完成'
    WHEN 4 THEN '已取消'
  END as order_status,
  o.created_at,

  -- 买家信息
  u.username,
  u.email,
  u.phone,

  -- 收货地址
  o.receiver_name,
  o.receiver_phone,
  o.receiver_address,

  -- 订单商品明细
  -- 使用 GROUP BY 配合 GROUP_CONCAT 可以将同一订单的多个商品明细聚合到一行显示
  GROUP_CONCAT(
    CONCAT(oi.product_name, ' x', oi.quantity, ' @', oi.price)
    SEPARATOR '; '
  ) as order_items,

  -- 支付信息
  p.payment_method,
  p.payment_no,
  p.paid_at

FROM orders o
JOIN users u ON o.user_id = u.id
LEFT JOIN order_items oi ON o.id = oi.order_id
LEFT JOIN payments p ON o.id = p.order_id
WHERE o.order_no = @order_no
GROUP BY o.id, o.order_no, o.total_amount, o.pay_amount, o.status,
         o.created_at, u.username, u.email, u.phone,
         o.receiver_name, o.receiver_phone, o.receiver_address,
         p.payment_method, p.payment_no, p.paid_at;
```

### 9.2 商品销售分析
```sql
-- 分析每个分类下商品的销售情况（一级分类）
-- 注意：商品关联的是二级分类，需要通过二级分类聚合到一级分类
SELECT
  c1.name as category_name,
  COUNT(DISTINCT p.id) as product_count,
  SUM(oi.quantity) as total_quantity,
  SUM(oi.total_amount) as total_revenue,
  AVG(oi.price) as avg_price
FROM categories c1
JOIN categories c2 ON c2.parent_id = c1.id  -- c2是二级分类
JOIN products p ON c2.id = p.category_id
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.id AND o.status = 3
WHERE c1.level = 1  -- 只看一级分类
GROUP BY c1.id, c1.name
HAVING total_revenue > 0
ORDER BY total_revenue DESC;
```

### 9.3 用户行为分析
```sql
SELECT
  u.username,
  COUNT(DISTINCT o.id) as order_count,
  COUNT(DISTINCT c.id) as cart_count,
  COUNT(DISTINCT pr.id) as review_count,
  u.created_at as register_time,
  MAX(o.created_at) as last_order_time
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
LEFT JOIN cart_items c ON u.id = c.user_id
LEFT JOIN product_reviews pr ON u.id = pr.user_id
WHERE EXISTS (SELECT 1 FROM orders WHERE user_id = u.id)  -- 只显示有购买行为的用户
GROUP BY u.id, u.username, u.created_at
ORDER BY order_count DESC
LIMIT 100;

这个sql很慢，执行计划如下：
--------------------+
| id | select_type | table  | partitions | type   | possible_keys | key         | key_len | ref                     | rows  | filtered | Extra                                                   |
+----+-------------+--------+------------+--------+---------------+-------------+---------+-------------------------+-------+----------+---------------------------------------------------------+
|  1 | SIMPLE      | orders | NULL       | index  | idx_user_id   | idx_user_id | 8       | NULL                    | 19816 |     5.05 | Using index; Using temporary; Using filesort; LooseScan |
|  1 | SIMPLE      | u      | NULL       | eq_ref | PRIMARY       | PRIMARY     | 8       | study_db.orders.user_id |     1 |   100.00 | NULL                                                    |
|  1 | SIMPLE      | o      | NULL       | ref    | idx_user_id   | idx_user_id | 8       | study_db.orders.user_id |    19 |   100.00 | NULL                                                    |
|  1 | SIMPLE      | c      | NULL       | ref    | idx_user_id   | idx_user_id | 8       | study_db.orders.user_id |     4 |   100.00 | Using index                                             |
|  1 | SIMPLE      | pr     | NULL       | ref    | idx_user_id   | idx_user_id | 8       | study_db.orders.user_id |    19 |   100.00 | Using index                                             |
+----+-------------+--------+------------+--------+---------------+-------------+---------+-------------------------+-------+----------+---------------------------------------------------------+

  1. Using temporary; Using filesort - 需要创建临时表并进行文件排序，这是最大的性能瓶颈
  2. 扫描行数多 - 第一步就扫描了 19816 行
  3. 多个 LEFT JOIN - 导致数据膨胀，每个用户可能产生大量笛卡尔积组合
  4. COUNT(DISTINCT) - 对膨胀后的数据集进行去重统计，开销大


  LooseScan 是 MySQL 对 EXISTS 子查询的半连接优化策略之一。

  它的工作原理：
  - 扫描索引时，只读取每个分组的第一条记录就跳过（loose，松散的）
  - 避免全表扫描来验证 EXISTS 条件
  - 类似于 GROUP BY 使用索引的 "Loose Index Scan"

  在你的查询中：
  WHERE EXISTS (SELECT 1 FROM orders WHERE user_id = u.id)
  MySQL 使用 LooseScan 优化：
  1. 利用 orders.idx_user_id 索引
  2. 对每个 user_id，只要找到第一条记录就确认存在
  3. 跳过该 user_id 的其他记录


  其他半连接优化策略：
  - FirstMatch - 找到第一个匹配就返回
  - Duplicate Weedout - 使用临时表去重
  - Materialization - 将子查询物化成临时表


-- 优化方案：使用子查询分别统计，避免笛卡尔积
  SELECT
    u.username,
    IFNULL(order_stats.order_count, 0) as order_count,
    IFNULL(cart_stats.cart_count, 0) as cart_count,
    IFNULL(review_stats.review_count, 0) as review_count,
    u.created_at as register_time,
    order_stats.last_order_time
  FROM users u
  INNER JOIN (
    SELECT user_id, COUNT(*) as order_count, MAX(created_at) as last_order_time
    FROM orders
    GROUP BY user_id
  ) order_stats ON u.id = order_stats.user_id
  LEFT JOIN (
    SELECT user_id, COUNT(*) as cart_count FROM cart_items GROUP BY user_id
  ) cart_stats ON u.id = cart_stats.user_id
  LEFT JOIN (
    SELECT user_id, COUNT(*) as review_count FROM product_reviews GROUP BY user_id
  ) review_stats ON u.id = review_stats.user_id
  ORDER BY order_count DESC
  LIMIT 100;

```

### 9.4 复购率分析
```sql
SELECT
  u.id,
  u.username,
  COUNT(o.id) as purchase_count,
  MIN(o.created_at) as first_purchase,
  MAX(o.created_at) as last_purchase,
  DATEDIFF(MAX(o.created_at), MIN(o.created_at)) as customer_lifetime_days
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.status = 3
GROUP BY u.id, u.username
HAVING purchase_count >= 3
ORDER BY purchase_count DESC
LIMIT 50;
```

---

## 学习要点总结

### 1. JOIN类型的选择原则

```sql
-- INNER JOIN：只要匹配的数据
SELECT ... FROM A INNER JOIN B ON A.id = B.a_id;

-- LEFT JOIN：保留左表所有数据
SELECT ... FROM A LEFT JOIN B ON A.id = B.a_id;

-- RIGHT JOIN：保留右表所有数据（少用，用LEFT代替）
SELECT ... FROM A RIGHT JOIN B ON A.id = B.a_id;
-- 等同于：
SELECT ... FROM B LEFT JOIN A ON A.id = B.a_id;

-- CROSS JOIN：笛卡尔积
SELECT ... FROM A CROSS JOIN B;
```

### 2. JOIN性能优化技巧

1. **小表驱动大表**
   ```sql
   -- 好：小表在前
   FROM products (500行) JOIN order_items (50000行)

   -- 不好：大表在前
   FROM order_items (50000行) JOIN products (500行)
   ```

2. **确保连接字段有索引**
   ```sql
   -- 检查索引
   SHOW INDEX FROM orders WHERE Column_name = 'user_id';

   -- 如果没有，创建索引
   CREATE INDEX idx_user_id ON orders(user_id);
   ```

3. **避免SELECT ***
   ```sql
   -- 不好
   SELECT * FROM orders o JOIN users u ON ...;

   -- 好：只选需要的字段
   SELECT o.order_no, u.username, o.total_amount FROM ...;
   ```

4. **使用EXPLAIN分析**
   ```sql
   EXPLAIN SELECT ...;
   -- 观察：type, key, rows, Extra
   ```

### 3. 常见问题和解决方案

**问题1：LEFT JOIN变成INNER JOIN**
```sql
-- 错误写法：WHERE条件使LEFT JOIN失效
SELECT u.*, o.order_no
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.status = 1;  -- ❌ 这会过滤掉没有订单的用户

-- 正确写法：条件放在ON中
SELECT u.*, o.order_no
FROM users u
LEFT JOIN orders o ON u.id = o.user_id AND o.status = 1;  -- ✅
```

**问题2：重复数据**
```sql
-- 一对多关联会产生重复
SELECT u.username, o.order_no
FROM users u
JOIN orders o ON u.id = o.user_id;
-- 一个用户有多个订单，username会重复

-- 解决方案1：使用DISTINCT
SELECT DISTINCT u.username FROM ...;

-- 解决方案2：使用GROUP BY
SELECT u.username, COUNT(o.id) as order_count
FROM users u
JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.username;
```

**问题3：NULL值处理**
```sql
-- LEFT JOIN可能产生NULL
SELECT u.username, IFNULL(o.order_no, '无订单') as order_no
FROM users u
LEFT JOIN orders o ON u.id = o.user_id;
```

### 4. 何时使用JOIN vs 子查询

**使用JOIN的场景：**
- 需要返回多个表的字段
- 性能要求高
- 数据量大

**使用子查询的场景：**
- 只需要过滤条件
- 逻辑更清晰
- 一次性查询

```sql
-- JOIN：返回多个表的字段
SELECT u.username, o.order_no, o.total_amount
FROM users u
JOIN orders o ON u.id = o.user_id;

-- 子查询：只需要过滤
SELECT username FROM users
WHERE id IN (SELECT user_id FROM orders WHERE total_amount > 1000);
```

---

## 4. 自连接

### 4.1 分类层级查询
```sql
-- 查询商品分类及其父分类名称
SELECT
  c1.id,
  c1.name as category_name,
  c1.parent_id,
  c2.name as parent_category_name
FROM categories c1
LEFT JOIN categories c2 ON c1.parent_id = c2.id
WHERE c1.parent_id > 0
ORDER BY c1.parent_id, c1.id
LIMIT 50;
```

### 4.2 查找同价商品
```sql
-- 查找相同价格的不同商品
SELECT
  p1.name as product1,
  p2.name as product2,
  p1.price
FROM products p1
INNER JOIN products p2 ON p1.price = p2.price AND p1.id < p2.id
WHERE p1.status = 1 AND p2.status = 1
ORDER BY p1.price DESC, p1.id
LIMIT 20;
```

---

## 5. 多表连接综合

### 5.1 用户购买明细
```sql
-- 查询用户的详细购买记录
SELECT
  u.username,
  o.order_no,
  p.name as product_name,
  oi.quantity,
  oi.total_amount,
  CASE o.status
    WHEN 0 THEN '待支付'
    WHEN 1 THEN '已支付'
    WHEN 2 THEN '已发货'
    WHEN 3 THEN '已完成'
    WHEN 4 THEN '已取消'
  END as order_status
FROM users u
INNER JOIN orders o ON u.id = o.user_id
INNER JOIN order_items oi ON o.id = oi.order_id
INNER JOIN products p ON oi.product_id = p.id
ORDER BY u.id, o.created_at DESC
LIMIT 100;
```

### 5.2 商品评价详情
```sql
-- 查询商品的评价信息
SELECT
  p.name as product_name,
  u.username,
  pr.rating,
  pr.content,
  o.order_no,
  pr.created_at as review_time
FROM products p
INNER JOIN product_reviews pr ON p.id = pr.product_id
INNER JOIN users u ON pr.user_id = u.id
INNER JOIN orders o ON pr.order_id = o.id
WHERE pr.rating >= 4
ORDER BY pr.created_at DESC
LIMIT 50;
```

### 5.3 热门商品排行
```sql
-- 统计商品的销售情况
SELECT
  p.name as product_name,
  c.name as category_name,
  SUM(oi.quantity) as total_quantity,
  SUM(oi.total_amount) as total_revenue
FROM products p
INNER JOIN categories c ON p.category_id = c.id
INNER JOIN order_items oi ON p.id = oi.product_id
INNER JOIN orders o ON oi.order_id = o.id
WHERE o.status = 3
GROUP BY p.id, p.name, c.name
ORDER BY total_revenue DESC
LIMIT 20;
```

### 5.4 用户消费统计
```sql
-- 统计每个用户的消费情况
SELECT
  u.username,
  COUNT(o.id) as order_count,
  SUM(o.pay_amount) as total_spending,
  AVG(o.pay_amount) as avg_order_amount
FROM users u
INNER JOIN orders o ON u.id = o.user_id
WHERE o.status = 3
GROUP BY u.id, u.username
ORDER BY total_spending DESC
LIMIT 50;
```

---

## 10. 性能思考

### 10.1 观察执行计划
```sql
-- 使用 EXPLAIN 分析查询
EXPLAIN
SELECT u.username, COUNT(o.id) as order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.username;

-- 观察要点：
-- - type列：ref、eq_ref、const 较好，ALL 最差
-- - key列：实际使用的索引
-- - rows列：扫描的行数，越少越好
-- - Extra列：Using index（好），Using filesort（需优化）
```

### 10.2 比较不同写法
```sql
-- 方法1：INNER JOIN
EXPLAIN
SELECT DISTINCT u.username
FROM users u
INNER JOIN orders o ON u.id = o.user_id
INNER JOIN order_items oi ON o.id = oi.order_id
WHERE oi.product_id = 100;

-- 方法2：WHERE IN (子查询)
EXPLAIN
SELECT username
FROM users
WHERE id IN (
  SELECT user_id FROM orders WHERE id IN (
    SELECT order_id FROM order_items WHERE product_id = 100
  )
);

-- 方法3：WHERE EXISTS (子查询)
EXPLAIN
SELECT username
FROM users u
WHERE EXISTS (
  SELECT 1 FROM orders o
  WHERE o.user_id = u.id
    AND EXISTS (
      SELECT 1 FROM order_items oi
      WHERE oi.order_id = o.id AND oi.product_id = 100
    )
);

-- 性能对比：
-- 通常 JOIN > EXISTS > IN (子查询)
-- 但具体要看数据量和索引情况
```

---

继续加油，进入第三阶段学习！
