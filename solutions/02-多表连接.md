# 第二阶段：多表连接完整答案

## 核心知识点

### 1. JOIN 的本质原理

**什么是 JOIN?**
- JOIN 是关系型数据库的核心操作,用于将多个表的数据按照某种关联关系组合在一起
- 本质是通过关联条件对两个表进行**笛卡尔积**,然后根据条件筛选出符合要求的结果
- MySQL 主要支持三种 JOIN 算法

**三种 JOIN 算法:**

**1. Nested Loop Join (嵌套循环连接)**
- **最基础的算法**,外层循环驱动表,内层循环被驱动表
- 伪代码:
  ```
  for each row in 驱动表:
      for each row in 被驱动表:
          if 满足连接条件:
              输出结果行
  ```
- 时间复杂度: O(M × N)
- 适用: 被驱动表连接字段有索引时,每次内层查找 O(log N)

**2. Block Nested Loop (块嵌套循环)**
- 使用 **join buffer** 批量缓存驱动表的数据
- 减少内层表的扫描次数
- 伪代码:
  ```
  将驱动表数据分批加载到 join buffer
  for each batch in join buffer:
      for each row in 被驱动表:
          匹配 batch 中的所有行
  ```
- 适用: 被驱动表连接字段**无索引**时

**3. Hash Join (哈希连接)**
- MySQL 8.0.18+ 新增,专门优化等值连接
- 过程:
  1. 对驱动表建立哈希表(连接字段作为 key)
  2. 扫描被驱动表,用连接字段查找哈希表
- 时间复杂度: O(M + N)
- 适用: 等值连接且无索引时,比 Block Nested Loop 更快

**JOIN 的执行流程:**
```
1. 确定驱动表(小表)和被驱动表(大表)
   - MySQL 优化器根据统计信息自动选择
   - 通常选择结果集较小的表作为驱动表

2. 选择 JOIN 算法
   - 有索引 → Nested Loop Join
   - 无索引 + 等值连接 → Hash Join (MySQL 8.0.18+)
   - 无索引 + 非等值连接 → Block Nested Loop

3. 执行连接
   - 从驱动表读取一行(或一批)数据
   - 在被驱动表中查找匹配的行
   - 将匹配的行组合后输出
   - 重复直到驱动表遍历完成
```

**索引对 JOIN 性能的关键影响:**
- **驱动表**: 全表扫描,索引影响不大
- **被驱动表**: 连接字段**必须有索引**,否则每次都要全表扫描

示例性能对比:
```
场景: 1000行驱动表 JOIN 10000行被驱动表

有索引: 1000 × log(10000) ≈ 1000 × 13 ≈ 13000 次比较
无索引: 1000 × 10000 = 1000万 次比较 (灾难!)
```

### 2. JOIN 类型详解

| JOIN类型 | 返回数据 | NULL处理 | 使用场景 |
|---------|---------|---------|---------|
| INNER JOIN | 两表匹配的记录 | 不返回NULL | 必须有关联关系的数据 |
| LEFT JOIN | 左表全部+右表匹配 | 右表不匹配返回NULL | 保留左表所有记录 |
| RIGHT JOIN | 右表全部+左表匹配 | 左表不匹配返回NULL | 保留右表所有记录(少用) |
| CROSS JOIN | 笛卡尔积(M×N) | - | 生成组合数据 |

**结果集大小对比:**
```sql
-- 假设: users 有 1000 行, orders 有 20000 行
-- 每个用户平均 20 个订单

INNER JOIN: ≈ 20000 行 (只返回有订单的用户)
LEFT JOIN:  ≈ 20000 行 (如果所有用户都有订单)
            ≈ 20100 行 (如果有100个用户无订单)
CROSS JOIN: 1000 × 20000 = 2000万行 (慎用!)
```

### 3. INNER JOIN vs LEFT JOIN 的本质区别

**INNER JOIN (内连接):**
```sql
SELECT * FROM A INNER JOIN B ON A.id = B.a_id;

执行逻辑:
1. 取 A 表一行: A.id = 1
2. 在 B 表找 B.a_id = 1 的行
3. 找到匹配 → 输出组合行
4. 找不到 → 丢弃该行,不输出
```

**LEFT JOIN (左外连接):**
```sql
SELECT * FROM A LEFT JOIN B ON A.id = B.a_id;

执行逻辑:
1. 取 A 表一行: A.id = 1
2. 在 B 表找 B.a_id = 1 的行
3. 找到匹配 → 输出组合行
4. 找不到 → 仍然输出 A 表的行,B 表字段填充 NULL
```

**关键差异:**
- INNER JOIN: 严格匹配,不匹配则丢弃
- LEFT JOIN: 保留左表,右表不匹配用 NULL 填充
- 结果集: LEFT JOIN ≥ INNER JOIN

### 4. 驱动表选择的重要性

**什么是驱动表?**
- JOIN 时先扫描的表(外层循环)
- MySQL 优化器自动选择,通常是结果集较小的表

**为什么小表做驱动表?**
```sql
-- 场景: A表 100行, B表 10000行, B.a_id 有索引

-- 方案1: A 驱动 B (好)
SELECT * FROM A JOIN B ON A.id = B.a_id;
成本: 100 × log(10000) ≈ 100 × 13 = 1300 次比较

-- 方案2: B 驱动 A (差)
SELECT * FROM B JOIN A ON A.id = B.a_id;
成本: 10000 × log(100) ≈ 10000 × 7 = 70000 次比较
```

**如何确认驱动表?**
```sql
EXPLAIN SELECT * FROM orders o JOIN users u ON o.user_id = u.id;

-- 查看 EXPLAIN 结果中的 table 字段顺序
-- 第一个出现的表是驱动表
```

**强制指定驱动表 (一般不需要):**
```sql
-- STRAIGHT_JOIN: 强制左表为驱动表
SELECT * FROM small_table STRAIGHT_JOIN large_table
ON small_table.id = large_table.fk;
```

---

## 1. INNER JOIN 内连接

### 知识点: INNER JOIN 执行原理

**定义:**
返回两个表中满足连接条件的记录,不满足条件的记录会被丢弃

**执行过程 (Nested Loop Join):**
```
1. 选择小表(users)作为驱动表
2. 全表扫描驱动表的每一行
3. 对每一行,根据 ON 条件在被驱动表(orders)中查找匹配行
   - 如果 orders.user_id 有索引: 使用索引快速查找 O(log N)
   - 如果无索引: 全表扫描 O(N)
4. 匹配成功 → 组合成结果行
   匹配失败 → 丢弃该行
```

**性能特点:**
- 结果集 ≤ min(表A行数, 表B行数)
- 被驱动表的连接字段**必须有索引**,否则性能极差
- 适合查询必须有关联关系的数据

**与 WHERE 的等价写法:**
```sql
-- INNER JOIN (推荐)
SELECT * FROM orders o INNER JOIN users u ON o.user_id = u.id;

-- WHERE 子句 (旧写法,不推荐)
SELECT * FROM orders o, users u WHERE o.user_id = u.id;
```

### 1.1 两表连接
```sql
-- 查询所有订单及对应的用户信息
SELECT
  o.order_no,
  u.username,
  o.pay_amount,
  o.status
FROM orders o
INNER JOIN users u ON o.user_id = u.id
LIMIT 50;
```

### 1.2 查看订单详情
```sql
-- 查询订单明细及对应的商品信息
SELECT
  oi.order_id,
  p.name AS product_name,
  oi.price,
  oi.quantity,
  oi.total_amount
FROM order_items oi
INNER JOIN products p ON oi.product_id = p.id
LIMIT 50;
```

### 1.3 三表连接
```sql
-- 查询订单、用户、支付信息
SELECT
  o.order_no,
  u.username,
  o.pay_amount,
  p.payment_method,
  p.paid_at
FROM orders o
INNER JOIN users u ON o.user_id = u.id
INNER JOIN payments p ON o.id = p.order_id
WHERE o.status >= 1  -- 已支付的订单
LIMIT 50;
```

### 1.4 四表连接
```sql
-- 查询完整的订单购买信息
SELECT
  u.username AS 用户名,
  o.order_no AS 订单号,
  p.name AS 商品名称,
  oi.quantity AS 购买数量,
  o.created_at AS 订单创建时间
FROM orders o
INNER JOIN users u ON o.user_id = u.id
INNER JOIN order_items oi ON o.id = oi.order_id
INNER JOIN products p ON oi.product_id = p.id
ORDER BY o.created_at DESC
LIMIT 30;
```

---

## 2. LEFT JOIN 左外连接

### 知识点: LEFT JOIN 的工作机制

**定义:**
返回左表的所有记录,以及右表中匹配的记录。右表不匹配时,相关字段填充 NULL

**执行过程:**
```
1. 全表扫描左表(users)
2. 对左表的每一行:
   - 在右表(orders)中查找匹配的行
   - 找到匹配 → 输出组合行
   - 找不到 → 输出左表行 + 右表字段全部为 NULL
3. 保证左表的每一行都会出现在结果中
```

**结果集特点:**
- 行数 = 左表行数 + 右表匹配行数(一对多情况)
- 一定 ≥ 左表行数
- 右表字段可能包含 NULL

**典型应用场景:**

**1. 查找未匹配的记录**
```sql
-- 查找从未下单的用户
SELECT u.* FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.id IS NULL;  -- 关键: 右表主键为 NULL 说明无匹配
```

**2. 统计包含0值的数据**
```sql
-- 统计所有用户的订单数(包括0订单用户)
SELECT u.username, COUNT(o.id) as order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id;
-- COUNT(o.id) 不统计 NULL,所以无订单用户 count=0
```

**3. 数据完整性检查**
```sql
-- 检查是否有订单没有对应的用户(数据异常)
SELECT o.* FROM orders o
LEFT JOIN users u ON o.user_id = u.id
WHERE u.id IS NULL;  -- 孤儿订单
```

### 2.1 查询所有用户及其订单
```sql
-- 查询所有用户，包括没有下过订单的用户
SELECT
  u.username,
  u.email,
  COUNT(o.id) as order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.username, u.email
ORDER BY order_count DESC
LIMIT 50;
```

### 2.2 查询未支付的订单
```sql
-- 查询所有订单及支付信息，包括还未支付的订单
SELECT
  o.order_no,
  o.pay_amount,
  p.payment_no,
  CASE
    WHEN p.status IS NULL THEN '未支付'
    WHEN p.status = 0 THEN '待支付'
    WHEN p.status = 1 THEN '已支付'
    WHEN p.status = 2 THEN '支付失败'
  END as payment_status
FROM orders o
LEFT JOIN payments p ON o.id = p.order_id
WHERE o.status = 0 OR p.payment_no IS NULL
LIMIT 50;
```

### 2.3 找出没有购买记录的用户
```sql
-- 查询从未下过订单的用户
SELECT
  u.id,
  u.username,
  u.created_at
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.id IS NULL
LIMIT 50;
```

### 2.4 商品销售情况
```sql
-- 查询所有商品及其销售数量，包括从未被购买过的商品
SELECT
  p.id,
  p.name,
  IFNULL(SUM(oi.quantity), 0) as total_sold,
  IFNULL(SUM(oi.total_amount), 0) as total_revenue
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.id AND o.status = 3
GROUP BY p.id, p.name
ORDER BY total_sold DESC
LIMIT 50;
```

---

## 3. RIGHT JOIN 右外连接

### 知识点: RIGHT JOIN vs LEFT JOIN

**RIGHT JOIN 原理:**
- 与 LEFT JOIN 相反,保留右表所有记录
- 左表不匹配时,左表字段填充 NULL

**为什么很少使用 RIGHT JOIN?**
1. **可读性差**: 主表在右侧,不符合阅读习惯
2. **可完全替代**: 任何 RIGHT JOIN 都可以改写为 LEFT JOIN
3. **团队规范**: 大多数团队禁止使用 RIGHT JOIN

**等价改写:**
```sql
-- RIGHT JOIN
SELECT * FROM A RIGHT JOIN B ON A.id = B.a_id;

-- 等价的 LEFT JOIN (推荐)
SELECT * FROM B LEFT JOIN A ON A.id = B.a_id;
```

**实际应用建议:**
- ✅ 统一使用 LEFT JOIN,主表放左边
- ❌ 避免使用 RIGHT JOIN,降低代码可读性
- ✅ 如果需要右表驱动,调整表顺序即可

### 3.1 练习 RIGHT JOIN
```sql
-- 将 1.1 的查询改写为 RIGHT JOIN
-- 从订单表出发，右连接用户表
SELECT
  o.order_no,
  u.username,
  o.pay_amount,
  o.status
FROM users u
RIGHT JOIN orders o ON u.id = o.user_id
LIMIT 50;

-- 结果应该与 INNER JOIN 相同（因为orders.user_id有外键约束）
```

### 3.2 对比 LEFT 和 RIGHT
```sql
-- LEFT JOIN：以users为主表
SELECT u.username, o.order_no
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
-- 结果：包含所有用户，即使没有订单

-- RIGHT JOIN：以orders为主表
SELECT u.username, o.order_no
FROM users u
RIGHT JOIN orders o ON u.id = o.user_id
-- 结果：只包含下过单的用户
```

---

## 6. 连接条件优化

### 知识点: ON vs WHERE 的区别

**执行时机不同:**
- **ON**: 在 JOIN 阶段过滤,决定是否生成连接行
- **WHERE**: 在 JOIN 完成后过滤,对结果集进行筛选

**对 INNER JOIN 的影响:**
```sql
-- 两种写法结果相同,性能也相同
SELECT * FROM users u
JOIN orders o ON u.id = o.user_id AND o.status = 1;

SELECT * FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.status = 1;
```

**对 LEFT JOIN 的影响 - 关键区别!**
```sql
-- 写法1: 条件在 ON 中
SELECT u.*, o.order_no
FROM users u
LEFT JOIN orders o ON u.id = o.user_id AND o.status = 1;
-- 结果: 返回所有用户,但只显示 status=1 的订单,其他订单显示 NULL

-- 写法2: 条件在 WHERE 中
SELECT u.*, o.order_no
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.status = 1;
-- 结果: 只返回有 status=1 订单的用户 (LEFT JOIN 变成了 INNER JOIN!)
```

**原理解释:**
```
ON 条件:
1. JOIN 时判断是否匹配
2. 不匹配 → 左表行仍保留,右表字段为 NULL

WHERE 条件:
1. JOIN 完成后过滤结果
2. WHERE o.status = 1 会过滤掉 o.status 为 NULL 的行
3. 导致左表未匹配的行也被过滤掉
```

**最佳实践:**
- ✅ LEFT JOIN 的过滤条件应该放在 ON 中(保持左表完整性)
- ✅ INNER JOIN 的条件放 ON 或 WHERE 都可以
- ⚠️ 注意 WHERE 会改变 LEFT JOIN 的语义

### 6.1 使用 USING
```sql
-- USING 要求两表的连接字段名完全相同
-- 当字段名相同时，可以简化JOIN语法

-- USING的优点：
-- 1. 语法更简洁
-- 2. 结果集中不会重复显示连接字段
-- USING的限制：
-- 1. 字段名必须完全相同
-- 2. 只能用于等值连接
```

### 6.2 多条件连接
```sql
-- 连接条件包含价格范围和状态
SELECT
  o.order_no,
  oi.product_name,
  oi.price,
  p.name,
  p.price as current_price
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id AND p.price > 100
WHERE o.status = 3
LIMIT 50;
```

---

## 7. 子查询与连接

### 知识点: JOIN vs 子查询性能对比

**子查询的分类:**
1. **非相关子查询**: 子查询独立执行,执行1次
2. **相关子查询**: 子查询依赖外层,执行N次(性能差)

**性能对比:**

**场景1: 简单过滤 - IN 子查询 vs JOIN**
```sql
-- 方法1: IN 子查询 (非相关)
SELECT * FROM users
WHERE id IN (SELECT user_id FROM orders WHERE status = 3);
-- 执行: 子查询1次,外层查询使用结果集

-- 方法2: JOIN
SELECT DISTINCT u.* FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.status = 3;
-- 执行: 一次连接操作,需要去重

-- 性能:
-- MySQL 8.0+ 优化器会自动转换,性能相当
-- 旧版本 JOIN 通常更快
```

**场景2: 相关子查询 vs JOIN (重要!)**
```sql
-- 方法1: 相关子查询 (性能差)
SELECT p.*,
  (SELECT COUNT(*) FROM order_items oi WHERE oi.product_id = p.id) as sales_count
FROM products p;
-- 执行: products 每行都执行一次子查询
-- 如果 products 有 500 行 → 执行 500 次子查询

-- 方法2: LEFT JOIN + GROUP BY (性能好)
SELECT p.*, COUNT(oi.id) as sales_count
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
GROUP BY p.id;
-- 执行: 一次连接 + 一次分组,性能远超相关子查询
```

**场景3: EXISTS vs JOIN**
```sql
-- 方法1: EXISTS (适合大表)
SELECT * FROM products p
WHERE EXISTS (
  SELECT 1 FROM order_items WHERE product_id = p.id
);
-- 执行: 对每行检查是否存在,找到第一条匹配就返回 true

-- 方法2: IN (适合小表)
SELECT * FROM products p
WHERE id IN (SELECT product_id FROM order_items);
-- 执行: 先获取子查询的完整结果集,再匹配

-- 方法3: JOIN
SELECT DISTINCT p.* FROM products p
JOIN order_items oi ON p.id = oi.product_id;
-- 执行: 连接后去重

-- 性能建议:
-- 子查询结果集很大 → EXISTS
-- 子查询结果集很小 → IN
-- 需要返回关联表字段 → JOIN
```

**选择原则:**
1. **避免相关子查询** - 优先改写为 JOIN
2. **EXISTS vs IN** - 根据数据量选择
3. **需要多表字段** - 使用 JOIN
4. **只需要过滤** - 子查询可能更清晰

### 7.1 用子查询替代连接
```sql
-- 方法1：使用 JOIN
SELECT DISTINCT u.username, u.email
FROM users u
JOIN orders o ON u.id = o.user_id
JOIN order_items oi ON o.id = oi.order_id
WHERE oi.product_id = 100;

-- 方法2：使用子查询
SELECT username, email
FROM users
WHERE id IN (
  SELECT user_id FROM orders WHERE id IN (
    SELECT order_id FROM order_items WHERE product_id = 100
  )
);

-- 对比：JOIN通常性能更好，但子查询更易读
```

### 7.2 连接替代子查询
```sql
-- 查询订单金额大于用户平均订单金额的订单
-- 使用JOIN实现
SELECT
  o1.order_no,
  o1.user_id,
  o1.pay_amount,
  avg_orders.avg_amount
FROM orders o1
JOIN (
  SELECT user_id, AVG(pay_amount) as avg_amount
  FROM orders
  GROUP BY user_id
) avg_orders ON o1.user_id = avg_orders.user_id
WHERE o1.pay_amount > avg_orders.avg_amount
ORDER BY o1.pay_amount DESC
LIMIT 50;
```

---

## 8. CROSS JOIN 交叉连接

### 知识点: 笛卡尔积的原理与应用

**什么是笛卡尔积?**
- 两个集合的所有可能组合
- 结果行数 = 表A行数 × 表B行数

**CROSS JOIN 原理:**
```sql
-- 显式写法
SELECT * FROM A CROSS JOIN B;

-- 隐式写法 (省略 ON 条件)
SELECT * FROM A, B;

-- 结果:
-- A 的每一行 与 B 的每一行组合
-- 如果 A 有 m 行, B 有 n 行 → 结果 m × n 行
```

**示例理解:**
```sql
-- 表 colors: 3行
-- 表 sizes: 4行
SELECT * FROM colors CROSS JOIN sizes;
-- 结果: 3 × 4 = 12 行 (所有颜色和尺码的组合)
```

**应用场景:**

**1. 生成组合数据**
```sql
-- 为每个商品生成所有规格组合
SELECT
  p.name,
  c.color,
  s.size
FROM products p
CROSS JOIN colors c
CROSS JOIN sizes s
WHERE p.category = '服装';
-- 生成: 商品 × 颜色 × 尺码 的所有组合
```

**2. 生成日期序列**
```sql
-- 生成最近7天的日期
SELECT DATE_SUB(CURDATE(), INTERVAL n.num DAY) as date
FROM (
  SELECT 0 as num UNION SELECT 1 UNION SELECT 2 UNION SELECT 3
  UNION SELECT 4 UNION SELECT 5 UNION SELECT 6
) n;
```

**3. 数据填充(测试数据)**
```sql
-- 为每个用户生成测试订单
INSERT INTO test_orders (user_id, product_id)
SELECT u.id, p.id
FROM users u CROSS JOIN products p
WHERE u.id <= 10 AND p.id <= 5;
-- 生成 10 × 5 = 50 条测试订单
```

**性能警告 ⚠️:**
```sql
-- 危险示例: 意外的笛卡尔积
SELECT * FROM orders o, order_items oi, products p
WHERE o.status = 1;
-- 忘记写 JOIN 条件!
-- 如果 orders:10000行, order_items:50000行, products:500行
-- 结果: 10000 × 50000 × 500 = 2500亿行! (数据库卡死)

-- 正确写法:
SELECT * FROM orders o
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
WHERE o.status = 1;
```

**使用建议:**
- ✅ 明确需要笛卡尔积时使用
- ✅ 生成组合数据、测试数据
- ❌ 避免意外的笛卡尔积(忘记 JOIN 条件)
- ⚠️ 注意结果集大小,防止内存溢出

### 8.1 笛卡尔积
```sql
-- 生成商品和颜色的组合
SELECT
  p.id,
  p.name,
  colors.color
FROM (
  SELECT id, name FROM products WHERE status = 1 LIMIT 5
) p
CROSS JOIN (
  SELECT '红色' as color
  UNION SELECT '黑色'
  UNION SELECT '白色'
  UNION SELECT '蓝色'
  UNION SELECT '灰色'
) colors
ORDER BY p.id, colors.color;

-- 结果：5个商品 × 5个颜色 = 25条记录
```

---

## 9. 综合实战

### 9.1 订单完整信息查询
```sql
-- 查询订单的完整信息
SET @order_no = (SELECT order_no FROM orders LIMIT 1);

SELECT
  -- 订单基本信息
  o.order_no,
  o.total_amount,
  o.pay_amount,
  CASE o.status
    WHEN 0 THEN '待支付'
    WHEN 1 THEN '已支付'
    WHEN 2 THEN '已发货'
    WHEN 3 THEN '已完成'
    WHEN 4 THEN '已取消'
  END as order_status,
  o.created_at,

  -- 买家信息
  u.username,
  u.email,
  u.phone,

  -- 收货地址
  o.receiver_name,
  o.receiver_phone,
  o.receiver_address,

  -- 订单商品明细
  -- 使用 GROUP BY 配合 GROUP_CONCAT 可以将同一订单的多个商品明细聚合到一行显示
  GROUP_CONCAT(
    CONCAT(oi.product_name, ' x', oi.quantity, ' @', oi.price)
    SEPARATOR '; '
  ) as order_items,

  -- 支付信息
  p.payment_method,
  p.payment_no,
  p.paid_at

FROM orders o
JOIN users u ON o.user_id = u.id
LEFT JOIN order_items oi ON o.id = oi.order_id
LEFT JOIN payments p ON o.id = p.order_id
WHERE o.order_no = @order_no
GROUP BY o.id, o.order_no, o.total_amount, o.pay_amount, o.status,
         o.created_at, u.username, u.email, u.phone,
         o.receiver_name, o.receiver_phone, o.receiver_address,
         p.payment_method, p.payment_no, p.paid_at;
```

### 9.2 商品销售分析
```sql
-- 分析每个分类下商品的销售情况（一级分类）
-- 注意：商品关联的是二级分类，需要通过二级分类聚合到一级分类
SELECT
  c1.name as category_name,
  COUNT(DISTINCT p.id) as product_count,
  SUM(oi.quantity) as total_quantity,
  SUM(oi.total_amount) as total_revenue,
  AVG(oi.price) as avg_price
FROM categories c1
JOIN categories c2 ON c2.parent_id = c1.id  -- c2是二级分类
JOIN products p ON c2.id = p.category_id
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.id AND o.status = 3
WHERE c1.level = 1  -- 只看一级分类
GROUP BY c1.id, c1.name
HAVING total_revenue > 0
ORDER BY total_revenue DESC;
```

### 9.3 用户行为分析
```sql
SELECT
  u.username,
  COUNT(DISTINCT o.id) as order_count,
  COUNT(DISTINCT c.id) as cart_count,
  COUNT(DISTINCT pr.id) as review_count,
  u.created_at as register_time,
  MAX(o.created_at) as last_order_time
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
LEFT JOIN cart_items c ON u.id = c.user_id
LEFT JOIN product_reviews pr ON u.id = pr.user_id
WHERE EXISTS (SELECT 1 FROM orders WHERE user_id = u.id)  -- 只显示有购买行为的用户
GROUP BY u.id, u.username, u.created_at
ORDER BY order_count DESC
LIMIT 100;

这个sql很慢，执行计划如下：
--------------------+
| id | select_type | table  | partitions | type   | possible_keys | key         | key_len | ref                     | rows  | filtered | Extra                                                   |
+----+-------------+--------+------------+--------+---------------+-------------+---------+-------------------------+-------+----------+---------------------------------------------------------+
|  1 | SIMPLE      | orders | NULL       | index  | idx_user_id   | idx_user_id | 8       | NULL                    | 19816 |     5.05 | Using index; Using temporary; Using filesort; LooseScan |
|  1 | SIMPLE      | u      | NULL       | eq_ref | PRIMARY       | PRIMARY     | 8       | study_db.orders.user_id |     1 |   100.00 | NULL                                                    |
|  1 | SIMPLE      | o      | NULL       | ref    | idx_user_id   | idx_user_id | 8       | study_db.orders.user_id |    19 |   100.00 | NULL                                                    |
|  1 | SIMPLE      | c      | NULL       | ref    | idx_user_id   | idx_user_id | 8       | study_db.orders.user_id |     4 |   100.00 | Using index                                             |
|  1 | SIMPLE      | pr     | NULL       | ref    | idx_user_id   | idx_user_id | 8       | study_db.orders.user_id |    19 |   100.00 | Using index                                             |
+----+-------------+--------+------------+--------+---------------+-------------+---------+-------------------------+-------+----------+---------------------------------------------------------+

  1. Using temporary; Using filesort - 需要创建临时表并进行文件排序，这是最大的性能瓶颈
  2. 扫描行数多 - 第一步就扫描了 19816 行
  3. 多个 LEFT JOIN - 导致数据膨胀，每个用户可能产生大量笛卡尔积组合
  4. COUNT(DISTINCT) - 对膨胀后的数据集进行去重统计，开销大


  LooseScan 是 MySQL 对 EXISTS 子查询的半连接优化策略之一。

  它的工作原理：
  - 扫描索引时，只读取每个分组的第一条记录就跳过（loose，松散的）
  - 避免全表扫描来验证 EXISTS 条件
  - 类似于 GROUP BY 使用索引的 "Loose Index Scan"

  在你的查询中：
  WHERE EXISTS (SELECT 1 FROM orders WHERE user_id = u.id)
  MySQL 使用 LooseScan 优化：
  1. 利用 orders.idx_user_id 索引
  2. 对每个 user_id，只要找到第一条记录就确认存在
  3. 跳过该 user_id 的其他记录


  其他半连接优化策略：
  - FirstMatch - 找到第一个匹配就返回
  - Duplicate Weedout - 使用临时表去重
  - Materialization - 将子查询物化成临时表


-- 优化方案：使用子查询分别统计，避免笛卡尔积
  SELECT
    u.username,
    IFNULL(order_stats.order_count, 0) as order_count,
    IFNULL(cart_stats.cart_count, 0) as cart_count,
    IFNULL(review_stats.review_count, 0) as review_count,
    u.created_at as register_time,
    order_stats.last_order_time
  FROM users u
  INNER JOIN (
    SELECT user_id, COUNT(*) as order_count, MAX(created_at) as last_order_time
    FROM orders
    GROUP BY user_id
  ) order_stats ON u.id = order_stats.user_id
  LEFT JOIN (
    SELECT user_id, COUNT(*) as cart_count FROM cart_items GROUP BY user_id
  ) cart_stats ON u.id = cart_stats.user_id
  LEFT JOIN (
    SELECT user_id, COUNT(*) as review_count FROM product_reviews GROUP BY user_id
  ) review_stats ON u.id = review_stats.user_id
  ORDER BY order_count DESC
  LIMIT 100;

```

### 9.4 复购率分析
```sql
SELECT
  u.id,
  u.username,
  COUNT(o.id) as purchase_count,
  MIN(o.created_at) as first_purchase,
  MAX(o.created_at) as last_purchase,
  DATEDIFF(MAX(o.created_at), MIN(o.created_at)) as customer_lifetime_days
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.status = 3
GROUP BY u.id, u.username
HAVING purchase_count >= 3
ORDER BY purchase_count DESC
LIMIT 50;
```

---

## 学习要点总结

### 1. JOIN类型的选择原则

```sql
-- INNER JOIN：只要匹配的数据
SELECT ... FROM A INNER JOIN B ON A.id = B.a_id;

-- LEFT JOIN：保留左表所有数据
SELECT ... FROM A LEFT JOIN B ON A.id = B.a_id;

-- RIGHT JOIN：保留右表所有数据（少用，用LEFT代替）
SELECT ... FROM A RIGHT JOIN B ON A.id = B.a_id;
-- 等同于：
SELECT ... FROM B LEFT JOIN A ON A.id = B.a_id;

-- CROSS JOIN：笛卡尔积
SELECT ... FROM A CROSS JOIN B;
```

### 2. JOIN性能优化技巧

1. **小表驱动大表**
   ```sql
   -- 好：小表在前
   FROM products (500行) JOIN order_items (50000行)

   -- 不好：大表在前
   FROM order_items (50000行) JOIN products (500行)
   ```

2. **确保连接字段有索引**
   ```sql
   -- 检查索引
   SHOW INDEX FROM orders WHERE Column_name = 'user_id';

   -- 如果没有，创建索引
   CREATE INDEX idx_user_id ON orders(user_id);
   ```

3. **避免SELECT ***
   ```sql
   -- 不好
   SELECT * FROM orders o JOIN users u ON ...;

   -- 好：只选需要的字段
   SELECT o.order_no, u.username, o.total_amount FROM ...;
   ```

4. **使用EXPLAIN分析**
   ```sql
   EXPLAIN SELECT ...;
   -- 观察：type, key, rows, Extra
   ```

### 3. 常见问题和解决方案

**问题1：LEFT JOIN变成INNER JOIN**
```sql
-- 错误写法：WHERE条件使LEFT JOIN失效
SELECT u.*, o.order_no
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.status = 1;  -- ❌ 这会过滤掉没有订单的用户

-- 正确写法：条件放在ON中
SELECT u.*, o.order_no
FROM users u
LEFT JOIN orders o ON u.id = o.user_id AND o.status = 1;  -- ✅
```

**问题2：重复数据**
```sql
-- 一对多关联会产生重复
SELECT u.username, o.order_no
FROM users u
JOIN orders o ON u.id = o.user_id;
-- 一个用户有多个订单，username会重复

-- 解决方案1：使用DISTINCT
SELECT DISTINCT u.username FROM ...;

-- 解决方案2：使用GROUP BY
SELECT u.username, COUNT(o.id) as order_count
FROM users u
JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.username;
```

**问题3：NULL值处理**
```sql
-- LEFT JOIN可能产生NULL
SELECT u.username, IFNULL(o.order_no, '无订单') as order_no
FROM users u
LEFT JOIN orders o ON u.id = o.user_id;
```

### 4. JOIN 优化最佳实践

**1. 确保连接字段有索引**
```sql
-- 检查索引
SHOW INDEX FROM orders WHERE Column_name = 'user_id';

-- 如果没有,创建索引
CREATE INDEX idx_user_id ON orders(user_id);

-- 性能提升: 10倍 ~ 1000倍
```

**2. 小表驱动大表**
```sql
-- MySQL 优化器通常会自动选择
-- 但可以用 STRAIGHT_JOIN 强制指定

-- ✅ 好: 小表驱动
SELECT * FROM small_table
STRAIGHT_JOIN large_table ON small_table.id = large_table.fk;

-- ❌ 差: 大表驱动
SELECT * FROM large_table
STRAIGHT_JOIN small_table ON small_table.id = large_table.fk;
```

**3. 避免 SELECT ***
```sql
-- ❌ 差: 查询所有字段,浪费IO
SELECT * FROM orders o JOIN users u ON o.user_id = u.id;

-- ✅ 好: 只查询需要的字段
SELECT o.order_no, u.username, o.total_amount
FROM orders o JOIN users u ON o.user_id = u.id;
```

**4. 使用 EXPLAIN 分析**
```sql
EXPLAIN SELECT * FROM orders o JOIN users u ON o.user_id = u.id;

-- 关注:
-- type: eq_ref/ref 较好, ALL 很差
-- key: 是否使用了索引
-- rows: 扫描行数,越少越好
-- Extra: Using join buffer(Block Nested Loop) 说明无索引
```

**5. 避免在 JOIN 条件中使用函数**
```sql
-- ❌ 差: 索引失效
SELECT * FROM orders o
JOIN users u ON DATE(o.created_at) = u.register_date;

-- ✅ 好: 保持条件简单
SELECT * FROM orders o
JOIN users u ON o.user_id = u.id
WHERE DATE(o.created_at) = u.register_date;
```

**6. 控制 JOIN 表的数量**
```sql
-- 一般建议: 不超过5个表 JOIN
-- 更多表时考虑:
-- 1. 拆分为多个查询
-- 2. 使用临时表
-- 3. 应用层组装数据
```

**7. LEFT JOIN 注意事项**
```sql
-- ❌ WHERE 条件把 LEFT JOIN 变成 INNER JOIN
SELECT u.*, o.order_no
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.status = 1;  -- 过滤掉了无订单的用户

-- ✅ 正确: 条件放 ON 中
SELECT u.*, o.order_no
FROM users u
LEFT JOIN orders o ON u.id = o.user_id AND o.status = 1;
```

### 5. 何时使用 JOIN vs 子查询

| 场景 | 推荐方式 | 原因 |
|-----|---------|-----|
| 需要返回多表字段 | JOIN | 一次查询获取所有数据 |
| 只需要过滤条件 | 子查询 | 逻辑更清晰 |
| 大数据量统计 | JOIN | 性能通常更好 |
| 相关子查询 | 改写为 JOIN | 避免 N 次查询 |
| 递归查询 | 递归 CTE | 子查询无法实现 |

**示例:**
```sql
-- ✅ 需要多表字段 → JOIN
SELECT u.username, o.order_no, o.total_amount
FROM users u
JOIN orders o ON u.id = o.user_id;

-- ✅ 只需要过滤 → 子查询(可读性好)
SELECT username FROM users
WHERE id IN (SELECT user_id FROM orders WHERE total_amount > 1000);

-- ❌ 相关子查询 → 改写为 JOIN
-- 差:
SELECT p.*, (SELECT COUNT(*) FROM order_items WHERE product_id = p.id)
FROM products p;
-- 好:
SELECT p.*, COUNT(oi.id)
FROM products p LEFT JOIN order_items oi ON p.id = oi.product_id
GROUP BY p.id;
```

### 6. 常见问题诊断

**问题1: JOIN 很慢**
```sql
-- 检查清单:
1. EXPLAIN 查看是否使用索引 (key 字段)
2. 检查连接字段是否有索引
3. 是否小表驱动大表
4. 是否 SELECT * (改为具体字段)
5. 检查 rows 扫描行数是否过多
```

**问题2: 结果行数比预期多**
```sql
-- 原因: 一对多关系导致笛卡尔积膨胀
-- 解决:
1. 使用 DISTINCT 去重
2. 使用 GROUP BY 聚合
3. 检查 ON 条件是否正确
```

**问题3: LEFT JOIN 返回 NULL 很多**
```sql
-- 检查:
1. 右表是否真的没有匹配数据
2. ON 条件是否正确
3. 是否应该用 INNER JOIN
```

---

## 性能优化总结

**JOIN 性能优化清单:**
- ✅ 连接字段建立索引
- ✅ 小表驱动大表
- ✅ 只查询需要的字段(避免 SELECT *)
- ✅ 使用 EXPLAIN 分析执行计划
- ✅ 避免在 JOIN 条件中使用函数
- ✅ 控制 JOIN 表数量(≤5)
- ✅ LEFT JOIN 条件放 ON,不要放 WHERE
- ✅ 避免相关子查询,改写为 JOIN
- ✅ 注意笛卡尔积陷阱

继续加油，进入第三阶段学习！
