# 第四阶段：高级查询完整答案

## 核心知识点

### 1. 子查询的分类与执行原理

**按位置分类:**
- **SELECT 子查询**: 返回标量值,作为查询字段
- **FROM 子查询**: 返回临时表,作为数据源(派生表)
- **WHERE 子查询**: 返回值用于条件判断

**按返回结果分类:**
- **标量子查询**: 返回单个值(1行1列)
- **列子查询**: 返回一列多行,常配合 IN/ANY/ALL
- **行子查询**: 返回一行多列,用于行比较
- **表子查询**: 返回多行多列,作为临时表

**执行方式:**
- **非相关子查询**: 子查询独立执行一次,结果用于外层查询
  ```sql
  SELECT * FROM products
  WHERE price > (SELECT AVG(price) FROM products);
  -- 子查询先执行,返回平均价格,外层查询使用该值
  ```

- **相关子查询**: 子查询依赖外层查询,对外层每行执行一次
  ```sql
  SELECT p1.* FROM products p1
  WHERE price > (SELECT AVG(price) FROM products p2 WHERE p2.category_id = p1.category_id);
  -- 外层每行都执行子查询,性能较差
  ```

**性能对比:**
```
非相关子查询: 执行1次
相关子查询: 执行N次(N=外层行数) → 性能瓶颈
```

### 2. CTE (WITH 子句) 原理

**什么是 CTE?**
- Common Table Expression (公共表表达式)
- 临时命名的结果集,仅在查询期间存在
- 可被同一查询多次引用

**语法:**
```sql
WITH cte_name AS (
  SELECT ...
)
SELECT * FROM cte_name;
```

**优势:**
1. **提高可读性**: 将复杂查询拆分为多个步骤
2. **避免重复**: 同一子查询可被多次引用
3. **递归查询**: 支持递归 CTE(树形结构遍历)

**执行原理:**
- **非递归 CTE**: MySQL 可能物化为临时表,也可能内联展开
- **递归 CTE**: 迭代执行,直到满足终止条件

**CTE vs 子查询:**
| 对比项 | CTE | 子查询 |
|-------|-----|--------|
| 可读性 | ✅ 高 | ❌ 嵌套复杂 |
| 可复用 | ✅ 可多次引用 | ❌ 需要重复写 |
| 递归 | ✅ 支持 | ❌ 不支持 |
| 性能 | 类似 | 类似 |

### 3. 窗口函数原理

**窗口函数 vs 聚合函数:**
| 对比项 | 聚合函数 | 窗口函数 |
|-------|---------|---------|
| 行数变化 | 多行→1行 | 不减少行数 |
| 分组 | GROUP BY | PARTITION BY |
| 排序 | ORDER BY(可选) | ORDER BY(常用) |

**核心概念:**
- **窗口(Window)**: 当前行及其相关行的集合
- **分区(PARTITION BY)**: 将数据分组,每组独立计算
- **排序(ORDER BY)**: 定义窗口内的行顺序
- **窗口框架(FRAME)**: 窗口内的具体行范围

**常用窗口函数:**

**1. 排名函数:**
- `ROW_NUMBER()`: 连续排名,1,2,3,4...
- `RANK()`: 跳跃排名,1,2,2,4... (并列后跳过)
- `DENSE_RANK()`: 密集排名,1,2,2,3... (并列不跳过)

**2. 聚合窗口函数:**
- `SUM() OVER()`: 累积求和
- `AVG() OVER()`: 移动平均
- `COUNT() OVER()`: 累积计数

**3. 取值函数:**
- `LAG()`: 取前N行的值
- `LEAD()`: 取后N行的值
- `FIRST_VALUE()`: 窗口第一行的值
- `LAST_VALUE()`: 窗口最后一行的值

**执行流程:**
```
1. FROM/WHERE: 确定数据源
2. PARTITION BY: 划分分区
3. ORDER BY: 分区内排序
4. 窗口函数计算: 对每行计算窗口函数
5. SELECT: 输出结果
```

**性能优化:**
- 窗口函数需要排序,数据量大时使用临时表
- PARTITION BY 字段建索引可提升性能
- 避免复杂的窗口框架定义

---

## 1. 子查询示例

### 1.1 标量子查询 - 查询价格高于平均价格的商品
```sql
SELECT name, price,
  (SELECT AVG(price) FROM products) as avg_price,
  price - (SELECT AVG(price) FROM products) as price_diff
FROM products
WHERE price > (SELECT AVG(price) FROM products)
ORDER BY price DESC
LIMIT 20;
```

**知识点:**
- SELECT 中的子查询返回标量值(单个值)
- WHERE 中的子查询用于过滤条件
- 同一子查询被多次使用,MySQL 会优化(缓存结果)

### 1.2 IN 子查询 - 购买过高价商品的用户
```sql
SELECT id, username, email
FROM users
WHERE id IN (
  SELECT DISTINCT o.user_id
  FROM orders o
  JOIN order_items oi ON o.id = oi.order_id
  WHERE oi.price > 1000
);
```

**知识点:**
- IN 子查询返回一列值
- DISTINCT 去重,避免重复匹配
- 子查询先执行,返回用户ID列表

### 1.3 EXISTS 子查询 - 有评价的商品
```sql
SELECT id, name, price
FROM products p
WHERE EXISTS (
  SELECT 1 FROM product_reviews WHERE product_id = p.id
)
LIMIT 50;
```

**知识点:**
- EXISTS 检查是否存在匹配行,返回 true/false
- 找到第一条匹配就返回,不需要全部扫描
- SELECT 1 只是占位符,实际不返回数据

### 1.4 FROM 子查询 - 派生表
```sql
-- 查询每个分类的平均价格,并筛选高于500的分类
SELECT category_id, avg_price
FROM (
  SELECT category_id, AVG(price) as avg_price
  FROM products
  GROUP BY category_id
) as category_avg
WHERE avg_price > 500
ORDER BY avg_price DESC;
```

**知识点:**
- FROM 子查询必须有别名
- 子查询结果作为临时表使用
- 外层查询可以对子查询结果进行进一步筛选

---

## 2. CTE (WITH) 示例

### 2.1 用户消费统计
```sql
WITH user_stats AS (
  SELECT
    user_id,
    COUNT(*) as order_count,
    SUM(pay_amount) as total_amount
  FROM orders
  WHERE status = 3
  GROUP BY user_id
)
SELECT
  u.username,
  us.order_count,
  us.total_amount,
  ROUND(us.total_amount / us.order_count, 2) as avg_order
FROM users u
JOIN user_stats us ON u.id = us.user_id
WHERE us.order_count >= 5
ORDER BY us.total_amount DESC
LIMIT 50;
```

**知识点:**
- CTE 使查询逻辑更清晰,分步骤完成
- user_stats 是临时命名的结果集
- 可以像表一样 JOIN

### 2.2 多个 CTE
```sql
WITH
  recent_orders AS (
    SELECT * FROM orders
    WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
  ),
  order_summary AS (
    SELECT
      user_id,
      COUNT(*) as order_count,
      SUM(pay_amount) as total_amount
    FROM recent_orders
    WHERE status = 3
    GROUP BY user_id
  )
SELECT
  u.username,
  os.order_count,
  os.total_amount
FROM users u
JOIN order_summary os ON u.id = os.user_id
ORDER BY os.total_amount DESC
LIMIT 20;
```

**知识点:**
- 多个 CTE 用逗号分隔
- 后面的 CTE 可以引用前面的 CTE
- 提高复杂查询的可维护性

### 2.3 递归 CTE - 分类树
```sql
-- 递归查询分类及其所有子分类
WITH RECURSIVE category_tree AS (
  -- 基础查询: 顶级分类
  SELECT id, name, parent_id, 1 as level
  FROM categories
  WHERE parent_id IS NULL

  UNION ALL

  -- 递归查询: 子分类
  SELECT c.id, c.name, c.parent_id, ct.level + 1
  FROM categories c
  JOIN category_tree ct ON c.parent_id = ct.id
)
SELECT * FROM category_tree
ORDER BY level, id;
```

**知识点:**
- RECURSIVE 关键字声明递归 CTE
- 基础查询 UNION ALL 递归查询
- 递归查询引用 CTE 自身
- 自动终止(当递归查询返回空结果)

---

## 3. 窗口函数示例

### 3.1 排名函数 - 商品价格排名
```sql
SELECT
  id,
  name,
  price,
  ROW_NUMBER() OVER (ORDER BY price DESC) as row_num,
  RANK() OVER (ORDER BY price DESC) as rank_num,
  DENSE_RANK() OVER (ORDER BY price DESC) as dense_rank_num
FROM products
WHERE status = 1
LIMIT 20;
```

**知识点:**
- `ROW_NUMBER()`: 连续排名,1,2,3,4,5...
- `RANK()`: 跳跃排名,1,2,2,4,5... (两个第2名,下一个是第4名)
- `DENSE_RANK()`: 密集排名,1,2,2,3,4... (两个第2名,下一个是第3名)

### 3.2 累计计算 - 每个用户的订单累计消费
```sql
SELECT
  user_id,
  order_no,
  pay_amount,
  created_at,
  SUM(pay_amount) OVER (
    PARTITION BY user_id
    ORDER BY created_at
  ) as cumulative_spending
FROM orders
WHERE user_id <= 10
ORDER BY user_id, created_at;
```

**知识点:**
- `PARTITION BY user_id`: 按用户分区,每个用户独立计算
- `ORDER BY created_at`: 分区内按时间排序
- `SUM() OVER()`: 累计求和,不减少行数

### 3.3 分组 TOP N - 每个分类 TOP 3 商品
```sql
WITH ranked_products AS (
  SELECT
    p.*,
    c.name as category_name,
    ROW_NUMBER() OVER (
      PARTITION BY p.category_id
      ORDER BY p.sales DESC
    ) as rn
  FROM products p
  JOIN categories c ON p.category_id = c.id
  WHERE p.status = 1
)
SELECT category_name, name, price, sales, rn as rank
FROM ranked_products
WHERE rn <= 3
ORDER BY category_name, rn;
```

**知识点:**
- `PARTITION BY category_id`: 每个分类独立排名
- `ROW_NUMBER()`: 分配排名
- 外层 WHERE 筛选 TOP 3
- 这是经典的分组 TOP N 问题解法

### 3.4 取值函数 - 环比增长
```sql
SELECT
  DATE_FORMAT(created_at, '%Y-%m') as month,
  COUNT(*) as order_count,
  LAG(COUNT(*), 1) OVER (ORDER BY DATE_FORMAT(created_at, '%Y-%m')) as prev_month_count,
  COUNT(*) - LAG(COUNT(*), 1) OVER (ORDER BY DATE_FORMAT(created_at, '%Y-%m')) as growth
FROM orders
WHERE status >= 1
GROUP BY DATE_FORMAT(created_at, '%Y-%m')
ORDER BY month DESC
LIMIT 12;
```

**知识点:**
- `LAG(expr, n)`: 取前 n 行的值
- `LEAD(expr, n)`: 取后 n 行的值
- 用于计算环比、同比等指标

---

## 关键学习点总结

### 1. 子查询优化原则
- 优先使用非相关子查询(执行1次)
- 避免相关子查询(执行N次)
- JOIN 通常比子查询性能更好
- EXISTS vs IN: 大表用 EXISTS,小表用 IN

### 2. CTE 应用场景
- 提高复杂查询的可读性
- 避免重复的子查询
- 递归查询(树形结构、层级数据)
- 多步骤数据处理

### 3. 窗口函数核心
- 不减少行数,为每行计算窗口内的聚合值
- `PARTITION BY` 分区,`ORDER BY` 排序
- `ROW_NUMBER/RANK/DENSE_RANK` 用于排名
- `LAG/LEAD` 用于获取前后行的值
- 解决分组 TOP N、累计计算、环比等问题

### 4. 性能建议
- 避免相关子查询,改写为 JOIN
- CTE 适合提高可读性,但不一定提升性能
- 窗口函数需要排序,大数据量注意性能
- 使用 EXPLAIN 分析执行计划

---

## 实践建议

1. **对比查询方式**: 同一需求,尝试用 JOIN、子查询、CTE、窗口函数实现
2. **关注执行计划**: 使用 EXPLAIN 对比不同写法的性能
3. **练习窗口函数**: 排名、累计、环比等复杂统计场景
4. **理解原理**: 知道每种方式的执行逻辑和适用场景

继续努力,进入第五阶段学习索引优化!
