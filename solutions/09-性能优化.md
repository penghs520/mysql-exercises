# 第九阶段：性能优化完整指导

## 核心知识点

### 1. 性能优化方法论

**优化流程:**
```
1. 发现问题 → 2. 定位问题 → 3. 分析原因 → 4. 解决问题 → 5. 验证效果
```

**优化层次 (从上到下):**
1. **应用层**: 缓存、连接池、批量操作
2. **SQL层**: 查询优化、索引设计
3. **存储层**: 表结构、数据类型
4. **系统层**: 参数调优、硬件升级

### 2. 慢查询日志

**开启慢查询日志:**
```sql
-- 查看当前配置
SHOW VARIABLES LIKE 'slow_query%';
SHOW VARIABLES LIKE 'long_query_time';

-- 临时开启 (重启失效)
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;  -- 记录超过1秒的查询
SET GLOBAL slow_query_log_file = '/var/log/mysql/slow.log';

-- 永久配置 (my.cnf)
[mysqld]
slow_query_log = ON
long_query_time = 1
slow_query_log_file = /var/log/mysql/slow.log
```

**分析慢查询:**
```sql
-- 使用 performance_schema 查看慢查询
SELECT
  DIGEST_TEXT as query_pattern,
  COUNT_STAR as exec_count,
  AVG_TIMER_WAIT / 1000000000000 as avg_time_sec,
  MAX_TIMER_WAIT / 1000000000000 as max_time_sec,
  SUM_ROWS_EXAMINED as total_rows_examined
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME = 'study_db'
ORDER BY AVG_TIMER_WAIT DESC
LIMIT 20;
```

### 3. EXPLAIN 深度分析

**关键指标详解:**

**type (访问类型):**
- `system`: 表只有一行 (系统表)
- `const`: 主键或唯一索引的等值查询,最优
- `eq_ref`: 主键或唯一索引的连接查询
- `ref`: 非唯一索引的等值查询
- `range`: 范围查询
- `index`: 全索引扫描
- `ALL`: 全表扫描,最差

**Extra 字段详解:**
- `Using index`: 覆盖索引,只读索引不回表 ✅
- `Using where`: Server层再次过滤 ⚠️
- `Using index condition`: 索引条件下推(ICP) ✅
- `Using filesort`: 无法使用索引排序,需要额外排序 ❌
- `Using temporary`: 使用临时表 ❌
- `Using join buffer`: JOIN没用索引,用内存缓冲 ❌

### 4. 常见性能问题

**问题1: 全表扫描**
- 原因: 没有索引,或索引失效
- 解决: 添加合适的索引

**问题2: 索引失效**
- 原因: 函数、类型转换、LIKE '%xx'、OR条件
- 解决: 改写SQL,避免索引失效

**问题3: 回表过多**
- 原因: 非覆盖索引,需要回表查询
- 解决: 使用覆盖索引

**问题4: JOIN性能差**
- 原因: 连接字段无索引,大表驱动小表
- 解决: 添加索引,优化连接顺序

**问题5: 深分页慢**
- 原因: OFFSET太大,需要扫描大量数据
- 解决: 记录上次位置,延迟关联

---

## 1. 发现性能问题

### 1.1 慢查询监控

```sql
-- 开启慢查询日志
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;

-- 查看慢查询统计
SELECT
  DIGEST_TEXT as query_pattern,
  COUNT_STAR as exec_count,
  AVG_TIMER_WAIT / 1000000000000 as avg_time_sec,
  MAX_TIMER_WAIT / 1000000000000 as max_time_sec,
  SUM_ROWS_EXAMINED as total_rows_examined
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME = 'study_db'
ORDER BY AVG_TIMER_WAIT DESC
LIMIT 20;
```

### 1.2 实时监控

```sql
-- 查看当前正在执行的查询
SELECT
  id,
  user,
  host,
  db,
  command,
  time,
  state,
  LEFT(info, 100) as query
FROM information_schema.processlist
WHERE command != 'Sleep'
ORDER BY time DESC;

-- 杀掉慢查询
KILL <thread_id>;
```

---

## 2. 分析与定位

### 2.1 使用 EXPLAIN 分析

```sql
EXPLAIN SELECT
  o.*,
  u.username,
  GROUP_CONCAT(oi.product_name) as products
FROM orders o
JOIN users u ON o.user_id = u.id
LEFT JOIN order_items oi ON o.id = oi.order_id
WHERE u.username = 'user100'
GROUP BY o.id
ORDER BY o.created_at DESC
LIMIT 20;

-- 重点关注:
-- type: ALL(全表扫描) → 需要优化
-- rows: 扫描行数,越少越好
-- Extra: Using filesort/temporary → 需要优化
```

### 2.2 检查索引使用

```sql
-- 查看表的索引
SHOW INDEX FROM orders;

-- 查看索引使用情况
SELECT
  table_schema,
  table_name,
  index_name,
  cardinality,
  seq_in_index
FROM information_schema.statistics
WHERE table_schema = 'study_db'
  AND table_name = 'orders'
ORDER BY table_name, index_name, seq_in_index;
```

---

## 3. 常见优化手段

### 3.1 添加索引

```sql
-- 检查缺失的索引
SHOW INDEX FROM users WHERE Column_name = 'username';
SHOW INDEX FROM orders WHERE Column_name = 'user_id';

-- 添加单列索引
CREATE INDEX idx_username ON users(username);

-- 添加组合索引 (注意顺序)
CREATE INDEX idx_user_created ON orders(user_id, created_at);
CREATE INDEX idx_status_time ON orders(status, created_at);

-- 查看索引使用统计
SELECT
  object_schema,
  object_name,
  index_name,
  count_star,
  count_read,
  count_insert,
  count_update,
  count_delete
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE object_schema = 'study_db'
ORDER BY count_star DESC;
```

**知识点:**
- 为 WHERE、JOIN、ORDER BY 中的列建索引
- 组合索引遵循最左前缀原则
- 区分度高的列放在前面

### 3.2 优化查询语句

**避免 SELECT * :**
```sql
-- ❌ 差
SELECT * FROM orders WHERE user_id = 100;

-- ✅ 好: 只查询需要的字段
SELECT id, order_no, total_amount, created_at
FROM orders
WHERE user_id = 100;
```

**避免函数导致索引失效:**
```sql
-- ❌ 索引失效
WHERE YEAR(created_at) = 2024

-- ✅ 使用范围查询
WHERE created_at >= '2024-01-01' AND created_at < '2025-01-01'
```

**避免隐式类型转换:**
```sql
-- ❌ phone是VARCHAR,传入数字导致索引失效
WHERE phone = 13800138000

-- ✅ 使用字符串
WHERE phone = '13800138000'
```

### 3.3 分页优化

**问题: 深分页很慢**
```sql
-- ❌ OFFSET很大时性能差
SELECT * FROM orders
ORDER BY id
LIMIT 10000, 20;  -- 需要扫描10020行
```

**优化方案1: 记录上次位置**
```sql
-- ✅ 只扫描20行
SELECT * FROM orders
WHERE id > 10000  -- 记录上次最后一条的ID
ORDER BY id
LIMIT 20;
```

**优化方案2: 延迟关联**
```sql
-- ✅ 先在索引上分页,再JOIN获取完整数据
SELECT o.*
FROM orders o
JOIN (
  SELECT id FROM orders
  ORDER BY id
  LIMIT 10000, 20
) t ON o.id = t.id;
```

**知识点:**
- 方案1适合连续翻页
- 方案2适合跳页查询
- 核心: 减少回表次数

### 3.4 子查询优化

**问题: 相关子查询性能差**
```sql
-- ❌ 对products每行都执行子查询
SELECT
  p.*,
  (SELECT COUNT(*) FROM order_items WHERE product_id = p.id) as sales
FROM products p;
```

**优化: 改写为JOIN**
```sql
-- ✅ 只执行一次JOIN
SELECT
  p.*,
  COUNT(oi.id) as sales
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
GROUP BY p.id;
```

---

## 4. 实战案例

### 4.1 案例1: 用户订单列表优化

**原始查询 (慢):**
```sql
SELECT
  o.*,
  u.username,
  GROUP_CONCAT(oi.product_name) as products
FROM orders o
JOIN users u ON o.user_id = u.id
LEFT JOIN order_items oi ON o.id = oi.order_id
WHERE u.username = 'user100'
GROUP BY o.id
ORDER BY o.created_at DESC
LIMIT 20;

-- EXPLAIN 结果:
-- orders: type=ALL, rows=20000 (全表扫描)
-- users: type=ALL, rows=1000
```

**优化步骤:**

**1. 添加索引:**
```sql
CREATE INDEX idx_username ON users(username);
CREATE INDEX idx_user_created ON orders(user_id, created_at);
```

**2. 优化查询 (先找用户ID):**
```sql
-- 先通过索引找到user_id
SELECT @user_id := id FROM users WHERE username = 'user100';

-- 使用user_id查询
SELECT
  o.*,
  'user100' as username,
  GROUP_CONCAT(oi.product_name) as products
FROM orders o
LEFT JOIN order_items oi ON o.id = oi.order_id
WHERE o.user_id = @user_id
GROUP BY o.id
ORDER BY o.created_at DESC
LIMIT 20;

-- EXPLAIN 结果:
-- orders: type=ref, rows=20 (使用索引)
```

**优化效果:**
- 查询时间: 1000ms → 10ms
- 扫描行数: 20000 → 20

### 4.2 案例2: 热销商品统计优化

**问题: 实时统计太慢**
```sql
SELECT
  p.name,
  SUM(oi.quantity) as total_sold,
  SUM(oi.total_amount) as total_revenue
FROM products p
JOIN order_items oi ON p.id = oi.product_id
JOIN orders o ON oi.order_id = o.id
WHERE o.status = 3
GROUP BY p.id, p.name
ORDER BY total_sold DESC
LIMIT 10;

-- 50000行订单明细,每次查询需要1-2秒
```

**优化方案: 汇总表 + 定时更新**

**1. 创建汇总表:**
```sql
CREATE TABLE product_sales_cache (
  product_id BIGINT PRIMARY KEY,
  product_name VARCHAR(200),
  total_sold INT DEFAULT 0,
  total_revenue DECIMAL(15,2) DEFAULT 0,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  INDEX idx_sold (total_sold)
);
```

**2. 定期更新 (每小时或每天):**
```sql
INSERT INTO product_sales_cache (product_id, product_name, total_sold, total_revenue)
SELECT
  p.id,
  p.name,
  IFNULL(SUM(oi.quantity), 0),
  IFNULL(SUM(oi.total_amount), 0)
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.id AND o.status = 3
GROUP BY p.id, p.name
ON DUPLICATE KEY UPDATE
  total_sold = VALUES(total_sold),
  total_revenue = VALUES(total_revenue),
  updated_at = NOW();
```

**3. 快速查询:**
```sql
SELECT * FROM product_sales_cache
ORDER BY total_sold DESC
LIMIT 10;

-- 查询时间: < 1ms
```

**知识点:**
- 空间换时间
- 定时更新汇总表
- 适合不需要实时的统计场景

### 4.3 案例3: COUNT(*) 优化

**问题: 大表 COUNT 很慢**
```sql
SELECT COUNT(*) FROM orders WHERE status = 3;
-- 2000万行数据,需要10秒
```

**优化方案:**

**1. 使用索引覆盖:**
```sql
-- 创建索引
CREATE INDEX idx_status ON orders(status);

-- COUNT 会使用索引,不回表
SELECT COUNT(*) FROM orders WHERE status = 3;
-- 时间: 10s → 1s
```

**2. 估算值 (EXPLAIN):**
```sql
EXPLAIN SELECT COUNT(*) FROM orders WHERE status = 3;
-- 查看 rows 字段,作为估算值
-- 适用于不需要精确计数的场景
```

**3. 汇总表:**
```sql
CREATE TABLE order_count_cache (
  status TINYINT PRIMARY KEY,
  count INT,
  updated_at TIMESTAMP
);

-- 定期更新
INSERT INTO order_count_cache (status, count)
SELECT status, COUNT(*) FROM orders GROUP BY status
ON DUPLICATE KEY UPDATE count = VALUES(count), updated_at = NOW();

-- 快速查询
SELECT count FROM order_count_cache WHERE status = 3;
```

---

## 5. 查询改写技巧

### 5.1 IN vs EXISTS

```sql
-- 场景: 查询有订单的用户

-- IN (适合子查询结果集小)
SELECT * FROM users
WHERE id IN (SELECT user_id FROM orders);

-- EXISTS (适合子查询结果集大)
SELECT * FROM users u
WHERE EXISTS (SELECT 1 FROM orders WHERE user_id = u.id);
```

### 5.2 UNION ALL vs OR

```sql
-- OR可能不走索引
SELECT * FROM orders
WHERE user_id = 100 OR status = 1;

-- UNION ALL 分别走索引
SELECT * FROM orders WHERE user_id = 100
UNION ALL
SELECT * FROM orders WHERE status = 1 AND user_id != 100;
```

### 5.3 拆分复杂查询

```sql
-- 复杂查询拆分为多个简单查询
-- 应用层组装结果

-- 1. 查询订单
SELECT * FROM orders WHERE user_id = 100;

-- 2. 查询订单明细
SELECT * FROM order_items WHERE order_id IN (...);

-- 3. 应用层组装
```

---

## 关键学习点总结

### 1. 性能优化原则

**优化优先级:**
1. ✅ 避免全表扫描 (添加索引)
2. ✅ 避免索引失效 (改写SQL)
3. ✅ 减少回表 (覆盖索引)
4. ✅ 优化JOIN (索引+小表驱动)
5. ✅ 优化分页 (延迟关联)

**不要过度优化:**
- 性能够用就好,不要盲目追求极致
- 平衡性能与可维护性
- 数据量小时,优化意义不大

### 2. 索引优化建议

**何时添加索引:**
- WHERE 条件列
- JOIN 连接列
- ORDER BY 排序列
- GROUP BY 分组列
- 覆盖索引 (包含查询所需所有列)

**何时不要添加索引:**
- 数据量很小 (< 1000行)
- 频繁更新的列
- 区分度很低的列 (如性别)
- 很少使用的列

### 3. SQL优化检查清单

- [ ] 是否避免了 SELECT * ?
- [ ] WHERE 条件是否使用了索引?
- [ ] 是否避免了函数导致索引失效?
- [ ] JOIN 字段是否有索引?
- [ ] 是否避免了相关子查询?
- [ ] 深分页是否优化?
- [ ] 是否使用了覆盖索引?
- [ ] GROUP BY 字段是否有索引?

---

## 实践建议

1. **养成 EXPLAIN 习惯**: 每条查询都用 EXPLAIN 分析
2. **监控慢查询**: 开启慢查询日志,定期分析
3. **压测验证**: 优化前后对比性能,量化效果
4. **建立基线**: 记录优化前的性能指标
5. **渐进优化**: 一次优化一个问题,逐步改进

**性能测试工具:**
```bash
# sysbench 压测
sysbench --test=oltp --mysql-db=study_db --mysql-user=root --mysql-password=root run

# mysqlslap 压测
mysqlslap --query="SELECT * FROM orders WHERE user_id = 1" --concurrency=100 --iterations=10

# pt-query-digest 分析慢查询
pt-query-digest /var/log/mysql/slow.log
```

继续学习第十阶段综合实战!
