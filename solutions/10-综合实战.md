# 第十阶段：综合实战完整指导

## 核心知识点

### 1. 系统设计思维

**设计原则:**
- **高可用**: 主从复制、故障切换
- **高性能**: 缓存、索引、读写分离
- **可扩展**: 分库分表、微服务
- **数据安全**: 备份、权限、审计

**常见架构:**
```
              应用层
                ↓
           缓存层 (Redis)
                ↓
         ┌──────┴──────┐
         ↓             ↓
    主库 (写)     从库1 (读)
         ↓             ↓
       从库2 (读)   从库3 (读)
```

### 2. 高并发场景处理

**并发问题:**
1. **超卖**: 库存扣减
2. **重复**: 订单重复提交
3. **性能**: 大量读写请求
4. **一致性**: 数据同步延迟

**解决方案:**
- **数据库层**: 事务、锁、唯一索引
- **缓存层**: Redis 原子操作
- **应用层**: 分布式锁、消息队列
- **架构层**: 读写分离、分库分表

### 3. 缓存策略

**Cache Aside (旁路缓存):**
```
读: 先查缓存 → 缓存命中返回 → 缓存未命中查DB → 写入缓存
写: 先更新DB → 删除缓存
```

**缓存问题:**
- **缓存穿透**: 查询不存在的数据 → 布隆过滤器
- **缓存击穿**: 热点数据过期 → 互斥锁
- **缓存雪崩**: 大量缓存同时过期 → 过期时间随机化

---

## 项目1: 秒杀系统

### 1.1 需求分析

**业务特点:**
- 瞬时高并发 (10万QPS+)
- 库存有限,防超卖
- 用户限购 (1人1单)
- 系统稳定性要求高

**技术挑战:**
- 数据库压力大
- 超卖问题
- 重复下单
- 雪崩效应

### 1.2 数据库设计

```sql
-- 秒杀商品表
CREATE TABLE seckill_products (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  product_id BIGINT NOT NULL COMMENT '商品ID',
  seckill_price DECIMAL(10,2) NOT NULL COMMENT '秒杀价',
  stock_count INT NOT NULL COMMENT '库存数量',
  start_time TIMESTAMP NOT NULL COMMENT '开始时间',
  end_time TIMESTAMP NOT NULL COMMENT '结束时间',
  version INT DEFAULT 0 COMMENT '版本号-乐观锁',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  INDEX idx_product (product_id),
  INDEX idx_time (start_time, end_time)
) ENGINE=InnoDB COMMENT='秒杀商品表';

-- 秒杀订单表
CREATE TABLE seckill_orders (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL COMMENT '用户ID',
  seckill_product_id BIGINT NOT NULL COMMENT '秒杀商品ID',
  order_no VARCHAR(50) UNIQUE NOT NULL COMMENT '订单号',
  status TINYINT DEFAULT 0 COMMENT '0-待支付,1-已支付,2-已取消',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  pay_time TIMESTAMP NULL COMMENT '支付时间',
  UNIQUE KEY uk_user_product (user_id, seckill_product_id) COMMENT '防止重复下单',
  INDEX idx_order_no (order_no),
  INDEX idx_user (user_id)
) ENGINE=InnoDB COMMENT='秒杀订单表';
```

**知识点:**
- `uk_user_product`: 唯一索引防止重复下单
- `version`: 乐观锁版本号
- 时间索引: 快速查询进行中的秒杀

### 1.3 防超卖方案

**方案1: 数据库悲观锁**
```sql
DELIMITER $$

CREATE PROCEDURE SeckillWithPessimisticLock(
  IN p_user_id BIGINT,
  IN p_seckill_product_id BIGINT,
  OUT p_success BOOLEAN,
  OUT p_message VARCHAR(100)
)
BEGIN
  DECLARE v_stock INT;
  DECLARE v_order_no VARCHAR(50);

  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    ROLLBACK;
    SET p_success = FALSE;
    SET p_message = '系统异常,请重试';
  END;

  START TRANSACTION;

  -- 1. 锁定库存行
  SELECT stock_count INTO v_stock
  FROM seckill_products
  WHERE id = p_seckill_product_id
    AND NOW() BETWEEN start_time AND end_time
  FOR UPDATE;

  -- 2. 检查库存
  IF v_stock IS NULL THEN
    SET p_success = FALSE;
    SET p_message = '秒杀已结束';
    ROLLBACK;
  ELSEIF v_stock <= 0 THEN
    SET p_success = FALSE;
    SET p_message = '商品已售罄';
    ROLLBACK;
  ELSE
    -- 3. 扣减库存
    UPDATE seckill_products
    SET stock_count = stock_count - 1
    WHERE id = p_seckill_product_id;

    -- 4. 创建订单
    SET v_order_no = CONCAT('SK', DATE_FORMAT(NOW(), '%Y%m%d%H%i%s'), LPAD(FLOOR(RAND() * 10000), 4, '0'));

    INSERT INTO seckill_orders (user_id, seckill_product_id, order_no)
    VALUES (p_user_id, p_seckill_product_id, v_order_no);

    SET p_success = TRUE;
    SET p_message = CONCAT('秒杀成功,订单号: ', v_order_no);
    COMMIT;
  END IF;
END$$

DELIMITER ;

-- 调用
CALL SeckillWithPessimisticLock(1, 1, @success, @msg);
SELECT @success, @msg;
```

**优点:** 可靠,不会超卖
**缺点:** 并发度低,锁等待

**方案2: 数据库乐观锁**
```sql
-- 1. 读取库存和版本号
SELECT stock_count, version
FROM seckill_products
WHERE id = ? AND NOW() BETWEEN start_time AND end_time;

-- 2. 检查库存 (应用层)

-- 3. 扣减库存 (使用版本号)
UPDATE seckill_products
SET stock_count = stock_count - 1,
    version = version + 1
WHERE id = ?
  AND version = ?
  AND stock_count > 0;

-- 4. 检查 affected_rows
-- 如果 = 0, 说明冲突,重试
-- 如果 = 1, 扣减成功,创建订单
```

**优点:** 并发度高,无锁等待
**缺点:** 冲突时需要重试

**方案3: Redis + 数据库 (推荐)**
```python
# 伪代码
def seckill(user_id, product_id):
    # 1. Redis 原子扣减库存
    stock = redis.decr(f"seckill:stock:{product_id}")

    if stock < 0:
        # 库存不足,回滚
        redis.incr(f"seckill:stock:{product_id}")
        return "商品已售罄"

    # 2. 异步创建订单 (发送到消息队列)
    mq.send({
        "user_id": user_id,
        "product_id": product_id,
        "order_no": generate_order_no()
    })

    return "秒杀成功"

# 消费者: 从MQ消费消息,写入数据库
def consume_order_message(msg):
    # 写入数据库
    db.insert_order(msg)
```

**优点:** 性能最好,削峰填谷
**缺点:** 架构复杂,需要Redis和MQ

### 1.4 系统优化

**1. 页面静态化:**
- 秒杀页面静态化,减少DB查询
- CDN 加速

**2. 按钮控制:**
- 秒杀开始前,按钮置灰
- JavaScript 控制,防止重复点击

**3. 接口限流:**
```sql
-- 创建限流表
CREATE TABLE rate_limit (
  user_id BIGINT PRIMARY KEY,
  request_count INT DEFAULT 0,
  window_start TIMESTAMP,
  INDEX idx_window (window_start)
);

-- 限流逻辑 (每分钟最多10次请求)
INSERT INTO rate_limit (user_id, request_count, window_start)
VALUES (?, 1, NOW())
ON DUPLICATE KEY UPDATE
  request_count = IF(TIMESTAMPDIFF(MINUTE, window_start, NOW()) >= 1, 1, request_count + 1),
  window_start = IF(TIMESTAMPDIFF(MINUTE, window_start, NOW()) >= 1, NOW(), window_start);

-- 检查是否超限
SELECT request_count FROM rate_limit
WHERE user_id = ? AND request_count <= 10;
```

---

## 项目2: 推荐系统

### 2.1 协同过滤推荐

**原理: 找相似用户,推荐他们买的商品**

```sql
-- 步骤1: 找出相似用户 (购买过相同商品)
WITH similar_users AS (
  SELECT
    o2.user_id,
    COUNT(DISTINCT oi2.product_id) as common_products,
    SUM(oi2.total_amount) as total_spending
  FROM orders o1
  JOIN order_items oi1 ON o1.id = oi1.order_id
  JOIN order_items oi2 ON oi1.product_id = oi2.product_id
  JOIN orders o2 ON oi2.order_id = o2.id
  WHERE o1.user_id = 1  -- 目标用户
    AND o2.user_id != 1
    AND o1.status = 3
    AND o2.status = 3
  GROUP BY o2.user_id
  HAVING common_products >= 2  -- 至少2个共同商品
  ORDER BY common_products DESC, total_spending DESC
  LIMIT 100
)

-- 步骤2: 推荐这些用户购买的商品
SELECT
  p.id,
  p.name,
  p.price,
  COUNT(DISTINCT o.user_id) as buyer_count,
  SUM(oi.quantity) as total_sold,
  AVG(pr.rating) as avg_rating
FROM similar_users su
JOIN orders o ON su.user_id = o.user_id
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
LEFT JOIN product_reviews pr ON p.id = pr.product_id
WHERE p.id NOT IN (
  -- 排除用户已购买的商品
  SELECT product_id FROM order_items
  WHERE order_id IN (
    SELECT id FROM orders WHERE user_id = 1 AND status = 3
  )
)
  AND o.status = 3
  AND p.status = 1
GROUP BY p.id, p.name, p.price
ORDER BY buyer_count DESC, total_sold DESC, avg_rating DESC
LIMIT 20;
```

**知识点:**
- CTE 将复杂查询拆分
- 先找相似用户,再找推荐商品
- 排除用户已购买的商品
- 按购买人数、销量、评分排序

### 2.2 热销推荐

```sql
-- 基于分类的热销推荐
SELECT
  p.id,
  p.name,
  p.price,
  p.category_id,
  c.name as category_name,
  COUNT(DISTINCT oi.order_id) as order_count,
  SUM(oi.quantity) as total_sold,
  SUM(oi.total_amount) as total_revenue,
  ROW_NUMBER() OVER (PARTITION BY p.category_id ORDER BY SUM(oi.quantity) DESC) as rank_in_category
FROM products p
JOIN categories c ON p.category_id = c.id
JOIN order_items oi ON p.id = oi.product_id
JOIN orders o ON oi.order_id = o.id
WHERE o.status = 3
  AND o.created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)  -- 最近30天
  AND p.status = 1
GROUP BY p.id, p.name, p.price, p.category_id, c.name
HAVING total_sold > 10
ORDER BY rank_in_category, total_sold DESC;
```

**知识点:**
- 窗口函数 `ROW_NUMBER()` 对每个分类排名
- 最近30天的热销数据
- 每个分类推荐TOP商品

---

## 项目3: 实时数据大屏

### 3.1 汇总表设计

```sql
-- 每日汇总表
CREATE TABLE dashboard_daily_stats (
  stat_date DATE PRIMARY KEY,
  order_count INT DEFAULT 0,
  order_amount DECIMAL(15,2) DEFAULT 0,
  paid_order_count INT DEFAULT 0,
  paid_amount DECIMAL(15,2) DEFAULT 0,
  new_user_count INT DEFAULT 0,
  active_user_count INT DEFAULT 0,
  avg_order_amount DECIMAL(10,2) DEFAULT 0,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB COMMENT='每日数据汇总';

-- 实时汇总表 (每小时更新)
CREATE TABLE dashboard_realtime_stats (
  id INT PRIMARY KEY AUTO_INCREMENT,
  stat_hour TIMESTAMP,
  order_count INT DEFAULT 0,
  order_amount DECIMAL(15,2) DEFAULT 0,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY uk_hour (stat_hour)
) ENGINE=InnoDB COMMENT='实时数据汇总';
```

### 3.2 定时更新任务

```sql
-- 每日汇总更新 (每天凌晨1点执行)
INSERT INTO dashboard_daily_stats (
  stat_date,
  order_count,
  order_amount,
  paid_order_count,
  paid_amount,
  new_user_count,
  active_user_count,
  avg_order_amount
)
SELECT
  CURDATE() - INTERVAL 1 DAY as stat_date,
  COUNT(*),
  SUM(total_amount),
  SUM(CASE WHEN status >= 1 THEN 1 ELSE 0 END),
  SUM(CASE WHEN status >= 1 THEN pay_amount ELSE 0 END),
  (SELECT COUNT(*) FROM users
   WHERE DATE(created_at) = CURDATE() - INTERVAL 1 DAY),
  COUNT(DISTINCT user_id),
  AVG(CASE WHEN status >= 1 THEN pay_amount END)
FROM orders
WHERE DATE(created_at) = CURDATE() - INTERVAL 1 DAY
ON DUPLICATE KEY UPDATE
  order_count = VALUES(order_count),
  order_amount = VALUES(order_amount),
  paid_order_count = VALUES(paid_order_count),
  paid_amount = VALUES(paid_amount),
  new_user_count = VALUES(new_user_count),
  active_user_count = VALUES(active_user_count),
  avg_order_amount = VALUES(avg_order_amount),
  updated_at = NOW();
```

### 3.3 大屏查询

```sql
-- 今日实时数据
SELECT
  COUNT(*) as today_order_count,
  IFNULL(SUM(pay_amount), 0) as today_revenue,
  COUNT(DISTINCT user_id) as today_active_users
FROM orders
WHERE DATE(created_at) = CURDATE()
  AND status >= 1;

-- 30天趋势
SELECT
  stat_date,
  order_count,
  order_amount,
  paid_order_count,
  paid_amount
FROM dashboard_daily_stats
WHERE stat_date >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
ORDER BY stat_date;

-- TOP10 商品 (从缓存表查询)
SELECT * FROM product_sales_cache
ORDER BY total_sold DESC
LIMIT 10;
```

**知识点:**
- 空间换时间,汇总表存储预计算结果
- 定时任务更新,不影响实时查询
- 大屏查询极快 (< 10ms)

---

## 项目4: 订单状态机

### 4.1 状态流转设计

```sql
-- 订单状态
-- 0: 待支付
-- 1: 已支付
-- 2: 已发货
-- 3: 已完成
-- 4: 已取消

-- 状态流转规则表
CREATE TABLE order_status_flow (
  id INT PRIMARY KEY AUTO_INCREMENT,
  from_status TINYINT NOT NULL,
  to_status TINYINT NOT NULL,
  action VARCHAR(50) NOT NULL COMMENT '操作',
  UNIQUE KEY uk_flow (from_status, to_status)
) ENGINE=InnoDB COMMENT='订单状态流转规则';

-- 插入合法流转
INSERT INTO order_status_flow (from_status, to_status, action) VALUES
(0, 1, '支付'),
(0, 4, '取消'),
(1, 2, '发货'),
(1, 4, '退款取消'),
(2, 3, '确认收货'),
(2, 4, '退货取消');
```

### 4.2 状态流转存储过程

```sql
DELIMITER $$

CREATE PROCEDURE UpdateOrderStatus(
  IN p_order_id BIGINT,
  IN p_new_status TINYINT,
  OUT p_success BOOLEAN,
  OUT p_message VARCHAR(100)
)
BEGIN
  DECLARE v_old_status TINYINT;
  DECLARE v_flow_exists INT;

  -- 1. 获取当前状态
  SELECT status INTO v_old_status
  FROM orders
  WHERE id = p_order_id
  FOR UPDATE;

  IF v_old_status IS NULL THEN
    SET p_success = FALSE;
    SET p_message = '订单不存在';
    ROLLBACK;
  END IF;

  -- 2. 检查状态流转是否合法
  SELECT COUNT(*) INTO v_flow_exists
  FROM order_status_flow
  WHERE from_status = v_old_status
    AND to_status = p_new_status;

  IF v_flow_exists = 0 THEN
    SET p_success = FALSE;
    SET p_message = CONCAT('非法状态流转: ', v_old_status, ' -> ', p_new_status);
    ROLLBACK;
  ELSE
    -- 3. 更新状态 (触发器会自动更新时间戳)
    UPDATE orders
    SET status = p_new_status
    WHERE id = p_order_id;

    SET p_success = TRUE;
    SET p_message = '状态更新成功';
    COMMIT;
  END IF;
END$$

DELIMITER ;
```

---

## 关键学习点总结

### 1. 系统设计要点

**高并发处理:**
- 缓存: 减少DB压力
- 异步: 消息队列削峰
- 限流: 保护系统稳定
- 降级: 保证核心功能

**数据一致性:**
- 事务: 保证原子性
- 锁: 防止并发问题
- 幂等: 防止重复操作
- 补偿: 最终一致性

### 2. 架构演进

**单体 → 微服务:**
```
单体应用
  ↓
垂直拆分 (按业务)
  ↓
读写分离
  ↓
分库分表
  ↓
微服务 + 消息队列
```

### 3. 数据库优化方向

**查询优化:**
- 索引设计
- SQL改写
- 分页优化
- 缓存结果

**架构优化:**
- 读写分离
- 分库分表
- NoSQL补充
- 冷热分离

---

## 总结

完成这10个阶段的学习后，你应该具备：

### ✅ 核心能力

**基础能力:**
- 扎实的SQL基础 (增删改查)
- 多表查询和复杂分析能力
- 索引和性能优化技能

**进阶能力:**
- 事务和并发控制理解
- 存储过程开发能力
- 权限和安全管理

**实战能力:**
- 系统设计和优化思维
- 高并发场景处理
- 架构演进规划

### 🎯 下一步建议

**1. 深入学习:**
- 分库分表 (ShardingSphere, MyCat)
- MySQL 高可用 (MHA, MGR)
- 源码阅读 (InnoDB 存储引擎)

**2. 横向扩展:**
- NoSQL 数据库 (Redis, MongoDB, ES)
- 消息队列 (Kafka, RocketMQ)
- 分布式系统 (微服务、分布式事务)

**3. 实战演练:**
- 参与实际项目
- 阅读优秀开源项目
- 解决生产环境问题
- 分享技术博客

**4. 持续进步:**
- 关注技术动态
- 参加技术社区
- 考取认证 (MySQL DBA认证)
- 成为数据库专家

继续保持学习,成为优秀的数据库工程师！🎉
