# 第六阶段：事务处理完整答案


## MySQL 如何实现 ACID 

### A - 原子性 (Atomicity) 的实现

**核心机制: Undo Log (回滚日志)**

#### 1. Undo Log 的作用

```
事务执行过程:
┌─────────────────────────────────────────────────┐
│  1. 事务开始                                     │
│  2. 记录 Undo Log (修改前的旧值)                  │
│  3. 修改数据页                                   │
│  4. 记录 Redo Log (修改后的新值)                  │
│  5. 提交事务                                     │
└─────────────────────────────────────────────────┘

如果事务回滚:
  → 读取 Undo Log
  → 将数据恢复到修改前的状态
```

#### 2. Undo Log 的工作原理

**示例: UPDATE 操作**

```sql
-- 原始数据: id=1, balance=1000
UPDATE users SET balance = 800 WHERE id = 1;
```

**执行过程:**
```
1. 事务开始
   - 生成唯一的事务ID: trx_id = 100

2. 写入 Undo Log (在修改数据前)
   undo_log:
   - 操作类型: UPDATE
   - 表: users
   - 主键: id = 1
   - 旧值: balance = 1000
   - trx_id: 100

3. 修改数据
   - 将 balance 从 1000 改为 800
   - 在行记录上标记 trx_id = 100

4a. 如果 COMMIT:
   - 事务提交,修改生效
   - Undo Log 保留一段时间(用于 MVCC)
   - 后台线程异步清理 Undo Log

4b. 如果 ROLLBACK:
   - 读取 Undo Log
   - 将 balance 恢复为 1000
   - 清理 Undo Log
```

**示例: INSERT 和 DELETE**

```sql
-- INSERT: Undo Log 记录删除操作
INSERT INTO users (id, balance) VALUES (2, 500);
-- Undo Log: DELETE FROM users WHERE id = 2

-- DELETE: Undo Log 记录插入操作
DELETE FROM users WHERE id = 1;
-- Undo Log: INSERT INTO users (id, balance) VALUES (1, 1000)
```

#### 3. Undo Log 的存储

```
InnoDB 存储引擎:
- 存储在 系统表空间 或 独立的 Undo 表空间
- 每个事务有自己的 Undo Log 段
- 以链表形式组织,支持多版本
```

**Undo Log Chain (版本链):**
```
当前版本 → 上一版本 → 更早版本 → ... → 原始版本
(trx_id=100)  (trx_id=90)  (trx_id=80)

每个版本通过 DB_ROLL_PTR 指针连接
```

---

### C - 一致性 (Consistency) 的实现

```
一致性是目标，不是具体机制
原子性 + 隔离性 + 持久性 → 共同实现一致性
```


广义上的一致性，还需要业务层面来保证：

```sql
-- 转账业务的一致性规则: 总金额不变
START TRANSACTION;

-- A账户扣款
UPDATE users SET balance = balance - 100 WHERE id = 1;

-- B账户加款
UPDATE users SET balance = balance + 100 WHERE id = 2;

-- 如果任何一步失败,全部回滚
-- 保证: A的扣款 + B的加款 = 0

COMMIT;
```


---

### I - 隔离性 (Isolation) 的实现

**核心机制: 锁 + MVCC (Multi-Version Concurrency Control)**

#### 1. 锁机制

**行级锁 (Row Lock):**
```sql
-- 排他锁 (X Lock)
SELECT * FROM users WHERE id = 1 FOR UPDATE;
-- 其他事务无法读取或修改 id=1 的行

-- 共享锁 (S Lock) - MySQL 8.0+
SELECT * FROM users WHERE id = 1 FOR SHARE;
-- 其他事务可以读取,但无法修改 id=1 的行
```

**锁的兼容性矩阵:**
```
          当前锁
          S    X
请求锁 S  ✅   ❌
       X  ❌   ❌
```

**间隙锁 (Gap Lock) 和 Next-Key Lock:**
```sql
-- 假设表中有 id: 1, 5, 10
SELECT * FROM users WHERE id > 3 AND id < 8 FOR UPDATE;

-- Gap Lock: 锁定 (3, 5) 和 (5, 8) 两个间隙
-- 防止其他事务插入 id=4, 6, 7 的记录
-- → 解决幻读问题
```

#### 2. MVCC (多版本并发控制)

**MVCC 的核心思想:**
```
为每一行数据保存多个版本
每个事务看到的是某个版本的数据快照
→ 实现"读不加锁,读写不冲突"
```

**每行记录的隐藏字段:**
```sql
-- InnoDB 为每行数据添加3个隐藏字段:

CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  balance DECIMAL(10,2),
  -- 隐藏字段 (用户看不见):
  DB_TRX_ID,      -- 最后修改该行的事务ID
  DB_ROLL_PTR,    -- 回滚指针,指向 Undo Log 中的上一版本
  DB_ROW_ID       -- 如果没有主键,自动生成的行ID
);
```

**示例: MVCC 版本链**

```sql
-- 初始数据: id=1, balance=1000

-- 事务1 (trx_id=100): UPDATE balance=800
-- 事务2 (trx_id=110): UPDATE balance=600
```

**版本链示例:**
```
当前版本 (最新):
┌───────────────────────────────────────┐
│ id=1, balance=600                     │
│ DB_TRX_ID = 110                       │
│ DB_ROLL_PTR → 指向上一版本            │
└───────────────────────────────────────┘
           ↓ (Undo Log)
┌───────────────────────────────────────┐
│ id=1, balance=800                     │
│ DB_TRX_ID = 100                       │
│ DB_ROLL_PTR → 指向更早版本            │
└───────────────────────────────────────┘
           ↓ (Undo Log)
┌───────────────────────────────────────┐
│ id=1, balance=1000 (原始版本)         │
│ DB_TRX_ID = NULL                      │
│ DB_ROLL_PTR = NULL                    │
└───────────────────────────────────────┘
```

#### 3. Read View (读视图)

**Read View 的作用:**
- 事务开始时创建快照,记录当前数据库的状态
- 决定事务能看到哪些版本的数据

**Read View 的关键字段:**
```
m_ids:          当前活跃(未提交)的事务ID列表
min_trx_id:     m_ids 中的最小值
max_trx_id:     下一个要分配的事务ID (当前最大值+1)
creator_trx_id: 创建此 Read View 的事务ID
```

**示例:**
```
假设当前活跃事务: [100, 105, 110]

Read View:
  m_ids = [100, 105, 110]
  min_trx_id = 100
  max_trx_id = 111
  creator_trx_id = 105
```

#### 4. 可见性判断算法

```
判断某个版本的数据是否对当前事务可见:

if (版本的 trx_id == creator_trx_id) {
  可见  // 自己修改的数据
}
else if (版本的 trx_id < min_trx_id) {
  可见  // 事务开始前已提交的数据
}
else if (版本的 trx_id >= max_trx_id) {
  不可见  // 未来事务的数据
}
else if (版本的 trx_id 在 m_ids 中) {
  不可见  // 活跃事务(未提交)的数据
}
else {
  可见  // 已提交的数据
}
```

**示例: 可见性判断**

```sql
-- 事务A (trx_id=100): 开始,创建 Read View
START TRANSACTION;  -- Read View: m_ids=[105, 110], min=105, max=111

-- 查询 id=1 的记录
SELECT * FROM users WHERE id = 1;
```

**版本链:**
```
版本1: balance=600, trx_id=110 → 判断: 110 在 m_ids 中 → 不可见
版本2: balance=800, trx_id=105 → 判断: 105 在 m_ids 中 → 不可见
版本3: balance=1000, trx_id=90 → 判断: 90 < min_trx_id → 可见 ✅

→ 事务A 读到 balance=1000
```

#### 5. 不同隔离级别的 Read View 创建时机

**READ COMMITTED:**
```sql
-- 每次查询都创建新的 Read View
START TRANSACTION;

SELECT * FROM users WHERE id = 1;  -- 创建 Read View 1
-- 其他事务提交了修改
SELECT * FROM users WHERE id = 1;  -- 创建 Read View 2 (读到新数据)

COMMIT;

→ 可能出现不可重复读
```

**REPEATABLE READ:**
```sql
-- 事务开始时创建 Read View,之后复用
START TRANSACTION;

SELECT * FROM users WHERE id = 1;  -- 创建 Read View
-- 其他事务提交了修改
SELECT * FROM users WHERE id = 1;  -- 复用同一个 Read View (读到旧数据)

COMMIT;

→ 避免不可重复读
```

---

#### 6. Read View 的性能问题与优化

**Read View 创建的性能开销:**

**1. 创建 Read View 的成本**
```
Read View 创建时需要:
1. 遍历所有活跃事务
2. 复制活跃事务ID列表到 m_ids
3. 计算 min_trx_id 和 max_trx_id

时间复杂度: O(活跃事务数)
```

**性能影响分析:**
```
场景1: 低并发 (10个活跃事务)
  创建 Read View: < 1微秒
  影响: 几乎可以忽略

场景2: 高并发 (1000个活跃事务)
  创建 Read View: 几十微秒
  影响: READ COMMITTED 每次查询创建,累积开销明显
```

**2. READ COMMITTED vs REPEATABLE READ 性能对比**

| 隔离级别 | Read View 创建频率 | 性能特点 | 适用场景 |
|---------|------------------|---------|---------|
| **READ COMMITTED** | 每次查询创建 | 开销较高,但能读到最新数据 | 对实时性要求高 |
| **REPEATABLE READ** | 事务开始创建一次 | 开销低,读到快照数据 | 对一致性要求高 |

**示例对比:**

```sql
-- READ COMMITTED
START TRANSACTION;

SELECT * FROM users;      -- 创建 Read View 1 (10微秒)
SELECT * FROM orders;     -- 创建 Read View 2 (10微秒)
SELECT * FROM products;   -- 创建 Read View 3 (10微秒)
-- 执行100次查询
-- 总开销: 100 * 10微秒 = 1毫秒

COMMIT;

-- REPEATABLE READ
START TRANSACTION;

SELECT * FROM users;      -- 创建 Read View (10微秒)
SELECT * FROM orders;     -- 复用 Read View (0微秒)
SELECT * FROM products;   -- 复用 Read View (0微秒)
-- 执行100次查询
-- 总开销: 1 * 10微秒 = 10微秒

COMMIT;
```

**3. 长事务的性能问题**

**问题: 长事务阻止 Undo Log 清理**

```sql
-- 事务A: 长事务
START TRANSACTION;  -- 创建 Read View

-- 1小时内持续查询...
SELECT * FROM users WHERE id = 1;

-- 期间,其他事务不断修改数据
-- 但事务A的 Read View 还需要这些旧版本
-- → Undo Log 无法清理,持续增长

COMMIT;  -- 1小时后才提交
```

**影响:**
```
1. Undo Log 空间膨胀
   - 事务A的 Read View 引用了大量旧版本
   - 后台清理线程无法删除这些版本
   - 可能导致表空间持续增长

2. 历史版本链过长
   - 后续事务查询时,需要遍历更长的版本链
   - 影响查询性能

3. 内存压力
   - Buffer Pool 中积累大量历史版本数据页
```

**实际案例:**
```
问题: 某电商系统,周末订单暴增,数据库响应变慢

排查:
SELECT * FROM information_schema.innodb_trx
WHERE trx_started < DATE_SUB(NOW(), INTERVAL 1 HOUR);

发现: 有一个事务运行了6小时,导致 Undo Log 从 2GB 增长到 50GB

原因: 开发人员在事务中执行报表查询,忘记提交

解决:
1. KILL 长事务
2. Undo Log 自动清理,空间恢复
3. 添加监控,超过5分钟的事务告警
```

**4. 高并发下的 Read View 性能优化**

**优化1: 减少活跃事务数**

```sql
-- ❌ 不好: 长事务
START TRANSACTION;
-- 复杂业务逻辑 (5秒)
-- 网络IO (2秒)
UPDATE users SET balance = balance - 100 WHERE id = 1;
COMMIT;

-- ✅ 好: 短事务
-- 业务逻辑在事务外 (5秒)
-- 网络IO在事务外 (2秒)
START TRANSACTION;
UPDATE users SET balance = balance - 100 WHERE id = 1;
COMMIT;  -- 事务只持续几毫秒

→ 活跃事务数减少,Read View 创建更快
```

**优化2: 使用连接池,避免频繁创建事务**

```
错误做法:
  每次请求 → 创建连接 → 开启事务 → 执行 → 提交 → 关闭连接

优化做法:
  连接池复用 → 减少事务创建开销
```

**优化3: 合理选择隔离级别**

```sql
-- 场景: 统计报表,不需要强一致性
-- 使用 READ COMMITTED,能读到最新数据
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

START TRANSACTION;
SELECT COUNT(*) FROM orders WHERE status = 1;  -- 创建 Read View
-- 每次查询都能看到最新提交的数据
COMMIT;

-- 场景: 订单生成,需要数据一致性
-- 使用 REPEATABLE READ,保证快照读
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

START TRANSACTION;
SELECT balance FROM users WHERE id = 1;  -- 创建 Read View
-- 后续查询都看到相同的快照
UPDATE users SET balance = balance - 100 WHERE id = 1;
COMMIT;
```

**5. 监控 Read View 相关指标**

```sql
-- 查看当前活跃事务
SELECT
  trx_id,
  trx_state,
  trx_started,
  TIMESTAMPDIFF(SECOND, trx_started, NOW()) as duration_sec,
  trx_rows_locked,
  trx_rows_modified
FROM information_schema.innodb_trx
ORDER BY trx_started;

-- 查看长事务 (超过60秒)
SELECT
  trx_id,
  trx_state,
  trx_started,
  TIMESTAMPDIFF(SECOND, trx_started, NOW()) as duration_sec
FROM information_schema.innodb_trx
WHERE TIMESTAMPDIFF(SECOND, trx_started, NOW()) > 60;

-- 查看 Undo Log 使用情况 (MySQL 8.0+)
SELECT
  tablespace_name,
  file_name,
  file_size / 1024 / 1024 as size_mb
FROM information_schema.files
WHERE file_type = 'UNDO LOG';
```

**6. Read View 性能优化总结**

| 优化策略 | 效果 | 适用场景 |
|---------|------|---------|
| **使用 RR 代替 RC** | 减少 Read View 创建次数 | 需要可重复读的场景 |
| **避免长事务** | 及时清理 Undo Log | 所有场景 |
| **缩短事务时间** | 减少活跃事务数 | 高并发场景 |
| **定期监控长事务** | 及时发现问题 | 生产环境必备 |

**最佳实践:**

```sql
-- ✅ 推荐: 快速短事务
START TRANSACTION;
UPDATE users SET last_login = NOW() WHERE id = 1;
COMMIT;

-- ❌ 避免: 长事务
START TRANSACTION;
-- 慢查询
SELECT * FROM large_table WHERE ...;  -- 10秒
-- 复杂计算
-- ...
UPDATE users SET last_login = NOW() WHERE id = 1;
COMMIT;

-- ✅ 推荐: 只读查询不需要事务
SELECT * FROM products WHERE category_id = 10;

-- ❌ 避免: 不必要的显式事务
START TRANSACTION;
SELECT * FROM products WHERE category_id = 10;
COMMIT;
```

**性能对比实测 (1000并发):**
```
REPEATABLE READ + 短事务:
  平均响应时间: 5ms
  Read View 创建开销: 0.01ms

READ COMMITTED + 长事务:
  平均响应时间: 20ms
  Read View 创建开销: 2ms (每次查询创建)
  Undo Log 膨胀: 10GB

→ REPEATABLE READ 性能提升 4倍
```

---

### D - 持久性 (Durability) 的实现

**核心机制: Redo Log (重做日志) + 双写缓冲区**

#### 1. Redo Log 的作用

**问题: 为什么需要 Redo Log?**
```
数据修改流程 (没有 Redo Log):
1. 事务修改数据
2. 数据页在内存中修改
3. 提交事务
4. 脏页刷新到磁盘

风险:
- 如果步骤3和4之间系统崩溃,已提交的数据丢失
- 违反持久性
```

**Redo Log 解决方案:**
```
WAL (Write-Ahead Logging) 预写日志:

1. 事务修改数据 (内存中)
2. 写入 Redo Log (磁盘,顺序写,快!)
3. 提交事务
4. 后台异步刷新脏页到磁盘

崩溃恢复:
- 系统重启后,读取 Redo Log
- 重新执行已提交但未刷盘的操作
- 保证数据不丢失
```

#### 2. Redo Log 的写入过程

```
事务执行:
┌─────────────────────────────────────────┐
│ 1. 修改内存中的数据页 (Buffer Pool)     │
│ 2. 记录修改到 Redo Log Buffer (内存)   │
│ 3. 事务提交时,Redo Log Buffer → 磁盘   │
└─────────────────────────────────────────┘

Redo Log 写入磁盘 (顺序写,速度快):
  ib_logfile0
  ib_logfile1
  (循环使用)
```

**Redo Log 的格式:**
```
每条 Redo Log 记录:
- 表空间ID
- 数据页号
- 偏移量
- 修改的数据 (新值)
- 日志序列号 (LSN, Log Sequence Number)
```

#### 3. innodb_flush_log_at_trx_commit 参数

**控制 Redo Log 刷盘策略:**

```sql
-- 0: 每秒刷盘一次 (性能最高,可能丢1秒数据)
SET GLOBAL innodb_flush_log_at_trx_commit = 0;

-- 1: 每次事务提交都刷盘 (最安全,默认)
SET GLOBAL innodb_flush_log_at_trx_commit = 1;

-- 2: 每次提交写入OS缓存,每秒刷盘 (折中)
SET GLOBAL innodb_flush_log_at_trx_commit = 2;
```

**详细对比:**
```
参数=0:
  COMMIT → Redo Log Buffer (内存)
  每秒 → OS Cache → 磁盘
  崩溃可能丢失1秒数据

参数=1 (推荐):
  COMMIT → Redo Log Buffer → OS Cache → 磁盘 (fsync)
  最安全,但性能略低

参数=2:
  COMMIT → Redo Log Buffer → OS Cache
  每秒 → 磁盘
  MySQL 崩溃不丢数据,OS 崩溃可能丢1秒
```

#### 4. 双写缓冲区 (Doublewrite Buffer)

**问题: 部分写失败**
```
数据页大小: 16KB
磁盘扇区: 512B

写入过程中断电:
  16KB = 32个扇区
  可能只写入了部分扇区 (如 20个)
  → 页损坏,无法恢复
```

**Doublewrite Buffer 解决方案:**
```
写入流程:
1. 脏页先写入 Doublewrite Buffer (共享表空间)
   - 顺序写,速度快
   - 写入两次,保证完整

2. 再写入实际的数据文件
   - 如果写入失败,从 Doublewrite Buffer 恢复

3. 完成后,清理 Doublewrite Buffer
```

**Doublewrite Buffer 结构:**
```
系统表空间 (ibdata1):
┌─────────────────────────────────┐
│  Doublewrite Buffer (2MB)       │
│  - Segment 1 (1MB)              │
│  - Segment 2 (1MB)              │
└─────────────────────────────────┘
       ↓ (写入成功后)
数据文件 (tablename.ibd):
┌─────────────────────────────────┐
│  实际的数据页                    │
└─────────────────────────────────┘
```

#### 5. 崩溃恢复流程

```
MySQL 重启后:
1. 读取 Redo Log
   - 扫描所有 Redo Log 文件
   - 找到最后一个检查点 (Checkpoint)

2. 重放日志 (Redo)
   - 从检查点开始,重新执行所有已提交的事务
   - 恢复内存中的数据页

3. 回滚未提交的事务 (Undo)
   - 读取 Undo Log
   - 回滚所有未提交的事务

4. 恢复完成,数据库可用
```


---

## 1. 基本事务操作

### 1.1 转账示例
```sql
-- 转账: A转100元给B
START TRANSACTION;

-- 检查余额（假设users表有balance字段）
SELECT @balance := balance FROM users WHERE id = 1 FOR UPDATE;

-- 应用层验证余额充足
-- 如果 @balance < 100, 则 ROLLBACK

-- 扣款
UPDATE users SET balance = balance - 100 WHERE id = 1;

-- 收款
UPDATE users SET balance = balance + 100 WHERE id = 2;

-- 提交
COMMIT;
-- 或回滚
-- ROLLBACK;
```

**知识点:**
- `FOR UPDATE` 加排他锁,防止其他事务修改
- 转账必须在同一事务中,保证原子性
- 任何步骤失败,ROLLBACK 回滚所有操作

### 1.2 查看事务状态
```sql
-- 查看当前隔离级别
SELECT @@transaction_isolation;

-- 设置会话隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 查看当前事务
SELECT * FROM information_schema.innodb_trx;

-- 查看当前锁
SELECT * FROM performance_schema.data_locks;
```

---

## 2. 隔离级别测试

### 2.1 模拟脏读 (READ UNCOMMITTED)
```sql
-- 终端1: 设置为 READ UNCOMMITTED
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;
SELECT stock FROM products WHERE id = 1;  -- 假设读到100

-- 终端2: 修改但不提交
START TRANSACTION;
UPDATE products SET stock = 50 WHERE id = 1;
-- 不提交

-- 终端1: 再次读取
SELECT stock FROM products WHERE id = 1;  -- 读到50 (脏读!)

-- 终端2: 回滚
ROLLBACK;

-- 终端1: 读到的50是无效数据
COMMIT;
```

**知识点:**
- READ UNCOMMITTED 可能读到未提交的数据
- 生产环境几乎不使用此隔离级别

### 2.2 模拟不可重复读 (READ COMMITTED)
```sql
-- 终端1
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
SELECT stock FROM products WHERE id = 1;  -- 读取：100

-- 终端2
START TRANSACTION;
UPDATE products SET stock = 50 WHERE id = 1;
COMMIT;

-- 终端1继续
SELECT stock FROM products WHERE id = 1;  -- 读取：50（已改变,不可重复读）
COMMIT;
```

**知识点:**
- READ COMMITTED: 每次查询都读取最新已提交的数据
- 同一事务中,两次读取可能不一致
- 适用于对数据一致性要求不高的场景

### 2.3 模拟幻读 (REPEATABLE READ)
```sql
-- 终端1
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT * FROM products WHERE price > 1000;  -- 假设返回10行

-- 终端2
START TRANSACTION;
INSERT INTO products (name, price) VALUES ('新商品', 1500);
COMMIT;

-- 终端1: InnoDB的REPEATABLE READ通过Next-Key Lock避免了幻读
SELECT * FROM products WHERE price > 1000;  -- 仍然10行 (MySQL已优化)
COMMIT;
```

**知识点:**
- MySQL 的 REPEATABLE READ 通过 MVCC 和 Next-Key Lock 解决了幻读
- 事务开始时创建快照,之后读取的都是快照版本
- 这是 MySQL 默认隔离级别

---

## 3. 库存扣减 (防超卖)

### 3.1 方案1: WHERE 条件判断 (推荐)
```sql
START TRANSACTION;

-- 直接在WHERE中判断库存
UPDATE products
SET stock = stock - 5
WHERE id = 100 AND stock >= 5;

-- 检查 affected_rows
SELECT ROW_COUNT() as affected;
-- 如果 affected = 0, 说明库存不足或商品不存在

COMMIT;
```

**知识点:**
- 利用 UPDATE 的原子性,一步完成检查和扣减
- `stock >= 5` 保证不会超卖
- ROW_COUNT() 返回受影响的行数
- 性能最好,无需额外加锁

### 3.2 方案2: 悲观锁 (FOR UPDATE)
```sql
START TRANSACTION;

-- 先锁定行
SELECT stock FROM products WHERE id = 100 FOR UPDATE;
-- 此时其他事务无法修改这行

-- 应用层判断库存
-- 如果 stock >= 5

-- 执行扣减
UPDATE products SET stock = stock - 5 WHERE id = 100;

COMMIT;
```

**知识点:**
- `FOR UPDATE` 加排他锁,阻塞其他事务
- 适合需要复杂业务逻辑判断的场景
- 并发度较低,可能导致锁等待

### 3.3 方案3: 乐观锁 (版本号)
```sql
-- 读取数据和版本号
SELECT stock, version FROM products WHERE id = 100;
-- 假设: stock=10, version=5

-- 应用层判断库存是否充足
-- 如果充足,执行更新

-- 更新时检查版本号
UPDATE products
SET stock = stock - 5, version = version + 1
WHERE id = 100 AND version = 5;

-- 检查 affected_rows
SELECT ROW_COUNT() as affected;
-- 如果 affected = 0, 说明数据已被其他事务修改,需要重试
```

**知识点:**
- 无需加锁,并发度高
- 通过版本号检测冲突
- 冲突时需要重试
- 适合读多写少的场景

---

## 4. 死锁处理

### 4.1 构造死锁场景
```sql
-- 终端1
START TRANSACTION;
UPDATE products SET stock = stock - 1 WHERE id = 1;
-- 已锁定 id=1

-- 终端2
START TRANSACTION;
UPDATE products SET stock = stock - 1 WHERE id = 2;
-- 已锁定 id=2

-- 终端1: 等待 id=2 的锁
UPDATE products SET stock = stock - 1 WHERE id = 2;
-- 阻塞中...

-- 终端2: 等待 id=1 的锁
UPDATE products SET stock = stock - 1 WHERE id = 1;
-- 死锁! MySQL 自动回滚其中一个事务

-- 错误信息:
-- ERROR 1213: Deadlock found when trying to get lock; try restarting transaction
```

**知识点:**
- MySQL 自动检测死锁
- 回滚其中一个事务(通常是持有锁少的事务)
- 被回滚的事务需要重试

### 4.2 避免死锁: 按固定顺序访问
```sql
-- ✅ 正确: 总是按 id 升序更新
START TRANSACTION;

UPDATE products SET stock = stock - 1
WHERE id IN (2, 1, 3)  -- 无论传入顺序如何
ORDER BY id;           -- 总是按 id 升序执行

COMMIT;

-- 所有事务都按相同顺序访问资源,不会形成循环等待
```

### 4.3 避免死锁: 缩短事务时间
```sql
-- ❌ 长事务: 容易死锁
START TRANSACTION;
-- 查询大量数据
SELECT ...;
-- 复杂计算
-- 网络调用
UPDATE products SET stock = stock - 1 WHERE id = 1;
COMMIT;

-- ✅ 短事务: 减少锁持有时间
-- 业务逻辑在事务外执行
-- 准备好所有数据后

START TRANSACTION;
UPDATE products SET stock = stock - 1 WHERE id = 1;
COMMIT;
```

### 4.4 查看死锁日志
```sql
-- 查看最近一次死锁信息
SHOW ENGINE INNODB STATUS;

-- 在输出中查找 LATEST DETECTED DEADLOCK 部分
-- 可以看到:
-- - 涉及的事务
-- - 持有的锁
-- - 等待的锁
-- - 哪个事务被回滚
```

---

## 关键学习点总结

### ACID 实现机制

| 特性 | 实现机制 | 关键组件 |
|------|---------|---------|
| **原子性** | Undo Log | 回滚日志,记录修改前的旧值 |
| **一致性** | 约束+隔离+应用逻辑 | 主键/外键/CHECK约束 |
| **隔离性** | 锁 + MVCC | 行锁/间隙锁/Next-Key Lock + 版本链 + Read View |
| **持久性** | Redo Log + 双写 | 重做日志 + Doublewrite Buffer |

### 业务场景最佳实践

**库存扣减:**
- 首选: WHERE 条件判断 (性能最好)
- 复杂逻辑: FOR UPDATE 悲观锁
- 读多写少: 乐观锁 + 重试

**转账:**
- 事务包裹所有操作(扣款+加款)
- FOR UPDATE 锁定账户余额
- 检查余额 → 扣款 → 加款 → COMMIT

**避免死锁:**
- 按固定顺序访问资源 (ORDER BY id)
- 缩短事务时间
- 降低隔离级别
- 使用乐观锁

### 实践建议

1. ✅ 模拟并发场景: 开启多个终端,测试隔离级别效果
2. ✅ 构造死锁场景: 观察 MySQL 如何检测和处理死锁
3. ✅ 实战库存扣减: 对比不同方案的性能和安全性
4. ✅ 理解底层原理: MVCC、Undo Log、Redo Log 的工作机制

**关键文件位置:**
```bash
# Redo Log
/var/lib/mysql/ib_logfile0
/var/lib/mysql/ib_logfile1

# Undo Log
/var/lib/mysql/undo_001
/var/lib/mysql/undo_002

# 系统表空间 (Doublewrite Buffer)
/var/lib/mysql/ibdata1
```

继续学习第七阶段:存储过程与函数!
