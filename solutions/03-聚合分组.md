# 第三阶段：聚合与分组完整答案

## 1. 基础聚合函数

### 1.1 COUNT 计数
```sql
SELECT
  status,
  CASE status
    WHEN 0 THEN '待支付'
    WHEN 1 THEN '已支付'
    WHEN 2 THEN '已发货'
    WHEN 3 THEN '已完成'
    WHEN 4 THEN '已取消'
  END as status_name,
  COUNT(*) as order_count
FROM orders
GROUP BY status
ORDER BY status;
```

### 1.2 SUM 求和
```sql
SELECT
  u.id,
  u.username,
  SUM(o.pay_amount) as total_spending
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.status >= 1  -- 已支付的订单
GROUP BY u.id, u.username
ORDER BY total_spending DESC
LIMIT 50;
```

### 1.3 AVG 平均值
```sql
SELECT
  c.id,
  c.name as category_name,
  COUNT(p.id) as product_count,
  ROUND(AVG(p.price), 2) as avg_price
FROM categories c
JOIN products p ON c.id = p.category_id
-- WHERE c.level = 1  -- 一级分类
GROUP BY c.id, c.name
ORDER BY avg_price DESC;
```

### 1.4 MAX/MIN 最值
```sql
SELECT
  user_id,
  COUNT(*) as order_count,
  MIN(pay_amount) as min_amount,
  MAX(pay_amount) as max_amount,
  AVG(pay_amount) as avg_amount
FROM orders
WHERE status = 3
GROUP BY user_id
HAVING order_count > 0
ORDER BY max_amount DESC
LIMIT 50;
```

---

## 2. GROUP BY 分组

### 2.1 单字段分组
```sql
SELECT
  YEAR(created_at) as register_year,
  COUNT(*) as user_count
FROM users
GROUP BY YEAR(created_at)
ORDER BY register_year;
```

### 2.2 多字段分组
```sql
SELECT
  DATE_FORMAT(created_at, '%Y') as year,
  DATE_FORMAT(created_at, '%m') as month,
  COUNT(*) as order_count,
  SUM(pay_amount) as total_amount
FROM orders
WHERE status >= 1
GROUP BY DATE_FORMAT(created_at, '%Y'), DATE_FORMAT(created_at, '%m')
ORDER BY year DESC, month DESC
LIMIT 12;
```

### 2.3 分组后筛选
```sql
SELECT
  u.id,
  u.username,
  COUNT(o.id) as purchase_count
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.status = 3
GROUP BY u.id, u.username
HAVING COUNT(o.id) > 5
ORDER BY purchase_count DESC;
```

---

## 3. HAVING 子句

### 3.1 HAVING vs WHERE
```sql
-- 统计平均价格超过500的商品分类
SELECT
  c.id,
  c.name as category_name,
  COUNT(p.id) as product_count,
  AVG(p.price) as avg_price
FROM categories c
JOIN products p ON c.id = p.category_id
WHERE p.status = 1  -- WHERE: 过滤商品（分组前）
GROUP BY c.id, c.name
HAVING AVG(p.price) > 500  -- HAVING: 过滤分组结果（分组后）
ORDER BY avg_price DESC;
```

### 3.2 复杂 HAVING 条件
```sql
SELECT
  user_id,
  COUNT(*) as order_count,
  SUM(pay_amount) as total_amount
FROM orders
WHERE status = 3
GROUP BY user_id
HAVING COUNT(*) >= 3 AND SUM(pay_amount) > 1000
ORDER BY total_amount DESC;
```

---

## 4. GROUP_CONCAT 字符串聚合

### 4.1 合并字符串
```sql
SELECT
  o.id,
  o.order_no,
  GROUP_CONCAT(oi.product_name SEPARATOR ', ') as product_list
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
GROUP BY o.id, o.order_no
ORDER BY o.created_at DESC
LIMIT 20;
```

### 4.2 带分隔符和排序
```sql
SELECT
  u.id,
  u.username,
  GROUP_CONCAT(
    CONCAT(ua.province, '-', ua.city, '-', ua.district)
    ORDER BY ua.is_default DESC, ua.id
    SEPARATOR ' | '
  ) as address_list
FROM users u
JOIN user_addresses ua ON u.id = ua.user_id
GROUP BY u.id, u.username
LIMIT 30;
```

---

## 5. 分组统计实战

### 5.1 商品销售排行
```sql
SELECT
  p.id,
  p.name as product_name,
  COUNT(DISTINCT oi.order_id) as order_count,
  SUM(oi.quantity) as total_quantity,
  SUM(oi.total_amount) as total_revenue
FROM products p
JOIN order_items oi ON p.id = oi.product_id
JOIN orders o ON oi.order_id = o.id
WHERE o.status = 3
GROUP BY p.id, p.name
HAVING total_quantity > 0
ORDER BY total_revenue DESC
LIMIT 20;
```

### 5.2 用户消费分析
```sql
SELECT
  u.username,
  COUNT(o.id) as order_count,
  SUM(o.pay_amount) as total_spending,
  AVG(o.pay_amount) as avg_order_amount,
  MAX(o.created_at) as last_order_time
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.status = 3
GROUP BY u.id, u.username
ORDER BY total_spending DESC
LIMIT 50;
```

### 5.3 每日订单统计
```sql
SELECT
  DATE(created_at) as order_date,
  COUNT(*) as order_count,
  SUM(pay_amount) as daily_revenue,
  AVG(pay_amount) as avg_order_amount
FROM orders
WHERE created_at >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
  AND status >= 1
GROUP BY DATE(created_at)
ORDER BY order_date DESC;
```

### 5.4 分类销售占比
```sql
SELECT
  c.name as category_name,
  SUM(oi.total_amount) as category_revenue,
  ROUND(
    SUM(oi.total_amount) * 100.0 / (
      SELECT SUM(total_amount)
      FROM order_items oi2
      JOIN orders o2 ON oi2.order_id = o2.id
      WHERE o2.status = 3
    ),
    2
  ) as revenue_percentage
FROM categories c
JOIN products p ON c.id = p.category_id
JOIN order_items oi ON p.id = oi.product_id
JOIN orders o ON oi.order_id = o.id
WHERE c.level = 1 AND o.status = 3
GROUP BY c.id, c.name
ORDER BY category_revenue DESC;
```

---

## 6. 时间维度分组

### 6.1 按小时统计
```sql
SELECT
  HOUR(created_at) as hour_of_day,
  COUNT(*) as order_count
FROM orders
WHERE DATE(created_at) >= CURDATE() - INTERVAL 7 DAY
GROUP BY HOUR(created_at)
ORDER BY hour_of_day;
```

### 6.2 按星期统计
```sql
SELECT
  DAYOFWEEK(created_at) as day_of_week,
  CASE DAYOFWEEK(created_at)
    WHEN 1 THEN '周日'
    WHEN 2 THEN '周一'
    WHEN 3 THEN '周二'
    WHEN 4 THEN '周三'
    WHEN 5 THEN '周四'
    WHEN 6 THEN '周五'
    WHEN 7 THEN '周六'
  END as weekday_name,
  COUNT(*) as order_count,
  SUM(pay_amount) as total_amount
FROM orders
WHERE status >= 1
GROUP BY DAYOFWEEK(created_at)
ORDER BY order_count DESC;
```

### 6.3 按季度统计
```sql
SELECT
  YEAR(created_at) as year,
  QUARTER(created_at) as quarter,
  CONCAT(YEAR(created_at), 'Q', QUARTER(created_at)) as period,
  COUNT(*) as order_count,
  SUM(pay_amount) as quarterly_revenue
FROM orders
WHERE status >= 1
GROUP BY YEAR(created_at), QUARTER(created_at)
ORDER BY year DESC, quarter DESC;
```

---

## 7. WITH ROLLUP 小计

### 7.1 分类小计
```sql
SELECT
  c.name as category_name,
  COUNT(p.id) as product_count
FROM categories c
LEFT JOIN products p ON c.id = p.category_id
WHERE c.level = 1
GROUP BY c.name WITH ROLLUP;
-- 最后一行NULL表示总计
```

### 7.2 多维度汇总
```sql
SELECT
  CASE status
    WHEN 0 THEN '待支付'
    WHEN 1 THEN '已支付'
    WHEN 2 THEN '已发货'
    WHEN 3 THEN '已完成'
    WHEN 4 THEN '已取消'
  END as order_status,
  payment_method,
  COUNT(*) as order_count,
  SUM(pay_amount) as total_amount
FROM orders
WHERE payment_method IS NOT NULL
GROUP BY status, payment_method WITH ROLLUP
LIMIT 50;
```

---

## 8. 条件聚合

### 8.1 使用 CASE 进行条件统计
```sql
SELECT
  user_id,
  SUM(CASE WHEN pay_amount < 100 THEN 1 ELSE 0 END) as low_price_orders,
  SUM(CASE WHEN pay_amount BETWEEN 100 AND 500 THEN 1 ELSE 0 END) as mid_price_orders,
  SUM(CASE WHEN pay_amount > 500 THEN 1 ELSE 0 END) as high_price_orders,
  COUNT(*) as total_orders
FROM orders
WHERE status = 3
GROUP BY user_id
HAVING total_orders >= 3
ORDER BY total_orders DESC
LIMIT 50;
```

### 8.2 状态分布统计
```sql
SELECT
  DATE(created_at) as order_date,
  COUNT(CASE WHEN status = 0 THEN 1 END) as pending_payment,
  COUNT(CASE WHEN status = 1 THEN 1 END) as paid,
  COUNT(CASE WHEN status = 2 THEN 1 END) as shipped,
  COUNT(CASE WHEN status = 3 THEN 1 END) as completed,
  COUNT(CASE WHEN status = 4 THEN 1 END) as cancelled,
  COUNT(*) as total
FROM orders
WHERE created_at >= CURDATE() - INTERVAL 7 DAY
GROUP BY DATE(created_at)
ORDER BY order_date DESC;
```

---

## 9. 去重统计

### 9.1 DISTINCT 配合 COUNT
```sql
SELECT
  p.id,
  p.name as product_name,
  COUNT(DISTINCT o.user_id) as unique_buyers,
  COUNT(oi.id) as total_purchases,
  ROUND(COUNT(oi.id) * 1.0 / COUNT(DISTINCT o.user_id), 2) as repeat_rate
FROM products p
JOIN order_items oi ON p.id = oi.product_id
JOIN orders o ON oi.order_id = o.id
WHERE o.status = 3
GROUP BY p.id, p.name
HAVING unique_buyers >= 5
ORDER BY unique_buyers DESC
LIMIT 30;
```

### 9.2 多维度去重
```sql
SELECT
  u.id,
  u.username,
  COUNT(DISTINCT DATE(o.created_at)) as active_days,
  COUNT(DISTINCT oi.product_id) as unique_products,
  COUNT(o.id) as total_orders
FROM users u
JOIN orders o ON u.id = o.user_id
JOIN order_items oi ON o.id = oi.order_id
WHERE o.status = 3
GROUP BY u.id, u.username
ORDER BY active_days DESC
LIMIT 50;
```

---

## 10. 综合练习

### 10.1 RFM 分析
```sql
SELECT
  u.id,
  u.username,
  DATEDIFF(CURDATE(), MAX(o.created_at)) as recency_days,
  COUNT(o.id) as frequency,
  SUM(o.pay_amount) as monetary
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.status = 3
GROUP BY u.id, u.username
ORDER BY monetary DESC
LIMIT 100;
```

### 10.2 商品复购率分析
```sql
SELECT
  p.id,
  p.name as product_name,
  COUNT(oi.id) as total_purchases,
  COUNT(DISTINCT o.user_id) as unique_buyers,
  ROUND(COUNT(oi.id) * 1.0 / COUNT(DISTINCT o.user_id), 2) as repeat_purchase_rate
FROM products p
JOIN order_items oi ON p.id = oi.product_id
JOIN orders o ON oi.order_id = o.id
WHERE o.status = 3
GROUP BY p.id, p.name
HAVING unique_buyers >= 5
ORDER BY repeat_purchase_rate DESC
LIMIT 20;
```

### 10.3 月度增长分析
```sql
WITH monthly_stats AS (
  SELECT
    DATE_FORMAT(created_at, '%Y-%m') as month,
    COUNT(*) as order_count,
    SUM(pay_amount) as revenue
  FROM orders
  WHERE status >= 1
  GROUP BY DATE_FORMAT(created_at, '%Y-%m')
)
SELECT
  month,
  order_count,
  revenue,
  LAG(revenue, 1) OVER (ORDER BY month) as prev_month_revenue,
  ROUND(
    (revenue - LAG(revenue, 1) OVER (ORDER BY month)) * 100.0 /
    LAG(revenue, 1) OVER (ORDER BY month),
    2
  ) as growth_rate
FROM monthly_stats
ORDER BY month DESC
LIMIT 12;
```

### 10.4 用户分层统计
```sql
SELECT
  CASE
    WHEN total_spending >= 10000 THEN 'VIP'
    WHEN total_spending >= 5000 THEN '高价值'
    WHEN total_spending >= 1000 THEN '中等'
    ELSE '普通'
  END as user_level,
  COUNT(*) as user_count,
  SUM(order_count) as total_orders,
  SUM(total_spending) as total_revenue,
  AVG(total_spending) as avg_spending
FROM (
  SELECT
    user_id,
    COUNT(*) as order_count,
    SUM(pay_amount) as total_spending
  FROM orders
  WHERE status = 3
  GROUP BY user_id
) user_stats
GROUP BY
  CASE
    WHEN total_spending >= 10000 THEN 'VIP'
    WHEN total_spending >= 5000 THEN '高价值'
    WHEN total_spending >= 1000 THEN '中等'
    ELSE '普通'
  END
ORDER BY
  CASE user_level
    WHEN 'VIP' THEN 1
    WHEN '高价值' THEN 2
    WHEN '中等' THEN 3
    ELSE 4
  END;
```

### 10.5 购物车转化分析
```sql
SELECT
  u.id,
  u.username,
  COUNT(DISTINCT c.product_id) as cart_products,
  COUNT(DISTINCT oi.product_id) as purchased_products,
  ROUND(
    COUNT(DISTINCT oi.product_id) * 100.0 /
    NULLIF(COUNT(DISTINCT c.product_id), 0),
    2
  ) as conversion_rate
FROM users u
LEFT JOIN cart_items c ON u.id = c.user_id
LEFT JOIN orders o ON u.id = o.user_id AND o.status = 3
LEFT JOIN order_items oi ON o.id = oi.order_id
WHERE EXISTS (SELECT 1 FROM cart_items WHERE user_id = u.id)
GROUP BY u.id, u.username
HAVING cart_products > 0
ORDER BY conversion_rate DESC
LIMIT 50;
```

---

## 学习要点总结

### 1. GROUP BY 执行顺序

```
FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY -> LIMIT
```

**关键理解：**
- WHERE：过滤原始数据（分组前）
- HAVING：过滤分组结果（分组后）
- SELECT中的聚合函数在GROUP BY之后执行

### 2. 常用聚合函数

| 函数 | 说明 | 示例 |
|------|------|------|
| COUNT(*) | 统计行数（包括NULL） | `COUNT(*)` |
| COUNT(col) | 统计非NULL值 | `COUNT(user_id)` |
| COUNT(DISTINCT col) | 统计唯一值 | `COUNT(DISTINCT user_id)` |
| SUM(col) | 求和 | `SUM(pay_amount)` |
| AVG(col) | 平均值 | `AVG(price)` |
| MAX(col) | 最大值 | `MAX(created_at)` |
| MIN(col) | 最小值 | `MIN(price)` |
| GROUP_CONCAT() | 字符串连接 | `GROUP_CONCAT(name)` |

### 3. 常见陷阱

**陷阱1：SELECT中的非聚合字段**
```sql
-- 错误：price不在GROUP BY中
SELECT category_id, price, COUNT(*)
FROM products
GROUP BY category_id;

-- 正确：要么聚合，要么在GROUP BY中
SELECT category_id, AVG(price), COUNT(*)
FROM products
GROUP BY category_id;
```

**陷阱2：HAVING vs WHERE**
```sql
-- 错误：不能在WHERE中使用聚合函数
SELECT user_id, COUNT(*) as cnt
FROM orders
WHERE COUNT(*) > 5  -- ❌ 错误
GROUP BY user_id;

-- 正确：使用HAVING
SELECT user_id, COUNT(*) as cnt
FROM orders
GROUP BY user_id
HAVING COUNT(*) > 5;  -- ✅ 正确
```

**陷阱3：NULL值处理**
```sql
-- COUNT(column) 不统计NULL
SELECT
  COUNT(*) as total_users,  -- 1000
  COUNT(phone) as users_with_phone  -- 可能 < 1000
FROM users;

-- 使用IFNULL/COALESCE处理NULL
SELECT
  category_id,
  IFNULL(SUM(stock), 0) as total_stock
FROM products
GROUP BY category_id;
```

### 4. 性能优化建议

1. **GROUP BY字段建立索引**
   ```sql
   CREATE INDEX idx_category ON products(category_id);
   ```

2. **避免不必要的排序**
   ```sql
   -- MySQL默认会对GROUP BY结果排序
   -- 如果不需要排序，使用 ORDER BY NULL
   SELECT category_id, COUNT(*)
   FROM products
   GROUP BY category_id
   ORDER BY NULL;
   ```

3. **先WHERE后GROUP BY**
   ```sql
   -- 好：先过滤再分组
   SELECT category_id, COUNT(*)
   FROM products
   WHERE status = 1  -- 先过滤
   GROUP BY category_id;
   ```

4. **使用覆盖索引**
   ```sql
   -- 如果查询只涉及索引字段，可以避免回表
   CREATE INDEX idx_status_category ON products(status, category_id);
   ```

恭喜完成第三阶段！继续进入第四阶段学习高级查询。
