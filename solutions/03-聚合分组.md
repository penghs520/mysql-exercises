# 第三阶段：聚合与分组完整答案

## 核心知识点

### 1. 聚合函数的本质原理

**什么是聚合函数?**
- 聚合函数对一组值进行计算并返回单个值(多行 → 一行)
- 本质是将多行数据"折叠"成一行统计结果
- 常与 GROUP BY 配合,对每个分组分别进行聚合计算

**执行原理:**
```
原始数据(多行) → 分组(GROUP BY) → 每组聚合计算 → 输出结果(每组一行)
```

**内存处理:**
- MySQL 需要在内存中维护分组数据和聚合状态
- 如果分组数过多,会使用临时表(磁盘),性能下降
- `tmp_table_size` 和 `max_heap_table_size` 控制内存临时表大小

### 2. GROUP BY 的执行流程

**完整的SQL执行顺序:**
```
1. FROM      - 确定数据源表
2. WHERE     - 过滤原始行(分组前)
3. GROUP BY  - 按指定字段分组
4. 聚合计算   - 对每组执行 COUNT/SUM/AVG 等
5. HAVING    - 过滤分组结果(分组后)，  为什么HAVING要放在聚合计算后，因为这样可以在HAVING中使用聚合计算结果进行过滤
6. SELECT    - 选择要显示的列
7. ORDER BY  - 对结果排序
8. LIMIT     - 限制返回行数
```

**重要规则:**
- WHERE 在分组前执行 → 可以减少分组的数据量(提升性能)
- HAVING 在分组后执行 → 只能过滤分组结果,不能减少计算量
- 当使用分组时，SELECT 中只能出现: ①聚合函数 ②GROUP BY中的字段 ③常量
```sql
-- ❌ 错误: name 不在 GROUP BY 中,每组有多个不同的 name,返回哪个?
-- 调整sql_mode系统变量为''可以直接select普通字段 
SELECT category_id, name, COUNT(*)
FROM products
GROUP BY category_id;

-- ✅ 正确: 使用聚合函数或加入 GROUP BY
-- name在聚合函数中允许
SELECT category_id, MAX(name), COUNT(*)
FROM products
GROUP BY category_id;
```



### 3. MySQL 分组实现算法

**Loose Index Scan (松散索引扫描):**
- 当 GROUP BY 字段有索引时使用
- 直接读取索引中每组的第一条记录,跳过其他记录
- 性能最优: O(组数) 而非 O(总行数)
- EXPLAIN 显示: `Using index for group-by`

**Tight Index Scan (紧凑索引扫描):**
- 扫描索引中所有相关记录
- 边扫描边累积聚合值
- EXPLAIN 显示: `Using index`

**临时表方式:**
- 无法使用索引时,创建临时表存储分组数据
- 内存临时表(快) 或 磁盘临时表(慢)
- EXPLAIN 显示: `Using temporary`

**性能对比:**
```
Loose Index Scan > Tight Index Scan > 内存临时表 > 磁盘临时表
```

### 4. 聚合函数特性对比

| 函数 | NULL处理 | DISTINCT支持 | 性能 | 注意事项 |
|------|---------|-------------|------|---------|
| COUNT(*) | 计入 | 不适用 | 最快 | 统计行数,不读取列值 |
| COUNT(col) | 忽略 | 支持 | 较快 | 需要读取列值 |
| COUNT(DISTINCT col) | 忽略 | - | 慢 | 需要去重,可能用临时表 |
| SUM(col) | 忽略 | 支持 | 快 | 遇到NULL返回NULL |
| AVG(col) | 忽略 | 支持 | 快 | NULL不参与计算 |
| MAX/MIN(col) | 忽略 | - | 快 | 有索引时可优化 |
| GROUP_CONCAT() | 忽略 | 支持 | 慢 | 受 group_concat_max_len 限制 |

### 5. WHERE vs HAVING 的本质区别

| 对比项 | WHERE | HAVING |
|-------|-------|--------|
| 执行时机 | 分组前(第2步) | 分组后(第5步) |
| 过滤对象 | 原始行 | 分组结果 |
| 能否用聚合函数 | ❌ 不能 | ✅ 可以 |
| 性能影响 | 减少分组数据量 | 不减少计算量 |
| 索引使用 | 可以使用索引 | 通常无法用索引 |

**性能优化原则:**
- 能用 WHERE 的条件不要用 HAVING
- WHERE 能减少参与分组的数据量,提升性能

---

## 1. 基础聚合函数

### 知识点: COUNT 函数的三种形式

**1. COUNT(*) - 统计行数**
- 不读取任何列的值,直接统计行数
- 包含 NULL 值的行
- 性能最优: InnoDB 优化为扫描最小的索引

**2. COUNT(column) - 统计非NULL值**
- 需要读取列的值并判断是否为 NULL
- 忽略 NULL 值
- 性能: 比 COUNT(*) 稍慢(需要读取列值)

**3. COUNT(DISTINCT column) - 统计唯一值**
- 需要去重操作,通常使用临时表
- 忽略 NULL 值
- 性能最差: 需要排序或哈希去重

**示例对比:**
```sql
SELECT
  COUNT(*) as total,           -- 1000 (所有行)
  COUNT(phone) as has_phone,   -- 800  (phone非NULL的行)
  COUNT(DISTINCT city) as cities -- 50   (唯一城市数)
FROM users;
```

### 1.1 COUNT 计数
```sql
SELECT
  status,
  CASE status
    WHEN 0 THEN '待支付'
    WHEN 1 THEN '已支付'
    WHEN 2 THEN '已发货'
    WHEN 3 THEN '已完成'
    WHEN 4 THEN '已取消'
  END as status_name,
  COUNT(*) as order_count
FROM orders
GROUP BY status
ORDER BY status;
```

### 1.2 SUM 求和
```sql
SELECT
  u.id,
  u.username,
  SUM(o.pay_amount) as total_spending
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.status >= 1  -- 已支付的订单
GROUP BY u.id, u.username
ORDER BY total_spending DESC
LIMIT 50;
```

### 1.3 AVG 平均值
```sql
SELECT
  c.id,
  c.name as category_name,
  COUNT(p.id) as product_count,
  ROUND(AVG(p.price), 2) as avg_price
FROM categories c
JOIN products p ON c.id = p.category_id
WHERE c.level = 1  -- 一级分类
GROUP BY c.id, c.name
ORDER BY avg_price DESC;
```

### 1.4 MAX/MIN 最值
```sql
SELECT
  user_id,
  COUNT(*) as order_count,
  MIN(pay_amount) as min_amount,
  MAX(pay_amount) as max_amount,
  AVG(pay_amount) as avg_amount
FROM orders
WHERE status = 3
GROUP BY user_id
HAVING order_count > 0
ORDER BY max_amount DESC
LIMIT 50;
```

---

## 2. GROUP BY 分组

### 知识点: GROUP BY 的工作原理

**分组的本质:**
- 将具有相同分组字段值的行聚合成一组
- 每组最终输出一行结果
- 组内数据通过聚合函数进行计算

**示例理解:**
```sql
-- 原始数据
user_id | amount
--------|-------
1       | 100
1       | 200
2       | 150
2       | 300

-- GROUP BY user_id 后的逻辑结构
组1: user_id=1 → [100, 200] → SUM=300
组2: user_id=2 → [150, 300] → SUM=450
```

**MySQL 8.0 的 ONLY_FULL_GROUP_BY 模式:**
- 默认启用,要求 SELECT 中的非聚合列必须出现在 GROUP BY 中
- 防止返回不确定的结果
```sql
-- ❌ 错误: name 不在 GROUP BY 中,每组有多个不同的 name,返回哪个?
SELECT category_id, name, COUNT(*)
FROM products
GROUP BY category_id;

-- ✅ 正确: 使用聚合函数或加入 GROUP BY
SELECT category_id, MAX(name), COUNT(*)
FROM products
GROUP BY category_id;
```

### 2.1 单字段分组
```sql
SELECT
  YEAR(created_at) as register_year,
  COUNT(*) as user_count
FROM users
GROUP BY YEAR(created_at)
ORDER BY register_year;
```

### 2.2 多字段分组
```sql
SELECT
  DATE_FORMAT(created_at, '%Y') as year,
  DATE_FORMAT(created_at, '%m') as month,
  COUNT(*) as order_count,
  SUM(pay_amount) as total_amount
FROM orders
WHERE status >= 1
GROUP BY DATE_FORMAT(created_at, '%Y'), DATE_FORMAT(created_at, '%m')
ORDER BY year DESC, month DESC
LIMIT 12;
```

### 2.3 分组后筛选
```sql
SELECT
  u.id,
  u.username,
  COUNT(o.id) as purchase_count
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.status = 3
GROUP BY u.id, u.username
HAVING COUNT(o.id) > 5
ORDER BY purchase_count DESC;
```

---

## 3. HAVING 子句

### 知识点: HAVING 的使用场景

**何时使用 HAVING?**
- 需要对聚合结果进行过滤时
- 条件中包含聚合函数(COUNT、SUM、AVG等)时
- having中的字段只能是聚合计算中的值、或者group by中出现的字段

**WHERE vs HAVING 选择原则:**
```sql
-- 场景1: 过滤原始数据 → 用 WHERE
SELECT category_id, COUNT(*)
FROM products
WHERE price > 100  -- ✅ 过滤商品,不是聚合结果
GROUP BY category_id;

-- 场景2: 过滤聚合结果 → 用 HAVING
SELECT category_id, COUNT(*) as cnt
FROM products
GROUP BY category_id
HAVING COUNT(*) > 10;  -- ✅ 过滤分组结果

-- 场景3: 同时使用 WHERE 和 HAVING
SELECT category_id, AVG(price) as avg_price
FROM products
WHERE status = 1           -- 先过滤: 只看上架商品
GROUP BY category_id
HAVING AVG(price) > 500;   -- 再过滤: 平均价格>500的分类
```

**性能对比:**
```sql
-- ❌ 性能差: 先分组100万行,再过滤
SELECT user_id, COUNT(*)
FROM orders
GROUP BY user_id
HAVING user_id < 1000;

-- ✅ 性能好: 先过滤到1000行,再分组
SELECT user_id, COUNT(*)
FROM orders
WHERE user_id < 1000  -- 利用索引快速过滤
GROUP BY user_id;
```

### 3.1 HAVING vs WHERE
```sql
-- 统计平均价格超过500的商品分类
SELECT
  c.id,
  c.name as category_name,
  COUNT(p.id) as product_count,
  AVG(p.price) as avg_price
FROM categories c
JOIN products p ON c.id = p.category_id
WHERE p.status = 1  -- WHERE: 过滤商品（分组前）
GROUP BY c.id, c.name
HAVING AVG(p.price) > 500  -- HAVING: 过滤分组结果（分组后）
ORDER BY avg_price DESC;
```

### 3.2 复杂 HAVING 条件
```sql
SELECT
  user_id,
  COUNT(*) as order_count,
  SUM(pay_amount) as total_amount
FROM orders
WHERE status = 3
GROUP BY user_id
HAVING COUNT(*) >= 3 AND SUM(pay_amount) > 1000
ORDER BY total_amount DESC;
```

---

## 4. GROUP_CONCAT 字符串聚合

### 知识点: GROUP_CONCAT 原理与限制

**功能:**
- 将一组字符串值连接成一个字符串
- 可以指定分隔符、排序、去重

**语法:**
```sql
GROUP_CONCAT([DISTINCT] expr [ORDER BY ...] [SEPARATOR 'str'])
```

**工作原理:**
1. 对每个分组,收集所有非NULL的值
2. 按 ORDER BY 排序(可选)
3. 用 SEPARATOR 连接成字符串
4. 返回结果字符串

**重要限制:**
- 默认最大长度: 1024 字节(由 `group_concat_max_len` 控制)
- 超过长度会被截断,不会报错
- 可以临时修改:
  ```sql
  SET SESSION group_concat_max_len = 10240;  -- 设置为10KB
  ```

**性能考虑:**
- 需要在内存中拼接字符串,大量数据时内存消耗大
- 排序会增加开销
- 不适合超大结果集(考虑应用层处理)

### 4.1 合并字符串
```sql
SELECT
  o.id,
  o.order_no,
  GROUP_CONCAT(oi.product_name SEPARATOR ', ') as product_list
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
GROUP BY o.id, o.order_no
ORDER BY o.created_at DESC
LIMIT 20;
```

### 4.2 带分隔符和排序
```sql
SELECT
  u.id,
  u.username,
  GROUP_CONCAT(
    CONCAT(ua.province, '-', ua.city, '-', ua.district)
    ORDER BY ua.is_default DESC, ua.id
    SEPARATOR ' | '
  ) as address_list
FROM users u
JOIN user_addresses ua ON u.id = ua.user_id
GROUP BY u.id, u.username
LIMIT 30;
```

---

## 5. 分组统计实战

### 5.1 商品销售排行
```sql
SELECT
  p.id,
  p.name as product_name,
  COUNT(DISTINCT oi.order_id) as order_count,
  SUM(oi.quantity) as total_quantity,
  SUM(oi.total_amount) as total_revenue
FROM products p
JOIN order_items oi ON p.id = oi.product_id
JOIN orders o ON oi.order_id = o.id
WHERE o.status = 3
GROUP BY p.id, p.name
HAVING total_quantity > 0
ORDER BY total_revenue DESC
LIMIT 20;
```

### 5.2 用户消费分析
```sql
SELECT
  u.username,
  COUNT(o.id) as order_count,
  SUM(o.pay_amount) as total_spending,
  AVG(o.pay_amount) as avg_order_amount,
  MAX(o.created_at) as last_order_time
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.status = 3
GROUP BY u.id, u.username
ORDER BY total_spending DESC
LIMIT 50;
```

### 5.3 每日订单统计
```sql
SELECT
  DATE(created_at) as order_date,
  COUNT(*) as order_count,
  SUM(pay_amount) as daily_revenue,
  AVG(pay_amount) as avg_order_amount
FROM orders
WHERE created_at >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
  AND status >= 1
GROUP BY DATE(created_at)
ORDER BY order_date DESC;
```

### 5.4 分类销售占比
```sql
SELECT
  c.name as category_name,
  SUM(oi.total_amount) as category_revenue,
  ROUND(
    SUM(oi.total_amount) * 100.0 / (
      SELECT SUM(total_amount)
      FROM order_items oi2
      JOIN orders o2 ON oi2.order_id = o2.id
      WHERE o2.status = 3
    ),
    2
  ) as revenue_percentage
FROM categories c
JOIN products p ON c.id = p.category_id
JOIN order_items oi ON p.id = oi.product_id
JOIN orders o ON oi.order_id = o.id
WHERE c.level = 1 AND o.status = 3
GROUP BY c.id, c.name
ORDER BY category_revenue DESC;
```

---

## 6. 时间维度分组

### 6.1 按小时统计
```sql
SELECT
  HOUR(created_at) as hour_of_day,
  COUNT(*) as order_count
FROM orders
WHERE DATE(created_at) >= CURDATE() - INTERVAL 7 DAY
GROUP BY HOUR(created_at)
ORDER BY hour_of_day;
```

### 6.2 按星期统计
```sql
SELECT
  DAYOFWEEK(created_at) as day_of_week,
  CASE DAYOFWEEK(created_at)
    WHEN 1 THEN '周日'
    WHEN 2 THEN '周一'
    WHEN 3 THEN '周二'
    WHEN 4 THEN '周三'
    WHEN 5 THEN '周四'
    WHEN 6 THEN '周五'
    WHEN 7 THEN '周六'
  END as weekday_name,
  COUNT(*) as order_count,
  SUM(pay_amount) as total_amount
FROM orders
WHERE status >= 1
GROUP BY DAYOFWEEK(created_at)
ORDER BY order_count DESC;
```

### 6.3 按季度统计
```sql
SELECT
  YEAR(created_at) as year,
  QUARTER(created_at) as quarter,
  CONCAT(YEAR(created_at), 'Q', QUARTER(created_at)) as period,
  COUNT(*) as order_count,
  SUM(pay_amount) as quarterly_revenue
FROM orders
WHERE status >= 1
GROUP BY YEAR(created_at), QUARTER(created_at)
ORDER BY year DESC, quarter DESC;
```

---

## 7. WITH ROLLUP 小计

### 知识点: WITH ROLLUP 原理

**功能:**
- 在分组结果的基础上,自动生成小计和总计行
- 从右到左依次对 GROUP BY 的字段进行聚合

**工作原理:**
```sql
-- GROUP BY a, b, c WITH ROLLUP
-- 生成以下层级的汇总:
1. GROUP BY a, b, c  -- 最细粒度分组
2. GROUP BY a, b     -- b的小计 (c显示为NULL)
3. GROUP BY a        -- a的小计 (b,c显示为NULL)
4. 总计               -- 全部NULL
```

**示例理解:**
```sql
SELECT category_id, status, COUNT(*) as cnt
FROM products
GROUP BY category_id, status WITH ROLLUP;

-- 结果类似:
-- category_id | status | cnt
-- ------------|--------|----
-- 1           | 0      | 5     ← 分类1,状态0
-- 1           | 1      | 10    ← 分类1,状态1
-- 1           | NULL   | 15    ← 分类1小计
-- 2           | 0      | 3     ← 分类2,状态0
-- 2           | 1      | 8     ← 分类2,状态1
-- 2           | NULL   | 11    ← 分类2小计
-- NULL        | NULL   | 26    ← 总计
```

**使用场景:**
- 多维度数据分析报表
- 需要小计和总计的统计查询
- 替代多个 UNION 查询

### 7.1 分类小计
```sql
SELECT
  c.name as category_name,
  COUNT(p.id) as product_count
FROM categories c
LEFT JOIN products p ON c.id = p.category_id
WHERE c.level = 1
GROUP BY c.name WITH ROLLUP;
-- 最后一行NULL表示总计
```

### 7.2 多维度汇总
```sql
SELECT
  CASE status
    WHEN 0 THEN '待支付'
    WHEN 1 THEN '已支付'
    WHEN 2 THEN '已发货'
    WHEN 3 THEN '已完成'
    WHEN 4 THEN '已取消'
  END as order_status,
  payment_method,
  COUNT(*) as order_count,
  SUM(pay_amount) as total_amount
FROM orders
WHERE payment_method IS NOT NULL
GROUP BY status, payment_method WITH ROLLUP
LIMIT 50;
```

---

## 8. 条件聚合

### 知识点: 条件聚合的实现方式

**核心思想:**
- 使用 CASE WHEN 在聚合函数内部进行条件判断
- 将行数据"转置"为列数据(行转列)
- 一次查询完成多个维度的统计

**常用模式:**

**1. 条件计数:**
```sql
SUM(CASE WHEN condition THEN 1 ELSE 0 END)
-- 或
COUNT(CASE WHEN condition THEN 1 END)  -- ELSE NULL,NULL不计入COUNT
```

**2. 条件求和:**
```sql
SUM(CASE WHEN condition THEN amount ELSE 0 END)
```

**3. 行转列(数据透视):**
```sql
SELECT
  date,
  SUM(CASE WHEN product = 'A' THEN sales ELSE 0 END) as product_A_sales,
  SUM(CASE WHEN product = 'B' THEN sales ELSE 0 END) as product_B_sales
FROM sales_data
GROUP BY date;
```

**性能优势:**
- 避免多次查询同一张表
- 减少应用层的数据处理
- 一次扫描完成多维度统计

### 8.1 使用 CASE 进行条件统计
```sql
SELECT
  user_id,
  SUM(CASE WHEN pay_amount < 100 THEN 1 ELSE 0 END) as low_price_orders,
  SUM(CASE WHEN pay_amount BETWEEN 100 AND 500 THEN 1 ELSE 0 END) as mid_price_orders,
  SUM(CASE WHEN pay_amount > 500 THEN 1 ELSE 0 END) as high_price_orders,
  COUNT(*) as total_orders
FROM orders
WHERE status = 3
GROUP BY user_id
HAVING total_orders >= 3
ORDER BY total_orders DESC
LIMIT 50;
```

### 8.2 状态分布统计
```sql
SELECT
  DATE(created_at) as order_date,
  COUNT(CASE WHEN status = 0 THEN 1 END) as pending_payment,
  COUNT(CASE WHEN status = 1 THEN 1 END) as paid,
  COUNT(CASE WHEN status = 2 THEN 1 END) as shipped,
  COUNT(CASE WHEN status = 3 THEN 1 END) as completed,
  COUNT(CASE WHEN status = 4 THEN 1 END) as cancelled,
  COUNT(*) as total
FROM orders
WHERE created_at >= CURDATE() - INTERVAL 7 DAY
GROUP BY DATE(created_at)
ORDER BY order_date DESC;
```

---

## 9. 去重统计

### 知识点: DISTINCT 在聚合中的应用

**COUNT(DISTINCT column) 原理:**
1. 扫描分组内的所有行
2. 将 column 的值放入临时集合(去重)
3. 返回集合的大小

**去重算法:**
- **哈希去重**: 内存充足时使用,O(n) 时间复杂度
- **排序去重**: 内存不足时使用,O(n log n) 时间复杂度

**性能陷阱:**
```sql
-- ❌ 多个 COUNT(DISTINCT) 性能很差
SELECT
  COUNT(DISTINCT user_id),
  COUNT(DISTINCT product_id),
  COUNT(DISTINCT order_id)
FROM order_items;
-- 每个 DISTINCT 都需要独立的去重过程,无法共享

-- ✅ 优化方案: 分别查询或使用子查询
SELECT
  (SELECT COUNT(DISTINCT user_id) FROM order_items) as users,
  (SELECT COUNT(DISTINCT product_id) FROM order_items) as products,
  (SELECT COUNT(DISTINCT order_id) FROM order_items) as orders;
```

**SUM(DISTINCT column) vs SUM(column):**
```sql
-- 订单明细表数据
order_id | amount
---------|-------
1        | 100
1        | 200
2        | 150

-- SUM(amount) = 450 (所有行求和)
-- SUM(DISTINCT amount) = 450 (去重后: 100+200+150)
-- 注意: SUM(DISTINCT) 很少用,通常是逻辑错误
```

### 9.1 DISTINCT 配合 COUNT
```sql
SELECT
  p.id,
  p.name as product_name,
  COUNT(DISTINCT o.user_id) as unique_buyers,
  COUNT(oi.id) as total_purchases,
  ROUND(COUNT(oi.id) * 1.0 / COUNT(DISTINCT o.user_id), 2) as repeat_rate
FROM products p
JOIN order_items oi ON p.id = oi.product_id
JOIN orders o ON oi.order_id = o.id
WHERE o.status = 3
GROUP BY p.id, p.name
HAVING unique_buyers >= 5
ORDER BY unique_buyers DESC
LIMIT 30;
```

### 9.2 多维度去重
```sql
SELECT
  u.id,
  u.username,
  COUNT(DISTINCT DATE(o.created_at)) as active_days,
  COUNT(DISTINCT oi.product_id) as unique_products,
  COUNT(o.id) as total_orders
FROM users u
JOIN orders o ON u.id = o.user_id
JOIN order_items oi ON o.id = oi.order_id
WHERE o.status = 3
GROUP BY u.id, u.username
ORDER BY active_days DESC
LIMIT 50;
```

---

## 10. 综合练习

### 10.1 RFM 分析
```sql
SELECT
  u.id,
  u.username,
  DATEDIFF(CURDATE(), MAX(o.created_at)) as recency_days,
  COUNT(o.id) as frequency,
  SUM(o.pay_amount) as monetary
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.status = 3
GROUP BY u.id, u.username
ORDER BY monetary DESC
LIMIT 100;
```

### 10.2 商品复购率分析
```sql
SELECT
  p.id,
  p.name as product_name,
  COUNT(oi.id) as total_purchases,
  COUNT(DISTINCT o.user_id) as unique_buyers,
  ROUND(COUNT(oi.id) * 1.0 / COUNT(DISTINCT o.user_id), 2) as repeat_purchase_rate
FROM products p
JOIN order_items oi ON p.id = oi.product_id
JOIN orders o ON oi.order_id = o.id
WHERE o.status = 3
GROUP BY p.id, p.name
HAVING unique_buyers >= 5
ORDER BY repeat_purchase_rate DESC
LIMIT 20;
```

### 10.3 月度增长分析
```sql
WITH monthly_stats AS (
  SELECT
    DATE_FORMAT(created_at, '%Y-%m') as month,
    COUNT(*) as order_count,
    SUM(pay_amount) as revenue
  FROM orders
  WHERE status >= 1
  GROUP BY DATE_FORMAT(created_at, '%Y-%m')
)
SELECT
  month,
  order_count,
  revenue,
  LAG(revenue, 1) OVER (ORDER BY month) as prev_month_revenue,
  ROUND(
    (revenue - LAG(revenue, 1) OVER (ORDER BY month)) * 100.0 /
    LAG(revenue, 1) OVER (ORDER BY month),
    2
  ) as growth_rate
FROM monthly_stats
ORDER BY month DESC
LIMIT 12;
```

### 10.4 用户分层统计
```sql
SELECT
  CASE
    WHEN total_spending >= 10000 THEN 'VIP'
    WHEN total_spending >= 5000 THEN '高价值'
    WHEN total_spending >= 1000 THEN '中等'
    ELSE '普通'
  END as user_level,
  COUNT(*) as user_count,
  SUM(order_count) as total_orders,
  SUM(total_spending) as total_revenue,
  AVG(total_spending) as avg_spending
FROM (
  SELECT
    user_id,
    COUNT(*) as order_count,
    SUM(pay_amount) as total_spending
  FROM orders
  WHERE status = 3
  GROUP BY user_id
) user_stats
GROUP BY
  CASE
    WHEN total_spending >= 10000 THEN 'VIP'
    WHEN total_spending >= 5000 THEN '高价值'
    WHEN total_spending >= 1000 THEN '中等'
    ELSE '普通'
  END
ORDER BY
  CASE user_level
    WHEN 'VIP' THEN 1
    WHEN '高价值' THEN 2
    WHEN '中等' THEN 3
    ELSE 4
  END;
```

### 10.5 购物车转化分析
```sql
SELECT
  u.id,
  u.username,
  COUNT(DISTINCT c.product_id) as cart_products,
  COUNT(DISTINCT oi.product_id) as purchased_products,
  ROUND(
    COUNT(DISTINCT oi.product_id) * 100.0 /
    NULLIF(COUNT(DISTINCT c.product_id), 0),
    2
  ) as conversion_rate
FROM users u
LEFT JOIN cart_items c ON u.id = c.user_id
LEFT JOIN orders o ON u.id = o.user_id AND o.status = 3
LEFT JOIN order_items oi ON o.id = oi.order_id
WHERE EXISTS (SELECT 1 FROM cart_items WHERE user_id = u.id)
GROUP BY u.id, u.username
HAVING cart_products > 0
ORDER BY conversion_rate DESC
LIMIT 50;
```

---

## 学习要点总结

### 1. GROUP BY 执行顺序

```
FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY -> LIMIT
```

**关键理解：**
- WHERE：过滤原始数据（分组前）
- HAVING：过滤分组结果（分组后）
- SELECT中的聚合函数在GROUP BY之后执行

### 2. 常用聚合函数

| 函数 | 说明 | 示例 |
|------|------|------|
| COUNT(*) | 统计行数（包括NULL） | `COUNT(*)` |
| COUNT(col) | 统计非NULL值 | `COUNT(user_id)` |
| COUNT(DISTINCT col) | 统计唯一值 | `COUNT(DISTINCT user_id)` |
| SUM(col) | 求和 | `SUM(pay_amount)` |
| AVG(col) | 平均值 | `AVG(price)` |
| MAX(col) | 最大值 | `MAX(created_at)` |
| MIN(col) | 最小值 | `MIN(price)` |
| GROUP_CONCAT() | 字符串连接 | `GROUP_CONCAT(name)` |

### 3. 常见陷阱

**陷阱1：SELECT中的非聚合字段**
```sql
-- 错误：price不在GROUP BY中
SELECT category_id, price, COUNT(*)
FROM products
GROUP BY category_id;

-- 正确：要么聚合，要么在GROUP BY中
SELECT category_id, AVG(price), COUNT(*)
FROM products
GROUP BY category_id;
```

**陷阱2：HAVING vs WHERE**
```sql
-- 错误：不能在WHERE中使用聚合函数
SELECT user_id, COUNT(*) as cnt
FROM orders
WHERE COUNT(*) > 5  -- ❌ 错误
GROUP BY user_id;

-- 正确：使用HAVING
SELECT user_id, COUNT(*) as cnt
FROM orders
GROUP BY user_id
HAVING COUNT(*) > 5;  -- ✅ 正确
```

**陷阱3：NULL值处理**
```sql
-- COUNT(column) 不统计NULL
SELECT
  COUNT(*) as total_users,  -- 1000
  COUNT(phone) as users_with_phone  -- 可能 < 1000
FROM users;

-- 使用IFNULL/COALESCE处理NULL
SELECT
  category_id,
  IFNULL(SUM(stock), 0) as total_stock
FROM products
GROUP BY category_id;
```

### 4. 性能优化建议

**1. 在 GROUP BY 字段上建立索引**
```sql
CREATE INDEX idx_category ON products(category_id);
```
- 有索引: 可使用 Loose Index Scan,性能最优
- 无索引: 需要创建临时表,性能较差

**2. 避免 GROUP BY 默认排序**
```sql
-- MySQL 8.0 之前,GROUP BY 默认排序结果(按分组字段)
-- 不需要排序时,使用 ORDER BY NULL 避免额外开销
SELECT category_id, COUNT(*)
FROM products
GROUP BY category_id
ORDER BY NULL;  -- 节省排序开销

-- MySQL 8.0+ 已移除默认排序,但显式 ORDER BY NULL 仍然有效
```

**3. WHERE 优先于 HAVING**
```sql
-- ❌ 差: 100万行数据分组后再过滤
SELECT user_id, COUNT(*)
FROM orders
GROUP BY user_id
HAVING user_id < 1000;

-- ✅ 好: 先过滤到1000行再分组
SELECT user_id, COUNT(*)
FROM orders
WHERE user_id < 1000
GROUP BY user_id;
```

**4. 使用覆盖索引**
```sql
-- 如果查询只涉及索引字段,避免回表查询主键数据
CREATE INDEX idx_status_category ON products(status, category_id);

SELECT category_id, COUNT(*)
FROM products
WHERE status = 1
GROUP BY category_id;
-- EXPLAIN 显示: Using index (覆盖索引)
```

**5. 控制分组数量**
```sql
-- 分组数过多会导致内存临时表溢出到磁盘
-- 使用 WHERE 限制数据范围
SELECT user_id, COUNT(*)
FROM orders
WHERE created_at >= '2024-01-01'  -- 减少数据量
GROUP BY user_id;
```

**6. 避免复杂的聚合表达式**
```sql
-- ❌ 差: 表达式无法使用索引
SELECT DATE_FORMAT(created_at, '%Y-%m'), COUNT(*)
FROM orders
GROUP BY DATE_FORMAT(created_at, '%Y-%m');

-- ✅ 好: 使用虚拟列或预先计算
ALTER TABLE orders ADD COLUMN order_month VARCHAR(7)
  AS (DATE_FORMAT(created_at, '%Y-%m')) STORED;
CREATE INDEX idx_month ON orders(order_month);
```

**性能检查清单:**
- [ ] GROUP BY 字段是否有索引?
- [ ] 是否用 WHERE 先过滤数据?
- [ ] 是否避免了不必要的排序?
- [ ] 是否使用了覆盖索引?
- [ ] 分组数量是否可控?
- [ ] EXPLAIN 是否显示 Using temporary?

---

## 实战建议

1. **优先使用 WHERE 过滤**: 减少参与分组的数据量
2. **合理使用索引**: GROUP BY 字段必须有索引
3. **注意 NULL 处理**: 使用 IFNULL/COALESCE 处理聚合结果中的 NULL
4. **检查执行计划**: 使用 EXPLAIN 分析性能瓶颈
5. **控制结果集大小**: 使用 LIMIT 或额外的 WHERE 条件

恭喜完成第三阶段！继续进入第四阶段学习高级查询。
