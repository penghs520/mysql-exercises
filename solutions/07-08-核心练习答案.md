# 第7-8阶段核心练习答案

## 第七阶段：存储过程核心练习

### 1. 完整下单流程存储过程

```sql
DELIMITER $$

CREATE PROCEDURE CreateOrderComplete(
  IN p_user_id BIGINT,
  IN p_product_id BIGINT,
  IN p_quantity INT,
  IN p_address_id BIGINT,
  OUT p_order_id BIGINT,
  OUT p_success BOOLEAN,
  OUT p_message VARCHAR(200)
)
BEGIN
  DECLARE v_price DECIMAL(10,2);
  DECLARE v_stock INT;
  DECLARE v_product_name VARCHAR(200);
  DECLARE v_total_amount DECIMAL(10,2);
  DECLARE v_receiver_name VARCHAR(50);
  DECLARE v_receiver_phone VARCHAR(20);
  DECLARE v_receiver_address VARCHAR(500);
  DECLARE v_order_no VARCHAR(50);

  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    ROLLBACK;
    SET p_success = FALSE;
    SET p_message = '订单创建失败，事务已回滚';
  END;

  START TRANSACTION;

  -- 1. 验证用户
  IF NOT EXISTS(SELECT 1 FROM users WHERE id = p_user_id AND status = 1) THEN
    SET p_success = FALSE;
    SET p_message = '用户不存在或已禁用';
    ROLLBACK;
    LEAVE sp_label;
  END IF;

  -- 2. 获取商品信息并锁定
  SELECT price, stock, name INTO v_price, v_stock, v_product_name
  FROM products
  WHERE id = p_product_id AND status = 1
  FOR UPDATE;

  IF v_stock IS NULL THEN
    SET p_success = FALSE;
    SET p_message = '商品不存在或已下架';
    ROLLBACK;
    LEAVE sp_label;
  END IF;

  -- 3. 检查库存
  IF v_stock < p_quantity THEN
    SET p_success = FALSE;
    SET p_message = CONCAT('库存不足，当前库存: ', v_stock);
    ROLLBACK;
    LEAVE sp_label;
  END IF;

  -- 4. 获取收货地址
  SELECT receiver_name, phone, CONCAT(province, city, district, detail_address)
  INTO v_receiver_name, v_receiver_phone, v_receiver_address
  FROM user_addresses
  WHERE id = p_address_id AND user_id = p_user_id;

  IF v_receiver_name IS NULL THEN
    SET p_success = FALSE;
    SET p_message = '收货地址不存在';
    ROLLBACK;
    LEAVE sp_label;
  END IF;

  -- 5. 计算总金额
  SET v_total_amount = v_price * p_quantity;

  -- 6. 生成订单号
  SET v_order_no = CONCAT('ORD', DATE_FORMAT(NOW(), '%Y%m%d%H%i%s'), LPAD(FLOOR(RAND() * 10000), 4, '0'));

  -- 7. 创建订单
  INSERT INTO orders (
    order_no, user_id, total_amount, pay_amount, freight, status,
    receiver_name, receiver_phone, receiver_address
  ) VALUES (
    v_order_no, p_user_id, v_total_amount, v_total_amount, 0, 0,
    v_receiver_name, v_receiver_phone, v_receiver_address
  );

  SET p_order_id = LAST_INSERT_ID();

  -- 8. 创建订单明细
  INSERT INTO order_items (
    order_id, product_id, product_name, price, quantity, total_amount
  ) VALUES (
    p_order_id, p_product_id, v_product_name, v_price, p_quantity, v_total_amount
  );

  -- 9. 扣减库存
  UPDATE products
  SET stock = stock - p_quantity
  WHERE id = p_product_id;

  -- 10. 提交事务
  COMMIT;

  SET p_success = TRUE;
  SET p_message = CONCAT('订单创建成功，订单号: ', v_order_no);

  sp_label: BEGIN END;
END$$

DELIMITER ;

-- 测试调用
CALL CreateOrderComplete(1, 1, 2, 1, @order_id, @success, @msg);
SELECT @order_id, @success, @msg;
```

### 2. 库存扣减存储过程

```sql
DELIMITER $$

CREATE PROCEDURE DeductStockSafe(
  IN p_product_id BIGINT,
  IN p_quantity INT,
  OUT p_success BOOLEAN,
  OUT p_message VARCHAR(100)
)
BEGIN
  DECLARE v_stock INT;

  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    ROLLBACK;
    SET p_success = FALSE;
    SET p_message = '库存扣减异常';
  END;

  START TRANSACTION;

  -- 查询并锁定
  SELECT stock INTO v_stock
  FROM products
  WHERE id = p_product_id
  FOR UPDATE;

  IF v_stock IS NULL THEN
    SET p_success = FALSE;
    SET p_message = '商品不存在';
    ROLLBACK;
  ELSEIF v_stock < p_quantity THEN
    SET p_success = FALSE;
    SET p_message = CONCAT('库存不足，剩余: ', v_stock);
    ROLLBACK;
  ELSE
    -- 扣减库存
    UPDATE products
    SET stock = stock - p_quantity
    WHERE id = p_product_id;

    SET p_success = TRUE;
    SET p_message = '库存扣减成功';
    COMMIT;
  END IF;
END$$

DELIMITER ;
```

### 3. 订单状态流转触发器

```sql
-- 订单状态变更时自动更新时间戳
DELIMITER $$

CREATE TRIGGER tr_order_status_update
BEFORE UPDATE ON orders
FOR EACH ROW
BEGIN
  -- 待支付 -> 已支付
  IF OLD.status = 0 AND NEW.status = 1 AND NEW.payment_time IS NULL THEN
    SET NEW.payment_time = NOW();
  END IF;

  -- 已支付 -> 已发货
  IF OLD.status = 1 AND NEW.status = 2 AND NEW.delivery_time IS NULL THEN
    SET NEW.delivery_time = NOW();
  END IF;

  -- 已发货 -> 已完成
  IF OLD.status = 2 AND NEW.status = 3 AND NEW.finish_time IS NULL THEN
    SET NEW.finish_time = NOW();
  END IF;

  -- 更新修改时间
  SET NEW.updated_at = NOW();
END$$

DELIMITER ;
```

---

## 第八阶段：视图与权限核心练习

### 1. 创建常用业务视图

**订单汇总视图**
```sql
CREATE VIEW v_order_summary AS
SELECT
  o.id,
  o.order_no,
  o.created_at,
  u.username,
  u.email,
  o.total_amount,
  CASE o.status
    WHEN 0 THEN '待支付'
    WHEN 1 THEN '已支付'
    WHEN 2 THEN '已发货'
    WHEN 3 THEN '已完成'
    WHEN 4 THEN '已取消'
  END as status_name,
  o.receiver_name,
  o.receiver_phone,
  COUNT(oi.id) as item_count
FROM orders o
JOIN users u ON o.user_id = u.id
LEFT JOIN order_items oi ON o.id = oi.order_id
GROUP BY o.id, o.order_no, o.created_at, u.username, u.email,
         o.total_amount, o.status, o.receiver_name, o.receiver_phone;

-- 使用视图
SELECT * FROM v_order_summary
WHERE status_name = '已完成'
ORDER BY created_at DESC
LIMIT 20;
```

**商品销售统计视图**
```sql
CREATE VIEW v_product_sales AS
SELECT
  p.id,
  p.name,
  p.price,
  p.stock,
  IFNULL(SUM(oi.quantity), 0) as total_sold,
  IFNULL(SUM(oi.total_amount), 0) as total_revenue,
  IFNULL(AVG(pr.rating), 0) as avg_rating,
  COUNT(DISTINCT pr.id) as review_count
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN product_reviews pr ON p.id = pr.product_id
WHERE p.status = 1
GROUP BY p.id, p.name, p.price, p.stock;

-- 查询热销商品
SELECT * FROM v_product_sales
WHERE total_sold > 0
ORDER BY total_revenue DESC
LIMIT 20;
```

### 2. 数据脱敏视图

```sql
CREATE VIEW v_user_masked AS
SELECT
  id,
  username,
  -- 邮箱脱敏
  CONCAT(
    LEFT(email, 3),
    '***@',
    SUBSTRING_INDEX(email, '@', -1)
  ) as masked_email,
  -- 手机脱敏
  CONCAT(
    SUBSTRING(phone, 1, 3),
    '****',
    SUBSTRING(phone, 8, 4)
  ) as masked_phone,
  status,
  created_at
FROM users;

-- 查询
SELECT * FROM v_user_masked LIMIT 10;
```

### 3. 权限配置实战

**场景1：只读分析账号**
```sql
-- 1. 创建只读用户
CREATE USER 'analyst'@'%' IDENTIFIED BY 'analyst_password_123';

-- 2. 只授予视图查询权限
GRANT SELECT ON study_db.v_order_summary TO 'analyst'@'%';
GRANT SELECT ON study_db.v_product_sales TO 'analyst'@'%';
GRANT SELECT ON study_db.v_user_masked TO 'analyst'@'%';

-- 3. 禁止访问原表
REVOKE ALL ON study_db.* FROM 'analyst'@'%';

FLUSH PRIVILEGES;

-- 测试（需要切换到analyst用户）
-- SELECT * FROM v_order_summary LIMIT 10;  -- 可以
-- SELECT * FROM orders LIMIT 10;            -- 拒绝
```

**场景2：应用程序账号**
```sql
-- 1. 创建应用用户
CREATE USER 'app_service'@'%' IDENTIFIED BY 'app_secure_pwd_456';

-- 2. 授予必要的表权限
GRANT SELECT, INSERT, UPDATE ON study_db.orders TO 'app_service'@'%';
GRANT SELECT, INSERT, UPDATE ON study_db.order_items TO 'app_service'@'%';
GRANT SELECT, UPDATE ON study_db.products TO 'app_service'@'%';
GRANT SELECT ON study_db.users TO 'app_service'@'%';
GRANT SELECT ON study_db.user_addresses TO 'app_service'@'%';

-- 3. 授予存储过程执行权限
GRANT EXECUTE ON PROCEDURE study_db.CreateOrderComplete TO 'app_service'@'%';
GRANT EXECUTE ON PROCEDURE study_db.DeductStockSafe TO 'app_service'@'%';

-- 4. 禁止DELETE和DROP
-- （默认没有权限，无需REVOKE）

FLUSH PRIVILEGES;
```

**场景3：使用角色管理权限（MySQL 8.0+）**
```sql
-- 1. 创建角色
CREATE ROLE 'role_read_only';
CREATE ROLE 'role_order_manage';
CREATE ROLE 'role_admin';

-- 2. 为角色分配权限
-- 只读角色
GRANT SELECT ON study_db.* TO 'role_read_only';

-- 订单管理角色
GRANT SELECT, INSERT, UPDATE ON study_db.orders TO 'role_order_manage';
GRANT SELECT, INSERT, UPDATE ON study_db.order_items TO 'role_order_manage';
GRANT SELECT ON study_db.products TO 'role_order_manage';
GRANT SELECT ON study_db.users TO 'role_order_manage';

-- 管理员角色
GRANT ALL ON study_db.* TO 'role_admin';

-- 3. 创建用户并分配角色
CREATE USER 'readonly_user'@'%' IDENTIFIED BY 'pwd123';
GRANT 'role_read_only' TO 'readonly_user'@'%';
SET DEFAULT ROLE 'role_read_only' TO 'readonly_user'@'%';

CREATE USER 'order_manager'@'%' IDENTIFIED BY 'pwd456';
GRANT 'role_order_manage' TO 'order_manager'@'%';
SET DEFAULT ROLE 'role_order_manage' TO 'order_manager'@'%';
```

---

## 实践要点

### 存储过程最佳实践

1. **异常处理**：总是使用DECLARE HANDLER
2. **事务控制**：复杂操作使用事务保证原子性
3. **参数验证**：先验证输入参数
4. **日志记录**：记录关键操作（可创建日志表）
5. **性能考虑**：避免在存储过程中循环查询

### 视图使用建议

1. **简化查询**：封装复杂JOIN
2. **数据安全**：隐藏敏感字段
3. **性能注意**：视图不会提升性能，只是逻辑抽象
4. **避免过度使用**：视图套视图会影响可维护性

### 权限管理原则

1. **最小权限**：只授予必需的权限
2. **分层管理**：使用角色而不是直接授权
3. **定期审计**：检查权限分配
4. **密码策略**：使用强密码
5. **限制连接来源**：使用host限制（'user'@'192.168.1.%'）

继续学习第9-10阶段！
