# 第五阶段：索引优化完整答案

## 核心知识点

### 1. 索引的本质与数据结构

**索引是什么?**
- 索引是帮助 MySQL 高效获取数据的**数据结构**
- 类比: 书的目录,通过索引快速定位到目标页

**MySQL 索引类型:**

**1. B+Tree 索引 (默认,最常用)**
- 特点:
  - 平衡树,高度通常3-4层,查找 O(log n)
  - 叶子节点存储数据(聚簇索引)或主键(二级索引)
  - 叶子节点之间有指针,支持范围查询
- 适用:
  - 精确查询 (=, IN)
  - 范围查询 (>, <, BETWEEN)
  - 排序 (ORDER BY)
  - 分组 (GROUP BY)

**2. Hash 索引**
- 特点:
  - 基于哈希表,查找 O(1)
  - 只支持精确查询,不支持范围查询
- 适用:
  - Memory 表
  - 精确匹配 (=)

**3. 全文索引 (FULLTEXT)**
- 特点: 用于全文搜索
- 适用: TEXT/VARCHAR 大字段的关键词搜索

**4. 空间索引 (SPATIAL)**
- 特点: 用于地理空间数据
- 适用: GEOMETRY 类型

### 2. 聚簇索引 vs 二级索引

**聚簇索引 (Clustered Index):**
- InnoDB 中,主键就是聚簇索引
- **叶子节点存储完整的行数据**
- 每个表只有一个聚簇索引
- 数据按主键顺序物理存储

**二级索引 (Secondary Index):**
- 非主键索引都是二级索引
- **叶子节点存储: 索引列值 + 主键值**
- 查询流程:
  1. 在二级索引中找到主键值
  2. 回表: 用主键在聚簇索引中查找完整行数据

**回表的性能影响:**
```sql
-- 示例: idx_name 是 name 字段的二级索引
SELECT * FROM users WHERE name = 'Alice';

-- 执行过程:
-- 1. 在 idx_name 中找到 name='Alice' 的记录,获取主键 id=10
-- 2. 回表: 在聚簇索引中用 id=10 查找完整行数据
-- 总共: 2次B+树查找
```

**覆盖索引 (Covering Index) - 避免回表:**
```sql
-- 创建包含查询所需所有字段的索引
CREATE INDEX idx_name_age ON users(name, age);

SELECT name, age FROM users WHERE name = 'Alice';
-- 索引 idx_name_age 已包含 name 和 age,无需回表
-- EXPLAIN 显示: Using index
```

### 3. 索引的最左前缀原则

**组合索引: (a, b, c)**
- 可以匹配:
  - `WHERE a = 1`
  - `WHERE a = 1 AND b = 2`
  - `WHERE a = 1 AND b = 2 AND c = 3`
- 不能匹配:
  - `WHERE b = 2` (缺少 a)
  - `WHERE c = 3` (缺少 a 和 b)
  - `WHERE a = 1 AND c = 3` (b 断层,c 无法使用)

**原理:**
- B+Tree 索引按 (a, b, c) 的顺序排序
- 类比: 字典先按首字母,再按第二个字母排序
- 如果跳过前面的列,无法利用有序性

**示例:**
```sql
CREATE INDEX idx_abc ON orders(user_id, status, created_at);

-- ✅ 使用索引
SELECT * FROM orders WHERE user_id = 100;
SELECT * FROM orders WHERE user_id = 100 AND status = 1;
SELECT * FROM orders WHERE user_id = 100 AND status = 1 AND created_at > '2024-01-01';

-- ❌ 不使用索引
SELECT * FROM orders WHERE status = 1;  -- 缺少 user_id
SELECT * FROM orders WHERE created_at > '2024-01-01';  -- 缺少 user_id 和 status

-- ⚠️ 部分使用索引
SELECT * FROM orders WHERE user_id = 100 AND created_at > '2024-01-01';
-- user_id 使用索引, created_at 不使用(status 断层)
```

### 4. 索引失效的常见场景

**1. 在索引列上使用函数**
```sql
-- ❌ 索引失效
SELECT * FROM orders WHERE YEAR(created_at) = 2024;

-- ✅ 改写条件
SELECT * FROM orders WHERE created_at >= '2024-01-01' AND created_at < '2025-01-01';
```

**2. 隐式类型转换**
```sql
-- phone 是 VARCHAR 类型,有索引
-- ❌ 索引失效
SELECT * FROM users WHERE phone = 13800138000;  -- 数字类型

-- ✅ 使用字符串
SELECT * FROM users WHERE phone = '13800138000';
```

**3. LIKE 以 % 开头**
```sql
-- ❌ 索引失效
SELECT * FROM products WHERE name LIKE '%手机';

-- ✅ 可以使用索引
SELECT * FROM products WHERE name LIKE '手机%';
```

**4. OR 条件中有未建索引的列**
```sql
-- ❌ 索引失效 (status 无索引)
SELECT * FROM orders WHERE user_id = 100 OR status = 1;

-- ✅ 拆分为 UNION
SELECT * FROM orders WHERE user_id = 100
UNION
SELECT * FROM orders WHERE status = 1;
```

**5. 不等于 (!=, <>)**
```sql
-- ❌ 通常不走索引 (MySQL 认为扫描全表更快)
SELECT * FROM orders WHERE status != 0;

-- ✅ 使用 IN
SELECT * FROM orders WHERE status IN (1, 2, 3, 4);
```

### 5. EXPLAIN 执行计划分析

**关键字段解读:**

**type (访问类型) - 重要度 ⭐⭐⭐⭐⭐**
```
性能: system > const > eq_ref > ref > range > index > ALL

- system/const: 只有一行匹配,最优
- eq_ref: 主键或唯一索引,连接查询最优
- ref: 非唯一索引,常见的索引查找
- range: 范围查询 (>, <, BETWEEN, IN)
- index: 全索引扫描 (比 ALL 好,但仍需优化)
- ALL: 全表扫描 (最差,需优化)
```

**key (使用的索引) - 重要度 ⭐⭐⭐⭐⭐**
```
- NULL: 未使用索引,需要优化
- 索引名: 显示实际使用的索引
```

**rows (扫描行数) - 重要度 ⭐⭐⭐⭐**
```
- 预估扫描的行数,越少越好
- 与实际行数可能有差异(基于统计信息)
```

**Extra (额外信息) - 重要度 ⭐⭐⭐⭐⭐**
```
✅ 好的信号:
- Using index: 覆盖索引,无需回表
- Using index condition: 索引条件下推 (ICP)

⚠️ 需要优化:
- Using filesort: 无法使用索引排序,需要额外排序
- Using temporary: 使用临时表,GROUP BY/DISTINCT 常见
- Using where: 在存储引擎返回数据后,MySQL 再过滤

❌ 严重问题:
- Using join buffer: JOIN 没有使用索引,用内存缓冲
```

### 6. 索引条件下推 (Index Condition Pushdown, ICP)

**什么是索引条件下推?**
- MySQL 5.6+ 引入的优化技术
- 将部分 WHERE 条件的过滤操作从 MySQL Server 层下推到存储引擎层
- 减少回表次数,提升查询性能

**没有 ICP 的执行流程 (MySQL 5.5 及之前):**
```
1. 存储引擎层: 使用索引找到所有匹配索引条件的记录
2. 存储引擎层: 对每条记录回表,读取完整行数据
3. MySQL Server 层: 对返回的数据应用剩余 WHERE 条件过滤
```

**有 ICP 的执行流程 (MySQL 5.6+):**
```
1. 存储引擎层: 使用索引找到匹配索引条件的记录
2. 存储引擎层: 在索引上直接应用剩余 WHERE 条件过滤 ← 关键优化
3. 存储引擎层: 只对符合所有条件的记录回表
4. MySQL Server 层: 返回最终结果
```

**示例对比:**

```sql
-- 假设有索引: idx_name_age (name, age)
CREATE INDEX idx_name_age ON users(name, age);

-- 查询: 查找名字以 'Alice' 开头且年龄 > 25 的用户
SELECT * FROM users
WHERE name LIKE 'Alice%' AND age > 25;
```

**没有 ICP 的执行过程:**
```
1. 存储引擎: 在索引 idx_name_age 中找到所有 name LIKE 'Alice%' 的记录
   假设找到 100 条: Alice, Alice1, Alice2, ..., Alice99

2. 存储引擎: 对这 100 条记录全部回表,读取完整行数据
   (回表 100 次,即使其中很多 age <= 25)

3. Server 层: 过滤 age > 25 的记录
   假设只有 10 条满足

总计: 回表 100 次,只有 10 条有用
```

**有 ICP 的执行过程:**
```
1. 存储引擎: 在索引 idx_name_age 中找到所有 name LIKE 'Alice%' 的记录
   假设找到 100 条

2. 存储引擎: 在索引上直接检查 age > 25 ← ICP 优化
   索引中已包含 age 字段,直接过滤
   过滤后只剩 10 条满足条件的记录

3. 存储引擎: 只对这 10 条记录回表

总计: 回表 10 次,性能提升 10 倍
```

**ICP 的生效条件:**

1. **索引类型**: InnoDB 和 MyISAM 表
2. **索引包含条件列**: WHERE 条件中的列必须在索引中
3. **查询类型**: SELECT 语句
4. **非覆盖索引**: 如果是覆盖索引,直接返回,无需 ICP

**实战案例:**

```sql
-- 创建测试表和索引
CREATE TABLE employees (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  age INT,
  department VARCHAR(50),
  salary DECIMAL(10,2)
);

-- 创建组合索引
CREATE INDEX idx_name_age ON employees(name, age);

-- 插入测试数据
INSERT INTO employees VALUES
(1, 'Alice', 30, 'IT', 8000),
(2, 'Alice', 25, 'HR', 6000),
(3, 'Alice', 28, 'IT', 7500),
(4, 'Bob', 35, 'IT', 9000);

-- 查询1: 使用 ICP
EXPLAIN SELECT * FROM employees
WHERE name = 'Alice' AND age > 25;

-- EXPLAIN 结果:
-- type: ref
-- key: idx_name_age
-- Extra: Using index condition ← ICP 生效!

-- 执行过程:
-- 1. 在索引中找到 name='Alice' 的 3 条记录
-- 2. 在索引上过滤 age>25,剩 2 条 (Alice,30) 和 (Alice,28)
-- 3. 只对这 2 条记录回表获取完整数据
```

**关闭 ICP 对比性能:**

```sql
-- 关闭 ICP
SET optimizer_switch='index_condition_pushdown=off';

EXPLAIN SELECT * FROM employees
WHERE name = 'Alice' AND age > 25;
-- Extra: Using where (不再使用 ICP)

-- 执行过程:
-- 1. 在索引中找到 name='Alice' 的 3 条记录
-- 2. 对所有 3 条记录回表
-- 3. Server 层过滤 age>25

-- 开启 ICP (默认)
SET optimizer_switch='index_condition_pushdown=on';
```

**ICP 的限制:**

1. **不支持主键或唯一索引的精确查找**
   ```sql
   -- 不会使用 ICP (已经是最优查找)
   SELECT * FROM users WHERE id = 1;
   ```

2. **不支持覆盖索引**
   ```sql
   -- 覆盖索引,无需回表,不需要 ICP
   SELECT name, age FROM employees WHERE name = 'Alice' AND age > 25;
   -- Extra: Using index (不是 Using index condition)
   ```

3. **不支持触发器或存储函数**
   ```sql
   -- 函数导致无法使用 ICP
   SELECT * FROM employees WHERE UPPER(name) = 'ALICE' AND age > 25;
   ```

**ICP 的性能收益:**

- **减少回表次数**: 核心优势,尤其在过滤条件选择性高的场景
- **减少 I/O 操作**: 少读磁盘,降低延迟
- **提升吞吐量**: 高并发场景下效果明显

**最佳实践:**

1. ✅ 创建组合索引时,考虑 WHERE 条件的所有列
2. ✅ 保持 ICP 开启(默认)
3. ✅ 通过 EXPLAIN 验证是否使用 ICP
4. ✅ 对比 ICP 开启/关闭的性能差异

**验证 ICP 是否开启:**
```sql
SHOW VARIABLES LIKE 'optimizer_switch';
-- 查找 index_condition_pushdown=on
```

**分析示例:**
```sql
EXPLAIN SELECT * FROM orders WHERE user_id = 100 AND status = 1;

-- 理想结果:
-- type: ref
-- key: idx_user_status
-- rows: 10 (少量)
-- Extra: Using index condition
```

---

## 1. EXPLAIN 分析示例

### 1.1 基础分析
```sql
-- 分析查询性能
EXPLAIN SELECT * FROM orders WHERE user_id = 100;

-- 重点关注：
-- type: const/eq_ref/ref 较好，ALL最差
-- key: 实际使用的索引
-- rows: 扫描行数，越少越好
-- Extra: Using index(好), Using filesort(需优化)
```

**知识点:**
- EXPLAIN 不实际执行查询,只分析执行计划
- 关注 type、key、rows、Extra 四个关键字段
- 优化目标: type 越靠前越好,rows 越少越好

### 1.2 对比优化前后
```sql
-- 优化前
EXPLAIN SELECT * FROM orders WHERE status = 1;
-- type: ALL, rows: 20000, key: NULL (全表扫描)

-- 创建索引
CREATE INDEX idx_status ON orders(status);

-- 优化后
EXPLAIN SELECT * FROM orders WHERE status = 1;
-- type: ref, rows: 1000, key: idx_status (使用索引)
```

### 1.3 覆盖索引示例
```sql
-- 未覆盖: 需要回表
EXPLAIN SELECT id, username, email FROM users WHERE username = 'Alice';
-- Extra: NULL (需要回表获取 email)

-- 创建覆盖索引
CREATE INDEX idx_username_email ON users(username, email);

-- 覆盖索引: 无需回表
EXPLAIN SELECT id, username, email FROM users WHERE username = 'Alice';
-- Extra: Using index (覆盖索引,性能提升)
```

---

## 2. 创建合适的索引

### 2.1 单列索引
```sql
-- 为常用查询字段创建索引
CREATE INDEX idx_user_id ON orders(user_id);
CREATE INDEX idx_status ON orders(status);
CREATE INDEX idx_created_at ON orders(created_at);
```

**知识点:**
- 为 WHERE、JOIN、ORDER BY 中常用的列建索引
- 选择区分度高的列(唯一值多的列)
- 小表(< 1000行)不需要索引

### 2.2 组合索引(注意顺序)
```sql
-- 组合索引: 区分度高的列放前面
CREATE INDEX idx_user_status_time ON orders(user_id, status, created_at);

-- 可以匹配的查询:
-- WHERE user_id = 1
-- WHERE user_id = 1 AND status = 1
-- WHERE user_id = 1 AND status = 1 AND created_at > '2024-01-01'

-- 不能完全匹配的查询:
-- WHERE status = 1 (缺少 user_id)
-- WHERE user_id = 1 AND created_at > '2024-01-01' (status 断层)
```

**知识点:**
- 组合索引遵循最左前缀原则
- 区分度高的列放前面
- 等值查询列在前,范围查询列在后

### 2.3 前缀索引(长字符串)
```sql
-- 为长字符串创建前缀索引
CREATE INDEX idx_email_prefix ON users(email(20));

-- 查询仍然正常
SELECT * FROM users WHERE email = 'alice@example.com';
```

**知识点:**
- 长字符串(如 email, url)创建前缀索引节省空间
- 前缀长度要平衡: 太短区分度低,太长占空间
- 通过 `SELECT COUNT(DISTINCT LEFT(email, N))` 测试合适的长度

### 2.4 唯一索引
```sql
-- 保证数据唯一性
CREATE UNIQUE INDEX idx_email_unique ON users(email);

-- 插入重复数据会报错
INSERT INTO users (email) VALUES ('alice@example.com');
-- ERROR 1062: Duplicate entry 'alice@example.com' for key 'idx_email_unique'
```

**知识点:**
- 唯一索引既能加速查询,又能保证唯一性
- 业务上的唯一字段应该创建唯一索引
- 主键自动创建唯一索引

### 2.5 查看索引使用情况
```sql
-- 查看表的所有索引
SHOW INDEX FROM orders;

-- 查看索引统计信息
SELECT * FROM information_schema.statistics
WHERE table_name = 'orders';

-- 删除不用的索引
DROP INDEX idx_unused ON orders;
```

---

## 3. 索引优化案例

### 3.1 案例1: 全表扫描优化

**优化前：全表扫描**
```sql
-- 慢查询
SELECT * FROM orders
WHERE status = 1 AND created_at > '2024-01-01'
ORDER BY created_at DESC
LIMIT 20;

-- EXPLAIN 结果:
-- type: ALL, rows: 20000, key: NULL
-- Extra: Using where; Using filesort
```

**问题分析:**
1. type=ALL: 全表扫描
2. key=NULL: 未使用索引
3. Using filesort: 无法使用索引排序

**优化方案:**
```sql
-- 创建合适的组合索引
CREATE INDEX idx_status_time ON orders(status, created_at);

-- 再次执行同样的查询
-- EXPLAIN 结果:
-- type: range, rows: 100, key: idx_status_time
-- Extra: Using index condition
```

**优化效果:**
- 扫描行数: 20000 → 100 (减少200倍)
- 查询时间: 1000ms → 5ms (提升200倍)

### 3.2 案例2: 回表优化

**优化前：需要回表**
```sql
-- 查询用户名和邮箱
SELECT username, email FROM users
WHERE username = 'Alice';

-- EXPLAIN:
-- type: ref, key: idx_username
-- Extra: NULL (需要回表获取 email)
```

**优化方案:**
```sql
-- 创建覆盖索引
CREATE INDEX idx_username_email ON users(username, email);

-- 再次执行
-- EXPLAIN:
-- type: ref, key: idx_username_email
-- Extra: Using index (无需回表)
```

**优化效果:**
- 减少一次B+树查找
- 查询时间: 10ms → 3ms

### 3.3 案例3: JOIN 优化

**优化前：JOIN 慢**
```sql
-- 慢查询
SELECT o.*, u.username
FROM orders o
JOIN users u ON o.user_id = u.id
WHERE o.status = 1;

-- EXPLAIN orders:
-- type: ALL, rows: 20000, key: NULL
-- Extra: Using where; Using join buffer
```

**问题分析:**
- orders 表全表扫描
- 未使用索引,使用 join buffer

**优化方案:**
```sql
-- 为 orders.status 创建索引
CREATE INDEX idx_status ON orders(status);

-- 为 orders.user_id 创建索引 (JOIN 字段)
CREATE INDEX idx_user_id ON orders(user_id);

-- 再次执行
-- EXPLAIN orders:
-- type: ref, key: idx_status
-- EXPLAIN users:
-- type: eq_ref, key: PRIMARY
```

---

## 关键学习点总结

### 1. 索引设计原则
- 区分度高的列优先建索引
- 组合索引遵循最左前缀原则
- 覆盖索引避免回表,性能最优
- 不要在小表上建过多索引

### 2. EXPLAIN 必看字段
- `type`: ref/range 较好,ALL 最差
- `key`: NULL 表示未使用索引
- `rows`: 扫描行数,越少越好
- `Extra`: Using index(好), Using filesort(需优化)

### 3. 索引失效场景
- 索引列使用函数: `WHERE YEAR(date) = 2024`
- 隐式类型转换: `WHERE phone = 123` (phone 是 VARCHAR)
- LIKE 以 % 开头: `WHERE name LIKE '%keyword'`
- OR 条件中有未建索引的列
- 不等于操作: `WHERE status != 0`

### 4. 优化建议
- 养成 EXPLAIN 习惯,每条查询都分析
- 测试索引效果,对比优化前后性能
- 理解覆盖索引,通过调整索引结构避免回表
- 监控慢查询,找出性能瓶颈
- 定期清理无用索引

---

## 实践建议

1. ✅ **养成 EXPLAIN 习惯**: 每条查询都用 EXPLAIN 分析
2. ✅ **测试索引效果**: 对比添加索引前后的性能差异
3. ✅ **理解覆盖索引**: 尝试通过调整索引结构避免回表
4. ✅ **监控慢查询**: 找出慢查询并优化
5. ✅ **索引不是越多越好**: 权衡查询性能和写入性能

**性能优化清单:**
- [ ] 常用查询字段是否有索引?
- [ ] 组合索引顺序是否合理?
- [ ] 是否能使用覆盖索引?
- [ ] WHERE 条件是否导致索引失效?
- [ ] JOIN 字段是否有索引?
- [ ] EXPLAIN 显示的 type 是否可以接受?

继续努力,进入第六阶段学习事务处理!
