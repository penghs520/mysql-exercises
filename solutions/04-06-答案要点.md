# 第4-6阶段答案要点

由于这三个阶段的练习较为复杂且涉及大量实践操作，这里提供核心练习的答案要点和关键技巧。

---

## 第四阶段：高级查询关键答案

### 子查询示例

**查询价格高于平均价格的商品**
```sql
SELECT name, price,
  (SELECT AVG(price) FROM products) as avg_price,
  price - (SELECT AVG(price) FROM products) as price_diff
FROM products
WHERE price > (SELECT AVG(price) FROM products)
ORDER BY price DESC
LIMIT 20;
```

**IN子查询 - 购买过高价商品的用户**
```sql
SELECT id, username, email
FROM users
WHERE id IN (
  SELECT DISTINCT o.user_id
  FROM orders o
  JOIN order_items oi ON o.id = oi.order_id
  WHERE oi.price > 1000
);
```

**EXISTS子查询 - 有评价的商品**
```sql
SELECT id, name, price
FROM products p
WHERE EXISTS (
  SELECT 1 FROM product_reviews WHERE product_id = p.id
)
LIMIT 50;
```

### CTE (WITH) 示例

**用户消费统计**
```sql
WITH user_stats AS (
  SELECT
    user_id,
    COUNT(*) as order_count,
    SUM(pay_amount) as total_amount
  FROM orders
  WHERE status = 3
  GROUP BY user_id
)
SELECT
  u.username,
  us.order_count,
  us.total_amount,
  ROUND(us.total_amount / us.order_count, 2) as avg_order
FROM users u
JOIN user_stats us ON u.id = us.user_id
WHERE us.order_count >= 5
ORDER BY us.total_amount DESC
LIMIT 50;
```

### 窗口函数示例

**商品价格排名**
```sql
SELECT
  id,
  name,
  price,
  ROW_NUMBER() OVER (ORDER BY price DESC) as row_num,
  RANK() OVER (ORDER BY price DESC) as rank_num,
  DENSE_RANK() OVER (ORDER BY price DESC) as dense_rank_num
FROM products
WHERE status = 1
LIMIT 20;
```

**每个用户的订单累计消费**
```sql
SELECT
  user_id,
  order_no,
  pay_amount,
  created_at,
  SUM(pay_amount) OVER (
    PARTITION BY user_id
    ORDER BY created_at
  ) as cumulative_spending
FROM orders
WHERE user_id <= 10
ORDER BY user_id, created_at;
```

**每个分类TOP 3商品**
```sql
WITH ranked_products AS (
  SELECT
    p.*,
    c.name as category_name,
    ROW_NUMBER() OVER (
      PARTITION BY p.category_id
      ORDER BY p.sales DESC
    ) as rn
  FROM products p
  JOIN categories c ON p.category_id = c.id
  WHERE p.status = 1
)
SELECT category_name, name, price, sales, rn as rank
FROM ranked_products
WHERE rn <= 3
ORDER BY category_name, rn;
```

---

## 第五阶段：索引优化关键答案

### EXPLAIN分析示例

```sql
-- 分析查询性能
EXPLAIN SELECT * FROM orders WHERE user_id = 100;

-- 重点关注：
-- type: const/eq_ref/ref 较好，ALL最差
-- key: 实际使用的索引
-- rows: 扫描行数，越少越好
-- Extra: Using index(好), Using filesort(需优化)
```

### 创建合适的索引

```sql
-- 单列索引
CREATE INDEX idx_user_id ON orders(user_id);

-- 组合索引（注意顺序）
CREATE INDEX idx_user_status_time ON orders(user_id, status, created_at);

-- 前缀索引（长字符串）
CREATE INDEX idx_email_prefix ON users(email(20));

-- 查看索引使用情况
SHOW INDEX FROM orders;
```

### 索引优化案例

**优化前：全表扫描**
```sql
-- 慢查询
SELECT * FROM orders
WHERE status = 1 AND created_at > '2024-01-01'
ORDER BY created_at DESC
LIMIT 20;

-- EXPLAIN显示type=ALL, rows=20000
```

**优化后：使用索引**
```sql
-- 创建合适的索引
CREATE INDEX idx_status_time ON orders(status, created_at);

-- 再次执行同样的查询
-- EXPLAIN显示type=range, rows<100, Extra=Using index condition
```

---

## 第六阶段：事务处理关键答案

### 基本事务操作

```sql
-- 转账示例
START TRANSACTION;

-- 检查余额（这里假设users表有balance字段）
SELECT @balance := balance FROM users WHERE id = 1 FOR UPDATE;

-- 验证余额充足
-- 扣款
UPDATE users SET balance = balance - 100 WHERE id = 1;

-- 收款
UPDATE users SET balance = balance + 100 WHERE id = 2;

-- 提交
COMMIT;
-- 或回滚
-- ROLLBACK;
```

### 隔离级别测试

**模拟不可重复读（READ COMMITTED）**
```sql
-- 终端1
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
SELECT stock FROM products WHERE id = 1;  -- 读取：100

-- 终端2
START TRANSACTION;
UPDATE products SET stock = 50 WHERE id = 1;
COMMIT;

-- 终端1继续
SELECT stock FROM products WHERE id = 1;  -- 读取：50（已改变）
COMMIT;
```

### 库存扣减（防超卖）

**方案1：WHERE条件判断**
```sql
START TRANSACTION;

UPDATE products
SET stock = stock - 5
WHERE id = 100 AND stock >= 5;

-- 检查affected_rows
-- 如果为0，说明库存不足
SELECT ROW_COUNT() as affected;

COMMIT;
```

**方案2：悲观锁**
```sql
START TRANSACTION;

SELECT stock FROM products WHERE id = 100 FOR UPDATE;
-- 锁住该行

-- 应用层判断库存
-- 如果充足，执行扣减
UPDATE products SET stock = stock - 5 WHERE id = 100;

COMMIT;
```

### 死锁处理

**避免死锁的方法：**
1. 按固定顺序访问资源
2. 缩短事务时间
3. 降低隔离级别（谨慎）
4. 使用乐观锁

```sql
-- 按ID顺序更新（避免死锁）
START TRANSACTION;

-- 总是先更新ID小的
UPDATE products SET stock = stock - 1
WHERE id IN (1, 2, 3)
ORDER BY id;  -- 关键：按固定顺序

COMMIT;
```

---

## 关键学习点总结

### 第四阶段重点
1. 子查询类型：标量、列、行、表
2. CTE提高可读性
3. 窗口函数解决复杂排名问题
4. EXISTS vs IN的性能差异

### 第五阶段重点
1. EXPLAIN是性能分析的核心工具
2. 索引不是越多越好
3. 最左前缀原则
4. 覆盖索引避免回表

### 第六阶段重点
1. ACID特性理解
2. 不同隔离级别的适用场景
3. 锁机制：共享锁vs排他锁
4. 实际业务中的事务设计

---

## 实践建议

1. **多动手**：每个示例都要自己执行一遍
2. **使用EXPLAIN**：养成分析执行计划的习惯
3. **对比性能**：优化前后对比查询时间
4. **理解原理**：知其然也要知其所以然
5. **记录笔记**：整理常见问题和解决方案

继续努力，完成后续阶段的学习！
