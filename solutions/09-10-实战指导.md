# 第9-10阶段实战指导

这两个阶段重点在于实践和综合应用，答案不是唯一的，以下提供思路和框架。

---

## 第九阶段：性能优化实战指导

### 优化思路框架

#### 1. 发现问题

```sql
-- 开启慢查询日志
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;  -- 记录超过1秒的查询

-- 查看慢查询统计
SELECT
  DIGEST_TEXT as query_pattern,
  COUNT_STAR as exec_count,
  AVG_TIMER_WAIT / 1000000000000 as avg_time_sec,
  MAX_TIMER_WAIT / 1000000000000 as max_time_sec
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME = 'study_db'
ORDER BY AVG_TIMER_WAIT DESC
LIMIT 20;
```

#### 2. 分析问题

**使用EXPLAIN分析**
```sql
EXPLAIN SELECT ...;

-- 重点关注指标：
-- type: ALL(全表扫描) < index < range < ref < eq_ref < const
-- rows: 扫描行数，越少越好
-- Extra:
--   - Using index: 好！使用覆盖索引
--   - Using filesort: 需要优化排序
--   - Using temporary: 需要优化，使用了临时表
```

#### 3. 解决问题

**常见优化手段**

1. **添加索引**
```sql
-- 单列索引
CREATE INDEX idx_column ON table(column);

-- 组合索引（注意顺序）
CREATE INDEX idx_cols ON table(col1, col2, col3);
```

2. **优化查询语句**
```sql
-- 避免 SELECT *
SELECT id, name FROM products;

-- 避免函数导致索引失效
-- 不好
WHERE YEAR(created_at) = 2024
-- 好
WHERE created_at >= '2024-01-01' AND created_at < '2025-01-01'
```

3. **分页优化**
```sql
-- 传统分页（慢）
SELECT * FROM orders ORDER BY id LIMIT 10000, 20;

-- 优化1：记录上次位置
SELECT * FROM orders WHERE id > 10000 ORDER BY id LIMIT 20;

-- 优化2：延迟关联
SELECT o.*
FROM orders o
JOIN (
  SELECT id FROM orders ORDER BY id LIMIT 10000, 20
) t ON o.id = t.id;
```

### 实战案例

**案例1：优化用户订单列表查询**

原始查询（慢）：
```sql
SELECT
  o.*,
  u.username,
  GROUP_CONCAT(oi.product_name) as products
FROM orders o
JOIN users u ON o.user_id = u.id
LEFT JOIN order_items oi ON o.id = oi.order_id
WHERE u.username = 'user100'
GROUP BY o.id
ORDER BY o.created_at DESC
LIMIT 20;
```

优化步骤：
```sql
-- 1. 检查索引
SHOW INDEX FROM users WHERE Column_name = 'username';
SHOW INDEX FROM orders WHERE Column_name = 'user_id';

-- 2. 添加缺失的索引
CREATE INDEX idx_username ON users(username);
CREATE INDEX idx_user_created ON orders(user_id, created_at);

-- 3. 优化查询（先找用户ID）
SELECT
  o.*,
  u.username,
  GROUP_CONCAT(oi.product_name) as products
FROM orders o
JOIN users u ON o.user_id = u.id
LEFT JOIN order_items oi ON o.id = oi.order_id
WHERE o.user_id = (SELECT id FROM users WHERE username = 'user100')
GROUP BY o.id, u.username
ORDER BY o.created_at DESC
LIMIT 20;

-- 4. 或者使用视图缓存
```

**案例2：优化热销商品统计**

思路：
```sql
-- 问题：实时计算太慢
SELECT p.name, SUM(oi.quantity) as sold
FROM products p
JOIN order_items oi ON p.id = oi.product_id
JOIN orders o ON oi.order_id = o.id
WHERE o.status = 3
GROUP BY p.id, p.name
ORDER BY sold DESC
LIMIT 10;

-- 解决方案：创建汇总表，定期更新
CREATE TABLE product_sales_cache (
  product_id BIGINT PRIMARY KEY,
  product_name VARCHAR(200),
  total_sold INT,
  total_revenue DECIMAL(15,2),
  updated_at TIMESTAMP
);

-- 定期更新（通过定时任务）
INSERT INTO product_sales_cache (product_id, product_name, total_sold, total_revenue)
SELECT p.id, p.name, SUM(oi.quantity), SUM(oi.total_amount)
FROM products p
JOIN order_items oi ON p.id = oi.product_id
JOIN orders o ON oi.order_id = o.id
WHERE o.status = 3
GROUP BY p.id, p.name
ON DUPLICATE KEY UPDATE
  total_sold = VALUES(total_sold),
  total_revenue = VALUES(total_revenue),
  updated_at = NOW();

-- 快速查询
SELECT * FROM product_sales_cache
ORDER BY total_sold DESC
LIMIT 10;
```

---

## 第十阶段：综合实战指导

### 项目1：秒杀系统设计

**核心挑战**
- 高并发处理
- 超卖控制
- 系统稳定性

**数据库设计**
```sql
-- 秒杀商品表
CREATE TABLE seckill_products (
  id BIGINT PRIMARY KEY,
  product_id BIGINT NOT NULL,
  seckill_price DECIMAL(10,2) NOT NULL,
  stock_count INT NOT NULL,
  start_time TIMESTAMP NOT NULL,
  end_time TIMESTAMP NOT NULL,
  version INT DEFAULT 0,  -- 乐观锁
  INDEX idx_product (product_id),
  INDEX idx_time (start_time, end_time)
);

-- 秒杀订单表
CREATE TABLE seckill_orders (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  seckill_product_id BIGINT NOT NULL,
  order_no VARCHAR(50) UNIQUE NOT NULL,
  status TINYINT DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE KEY uk_user_product (user_id, seckill_product_id),
  INDEX idx_order_no (order_no)
);
```

**防超卖方案**

方案1：数据库悲观锁
```sql
START TRANSACTION;

SELECT stock_count FROM seckill_products
WHERE id = ? FOR UPDATE;

-- 检查库存
UPDATE seckill_products
SET stock_count = stock_count - 1
WHERE id = ? AND stock_count > 0;

-- 创建订单
INSERT INTO seckill_orders ...;

COMMIT;
```

方案2：数据库乐观锁
```sql
-- 读取库存和版本号
SELECT stock_count, version FROM seckill_products WHERE id = ?;

-- 更新（使用版本号）
UPDATE seckill_products
SET stock_count = stock_count - 1,
    version = version + 1
WHERE id = ? AND version = ? AND stock_count > 0;

-- 检查affected_rows，如果为0则重试
```

方案3：Redis + 数据库
```
1. 库存预热到Redis
2. Redis原子扣减（DECR）
3. 异步写入数据库
4. 使用消息队列削峰
```

### 项目2：用户推荐系统

**推荐逻辑：协同过滤**

```sql
-- 步骤1：找出相似用户（购买过相同商品）
WITH similar_users AS (
  SELECT
    o2.user_id,
    COUNT(DISTINCT oi2.product_id) as common_products
  FROM orders o1
  JOIN order_items oi1 ON o1.id = oi1.order_id
  JOIN order_items oi2 ON oi1.product_id = oi2.product_id
  JOIN orders o2 ON oi2.order_id = o2.id
  WHERE o1.user_id = ?  -- 目标用户
    AND o2.user_id != ?
    AND o1.status = 3
    AND o2.status = 3
  GROUP BY o2.user_id
  HAVING common_products >= 2
  ORDER BY common_products DESC
  LIMIT 100
)

-- 步骤2：推荐这些用户购买的商品
SELECT
  p.id,
  p.name,
  p.price,
  COUNT(DISTINCT o.user_id) as user_count,
  SUM(oi.quantity) as total_sold
FROM similar_users su
JOIN orders o ON su.user_id = o.user_id
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
WHERE p.id NOT IN (
  -- 排除用户已购买的商品
  SELECT product_id FROM order_items
  WHERE order_id IN (
    SELECT id FROM orders WHERE user_id = ? AND status = 3
  )
)
  AND o.status = 3
  AND p.status = 1
GROUP BY p.id, p.name, p.price
ORDER BY user_count DESC, total_sold DESC
LIMIT 20;
```

### 项目3：实时数据大屏

**方案：物化视图 + 定时更新**

```sql
-- 1. 创建汇总表
CREATE TABLE dashboard_stats (
  stat_date DATE PRIMARY KEY,
  order_count INT,
  total_revenue DECIMAL(15,2),
  new_users INT,
  active_users INT,
  avg_order_amount DECIMAL(10,2),
  updated_at TIMESTAMP
);

-- 2. 定时更新（每小时）
INSERT INTO dashboard_stats (
  stat_date, order_count, total_revenue, new_users, active_users, avg_order_amount
)
SELECT
  CURDATE(),
  COUNT(*),
  SUM(pay_amount),
  (SELECT COUNT(*) FROM users WHERE DATE(created_at) = CURDATE()),
  COUNT(DISTINCT user_id),
  AVG(pay_amount)
FROM orders
WHERE DATE(created_at) = CURDATE() AND status >= 1
ON DUPLICATE KEY UPDATE
  order_count = VALUES(order_count),
  total_revenue = VALUES(total_revenue),
  active_users = VALUES(active_users),
  avg_order_amount = VALUES(avg_order_amount),
  updated_at = NOW();

-- 3. 大屏查询（快速）
SELECT * FROM dashboard_stats
WHERE stat_date >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
ORDER BY stat_date DESC;
```

---

## 综合实战建议

### 1. 系统设计原则

- **高可用**：主从复制、读写分离
- **高性能**：缓存、索引、分库分表
- **可扩展**：微服务、消息队列
- **数据安全**：备份、权限控制

### 2. 常见架构模式

```
应用层
  ↓
缓存层（Redis）
  ↓
数据库主库（写）
  ↓
数据库从库（读）- 负载均衡
```

### 3. 性能优化清单

- [ ] 慢查询优化
- [ ] 索引设计合理
- [ ] SQL语句优化
- [ ] 连接池配置
- [ ] 缓存策略
- [ ] 读写分离
- [ ] 分库分表
- [ ] 监控告警

### 4. 学习资源

**推荐实践项目**
1. 实现一个简单的电商系统
2. 设计秒杀系统并压测
3. 构建数据分析平台
4. 优化现有项目的数据库性能

**推荐工具**
- **压测**: sysbench, mysqlslap
- **监控**: Prometheus + Grafana
- **分析**: pt-query-digest
- **可视化**: MySQL Workbench, Navicat

---

## 总结

完成这10个阶段的学习后，你应该具备：

✅ 扎实的SQL基础
✅ 多表查询和复杂分析能力
✅ 索引和性能优化技能
✅ 事务和并发控制理解
✅ 存储过程开发能力
✅ 权限和安全管理
✅ 系统设计和优化思维

**下一步建议：**
1. 参与实际项目
2. 学习分库分表（ShardingSphere）
3. 学习MySQL高可用（MHA, MGR）
4. 学习NoSQL数据库（Redis, MongoDB）
5. 深入研究MySQL源码

继续保持学习，成为数据库专家！🎉
