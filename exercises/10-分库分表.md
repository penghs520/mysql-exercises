# 10 - 分库分表

## 学习目标
- 理解分库分表的概念和应用场景
- 掌握垂直拆分和水平拆分策略
- 学习常见的分片算法和路由规则
- 了解分库分表带来的问题和解决方案
- 实践ShardingSphere等中间件的使用

## 基础知识

### 什么时候需要分库分表？

**分库场景**：
- 单库连接数不够
- 单库磁盘IO瓶颈
- 业务隔离需求

**分表场景**：
- 单表数据量过大（通常>1000万行）
- 单表索引过大，影响查询性能
- 表锁竞争激烈

### 拆分方式

1. **垂直拆分**：按业务模块拆分
   - 垂直分库：不同业务的表放到不同数据库
   - 垂直分表：一个表的列拆分到多个表

2. **水平拆分**：按数据行拆分
   - 水平分库：数据分散到多个数据库
   - 水平分表：数据分散到多个表

## 练习题

### 一、垂直拆分

#### 1. 垂直分库设计
基于study_db的电商数据库，设计垂直分库方案：

**原始数据库**：study_db（所有表在一个库）

**任务**：拆分为以下数据库
- user_db：用户相关（users, user_addresses）
- product_db：商品相关（categories, products, product_skus）
- order_db：订单相关（orders, order_items, payments）
- review_db：评价相关（product_reviews）

编写SQL创建这些数据库，并说明拆分依据。

```sql
-- 创建用户库
CREATE DATABASE user_db DEFAULT CHARACTER SET utf8mb4;

-- 创建商品库
CREATE DATABASE product_db DEFAULT CHARACTER SET utf8mb4;

-- 继续创建其他数据库...
```

#### 2. 垂直分表设计
对users表进行垂直拆分：

**原表字段**：
```sql
users (
    id, username, email, password_hash,
    phone, avatar_url, gender, birth_date,
    registration_ip, last_login_ip, last_login_at,
    is_active, created_at, updated_at
)
```

**任务**：拆分为两个表
- users_basic：基本信息（高频访问）
- users_extra：扩展信息（低频访问）

请设计表结构并说明拆分理由。

### 二、水平分库分表策略

#### 3. 分片键选择
为orders表设计水平分表方案，对比以下分片键：

| 分片键 | 优点 | 缺点 | 适用场景 |
|--------|------|------|----------|
| user_id | ? | ? | ? |
| order_id | ? | ? | ? |
| created_at | ? | ? | ? |

**任务**：
1. 补充表格内容
2. 选择最合适的分片键并说明理由
3. 如果按user_id分片，如何查询订单详情（给定order_id）？

#### 4. 分片算法设计

实现以下分片算法（伪SQL/逻辑描述）：

**方案1：取模分片**
```python
# 假设分4个表：orders_0, orders_1, orders_2, orders_3
def get_table_name(user_id):
    table_index = user_id % 4
    return f"orders_{table_index}"

# 插入订单时
table = get_table_name(user_id)
# INSERT INTO {table} ...
```

**方案2：范围分片**
```python
# 按user_id范围分片
def get_table_name(user_id):
    if user_id <= 250:
        return "orders_0"
    elif user_id <= 500:
        return "orders_1"
    elif user_id <= 750:
        return "orders_2"
    else:
        return "orders_3"
```

**方案3：一致性Hash**
```python
# 使用一致性Hash算法
import hashlib

def get_table_name(user_id):
    hash_value = int(hashlib.md5(str(user_id).encode()).hexdigest(), 16)
    table_index = hash_value % 4
    return f"orders_{table_index}"
```

**任务**：
1. 对比三种算法的优缺点
2. 哪种算法更容易扩容？
3. 如果要从4张表扩展到8张表，如何数据迁移？

### 三、分表实战

#### 5. 创建分表
在study_db中为orders表创建4个分表：

```sql
-- 基于原orders表结构创建分表
CREATE TABLE orders_0 LIKE orders;
CREATE TABLE orders_1 LIKE orders;
CREATE TABLE orders_2 LIKE orders;
CREATE TABLE orders_3 LIKE orders;

-- 或者直接定义结构
CREATE TABLE orders_0 (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    total_amount DECIMAL(10,2),
    status ENUM('pending','paid','shipped','completed','cancelled'),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_user_id (user_id),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB;

-- 创建其他分表...
```

#### 6. 数据迁移
将orders表的数据按user_id % 4迁移到分表：

```sql
-- 迁移到orders_0 (user_id % 4 = 0)
INSERT INTO orders_0
SELECT * FROM orders
WHERE user_id % 4 = 0;

-- 迁移到orders_1
INSERT INTO orders_1
SELECT * FROM orders
WHERE user_id % 4 = 1;

-- 继续其他分表...

-- 验证数据完整性
SELECT COUNT(*) FROM orders;
SELECT
    (SELECT COUNT(*) FROM orders_0) +
    (SELECT COUNT(*) FROM orders_1) +
    (SELECT COUNT(*) FROM orders_2) +
    (SELECT COUNT(*) FROM orders_3) AS total_in_shards;
```

#### 7. 分表查询
实现以下查询需求：

**需求1：查询某用户的所有订单**
```sql
-- 已知user_id，可以直接定位分表
SET @user_id = 123;
SET @table_index = @user_id % 4;

-- 需要应用层根据table_index选择表
SELECT * FROM orders_0 WHERE user_id = 123;  -- 如果user_id % 4 = 0
```

**需求2：查询某个订单详情（只知道order_id）**
```sql
-- 问题：不知道在哪个分表，需要查询所有分表
SELECT * FROM orders_0 WHERE id = 10001
UNION ALL
SELECT * FROM orders_1 WHERE id = 10001
UNION ALL
SELECT * FROM orders_2 WHERE id = 10001
UNION ALL
SELECT * FROM orders_3 WHERE id = 10001;
```

**任务**：如何优化需求2的查询？提示：引入路由表

#### 8. 路由表设计
创建一个轻量级路由表解决跨分片查询问题：

```sql
CREATE TABLE order_route (
    order_id BIGINT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    shard_index TINYINT NOT NULL,
    INDEX idx_user_id (user_id)
) ENGINE=InnoDB;

-- 插入路由信息
INSERT INTO order_route (order_id, user_id, shard_index)
SELECT id, user_id, (user_id % 4) AS shard_index
FROM orders;

-- 查询订单时先查路由表
SELECT shard_index FROM order_route WHERE order_id = 10001;
-- 根据shard_index定位到具体分表
```

### 四、分库分表的问题与解决方案

#### 9. 全局唯一ID生成
分表后auto_increment不再适用，设计全局唯一ID方案：

**方案1：雪花算法（Snowflake）**
```
64位ID = 1位符号位 + 41位时间戳 + 10位机器ID + 12位序列号
```

**方案2：数据库号段模式**
```sql
-- 创建ID生成表
CREATE TABLE id_generator (
    biz_type VARCHAR(50) PRIMARY KEY,
    max_id BIGINT NOT NULL,
    step INT NOT NULL DEFAULT 1000
) ENGINE=InnoDB;

-- 获取ID号段
UPDATE id_generator
SET max_id = max_id + step
WHERE biz_type = 'order'
RETURNING max_id;

-- 应用层使用max_id到max_id+step之间的ID
```

**方案3：UUID**
```sql
-- 使用UUID
SELECT UUID() AS new_id;

-- 或使用有序UUID（MySQL 8.0+）
SELECT UUID_TO_BIN(UUID()) AS new_id;
```

**任务**：对比三种方案的优缺点，选择最适合订单ID的方案

#### 10. 分布式事务处理
**场景**：创建订单需要操作多个分片

```sql
-- 订单表在orders_2（根据user_id）
-- 库存表在product_skus（可能在不同库）

-- 伪代码
BEGIN;
-- 1. 扣减库存（product_db.product_skus）
UPDATE product_skus SET stock = stock - 1 WHERE sku_id = ?;

-- 2. 创建订单（order_db.orders_2）
INSERT INTO orders_2 (...) VALUES (...);

-- 3. 创建订单明细（order_db.order_items_2）
INSERT INTO order_items_2 (...) VALUES (...);
COMMIT;
```

**问题**：跨库事务无法保证ACID

**解决方案**：
1. 两阶段提交（XA事务）
2. 最终一致性（TCC、SAGA）
3. 本地消息表
4. 分布式事务中间件（Seata）

**任务**：选择一种方案，设计订单创建的分布式事务流程

#### 11. 跨分片Join查询
**场景**：查询用户的订单和订单明细

```sql
-- 原来的查询（单表）
SELECT o.*, oi.product_id, oi.quantity
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
WHERE o.user_id = 123;

-- 分表后（orders和order_items都分片）
-- orders_2 JOIN order_items_2 ?
```

**解决方案**：
1. 应用层Join：分别查询再组装
2. 数据冗余：在order_items中冗余user_id
3. 宽表设计：合并表避免Join

**任务**：改写上述查询，实现分表后的等价查询

#### 12. 分页查询优化
**场景**：查询用户的订单，按时间倒序分页

```sql
-- 原查询
SELECT * FROM orders
WHERE user_id = 123
ORDER BY created_at DESC
LIMIT 0, 20;

-- 分表后（数据在orders_3）
SELECT * FROM orders_3
WHERE user_id = 123
ORDER BY created_at DESC
LIMIT 0, 20;

-- 跨分片分页（不知道user_id）
-- 需要查询所有分片
SELECT * FROM (
    SELECT * FROM orders_0 WHERE ... ORDER BY created_at DESC LIMIT 0, 20
    UNION ALL
    SELECT * FROM orders_1 WHERE ... ORDER BY created_at DESC LIMIT 0, 20
    UNION ALL
    SELECT * FROM orders_2 WHERE ... ORDER BY created_at DESC LIMIT 0, 20
    UNION ALL
    SELECT * FROM orders_3 WHERE ... ORDER BY created_at DESC LIMIT 0, 20
) AS all_orders
ORDER BY created_at DESC
LIMIT 0, 20;
```

**任务**：
1. 分析跨分片分页的性能问题
2. 设计优化方案（提示：归并排序）

#### 13. 数据聚合查询
**场景**：统计所有订单的总金额

```sql
-- 原查询
SELECT SUM(total_amount) FROM orders;

-- 分表后
SELECT SUM(total_amount) FROM (
    SELECT total_amount FROM orders_0
    UNION ALL
    SELECT total_amount FROM orders_1
    UNION ALL
    SELECT total_amount FROM orders_2
    UNION ALL
    SELECT total_amount FROM orders_3
) AS all_orders;

-- 优化：在应用层聚合
SELECT SUM(total_amount) FROM orders_0;  -- 100万
SELECT SUM(total_amount) FROM orders_1;  -- 150万
SELECT SUM(total_amount) FROM orders_2;  -- 120万
SELECT SUM(total_amount) FROM orders_3;  -- 130万
-- 应用层相加：100+150+120+130 = 500万
```

### 五、ShardingSphere实践（理论）

#### 14. ShardingSphere-JDBC配置
使用ShardingSphere-JDBC配置分库分表：

```yaml
# application.yml示例
spring:
  shardingsphere:
    datasource:
      names: ds0,ds1
      ds0:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/order_db_0
      ds1:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/order_db_1

    rules:
      sharding:
        tables:
          orders:
            actual-data-nodes: ds$->{0..1}.orders_$->{0..3}
            table-strategy:
              standard:
                sharding-column: user_id
                sharding-algorithm-name: order-table-inline
            database-strategy:
              standard:
                sharding-column: user_id
                sharding-algorithm-name: order-database-inline

        sharding-algorithms:
          order-database-inline:
            type: INLINE
            props:
              algorithm-expression: ds$->{user_id % 2}
          order-table-inline:
            type: INLINE
            props:
              algorithm-expression: orders_$->{user_id % 4}
```

**任务**：
1. 解释这个配置的分片规则
2. 计算user_id=123的订单会落到哪个库哪个表
3. 如何配置全局ID生成器

#### 15. 读写分离配置
结合分库分表和读写分离：

```yaml
spring:
  shardingsphere:
    rules:
      readwrite-splitting:
        data-sources:
          ds0:
            write-data-source-name: ds0-master
            read-data-source-names: ds0-slave-0,ds0-slave-1
            load-balancer-name: round-robin
          ds1:
            write-data-source-name: ds1-master
            read-data-source-names: ds1-slave-0,ds1-slave-1
            load-balancer-name: round-robin
```

**任务**：设计一个2库4表，每库1主2从的架构

### 六、扩容与缩容

#### 16. 分表扩容
**场景**：从4张表扩展到8张表

**问题**：
- user_id=100，原来在orders_0（100%4=0）
- 扩容后应该在orders_4（100%8=4）
- 需要数据迁移

**双倍扩容方案**（推荐）：
```sql
-- 步骤1：创建新表orders_4~7
CREATE TABLE orders_4 LIKE orders_0;
-- ...

-- 步骤2：迁移数据（取模从4变成8）
-- orders_0中user_id%8=4的数据迁移到orders_4
INSERT INTO orders_4
SELECT * FROM orders_0
WHERE user_id % 8 = 4;

DELETE FROM orders_0 WHERE user_id % 8 = 4;

-- 继续迁移其他表...
```

**一致性Hash方案**：
- 数据迁移量更少
- 实现更复杂

**任务**：计算双倍扩容需要迁移的数据比例

#### 17. 平滑扩容策略
设计一个不停服的扩容方案：

1. **双写阶段**：新数据同时写入新旧分片
2. **迁移阶段**：后台迁移历史数据
3. **校验阶段**：数据一致性校验
4. **切换阶段**：切换读流量到新分片
5. **清理阶段**：删除旧分片冗余数据

**任务**：详细设计每个阶段的操作步骤

### 七、监控与运维

#### 18. 分片数据监控
设计监控指标：

```sql
-- 各分片数据量
SELECT 'orders_0' AS shard, COUNT(*) AS cnt FROM orders_0
UNION ALL
SELECT 'orders_1', COUNT(*) FROM orders_1
UNION ALL
SELECT 'orders_2', COUNT(*) FROM orders_2
UNION ALL
SELECT 'orders_3', COUNT(*) FROM orders_3;

-- 各分片写入QPS（通过慢查询日志分析）
-- 各分片磁盘使用率
```

**任务**：
1. 如何发现数据倾斜？
2. 数据倾斜如何处理？

#### 19. 故障处理
**场景1**：某个分片宕机

**场景2**：数据迁移过程中出错

**场景3**：分片键选择不当，需要重新分片

**任务**：为每个场景设计应急预案

### 八、综合实战

#### 20. 设计一个完整的分库分表方案

**业务背景**：
- 订单表1亿+数据
- 用户表5000万+数据
- 每日新增订单100万+
- QPS峰值10000+

**任务**：
1. 设计分库分表方案（几个库几个表）
2. 选择分片键和分片算法
3. 解决全局ID、分布式事务、跨分片查询问题
4. 设计扩容方案
5. 制定监控和运维策略

画出架构图（可以用文字描述）：
```
用户层
  ↓
应用层（ShardingSphere-Proxy）
  ↓
数据层（8个库，每库4个分片表）
  order_db_0: orders_0~3, order_items_0~3
  order_db_1: orders_0~3, order_items_0~3
  ...
  order_db_7: orders_0~3, order_items_0~3
```

## 拓展思考

1. **分库分表 vs NewSQL**：为什么不用TiDB、CockroachDB等分布式数据库？

2. **分片策略演进**：从单表 -> 分表 -> 分库分表 -> 微服务独立数据库

3. **中间件选型**：
   - ShardingSphere（Client端）
   - Mycat（Proxy端）
   - Vitess（云原生）

4. **异地多活**：如何在分库分表基础上实现异地多活？

5. **CQRS模式**：命令查询职责分离在分库分表中的应用

## 练习提示

- 分库分表是复杂度很高的架构，务必先评估必要性
- 优先考虑垂直拆分，再考虑水平拆分
- 分片键选择至关重要，一旦确定很难修改
- 建议在测试环境完整演练扩容流程
- 考虑使用中间件简化开发复杂度

## 参考资料

- ShardingSphere官方文档
- 《分布式数据库架构及企业实践》
- Mycat权威指南
- 美团、阿里等公司的分库分表实践文章
- 数据库Sharding设计模式
