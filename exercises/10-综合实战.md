# 第十阶段：综合实战练习

## 练习说明
- 综合运用所学知识
- 解决实际业务场景
- 注重代码质量和性能

---

## 1. 电商核心功能实现

### 1.1 完整下单流程
```sql
-- 实现一个完整的下单存储过程
-- 输入：用户ID、商品列表(商品ID、数量)、收货地址ID
-- 输出：订单ID、成功/失败消息

DELIMITER $$

CREATE PROCEDURE CreateOrder(
  IN p_user_id BIGINT,
  IN p_product_list JSON,  -- [{"product_id": 1, "quantity": 2}, ...]
  IN p_address_id BIGINT,
  OUT p_order_id BIGINT,
  OUT p_success BOOLEAN,
  OUT p_message VARCHAR(200)
)
BEGIN
  DECLARE v_total_amount DECIMAL(10,2) DEFAULT 0;
  DECLARE v_product_id BIGINT;
  DECLARE v_quantity INT;
  DECLARE v_price DECIMAL(10,2);
  DECLARE v_stock INT;
  DECLARE v_product_name VARCHAR(200);
  DECLARE i INT DEFAULT 0;
  DECLARE v_count INT;

  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    ROLLBACK;
    SET p_success = FALSE;
    SET p_message = '订单创建失败，已回滚';
  END;

  START TRANSACTION;

  -- 1. 验证用户
  IF NOT EXISTS(SELECT 1 FROM users WHERE id = p_user_id AND status = 1) THEN
    SET p_success = FALSE;
    SET p_message = '用户不存在或已禁用';
    ROLLBACK;
    LEAVE proc_label;
  END IF;

  -- 2. 验证地址
  IF NOT EXISTS(SELECT 1 FROM user_addresses WHERE id = p_address_id AND user_id = p_user_id) THEN
    SET p_success = FALSE;
    SET p_message = '收货地址不存在';
    ROLLBACK;
    LEAVE proc_label;
  END IF;

  -- 3. 创建订单
  -- （省略具体实现，需要自己完成）

  COMMIT;
  SET p_success = TRUE;
  SET p_message = '订单创建成功';

  proc_label: BEGIN END;
END$$

DELIMITER ;

-- 测试
-- CALL CreateOrder(1, '[{"product_id":1,"quantity":2}]', 1, @order_id, @success, @msg);
-- SELECT @order_id, @success, @msg;

DROP PROCEDURE IF EXISTS CreateOrder;
```

### 1.2 库存管理系统
```sql
-- 实现库存扣减、释放、预占功能
-- 要求：
-- 1. 支持并发安全
-- 2. 支持超卖保护
-- 3. 记录库存变动日志

-- 创建库存日志表
CREATE TABLE IF NOT EXISTS stock_logs (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  product_id BIGINT NOT NULL,
  quantity INT NOT NULL,
  type ENUM('deduct', 'release', 'reserve') NOT NULL,
  order_id BIGINT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  INDEX idx_product (product_id),
  INDEX idx_order (order_id)
);

-- 实现库存扣减
-- （自己实现）

-- 清理
DROP TABLE IF EXISTS stock_logs;
```

### 1.3 订单状态流转
```sql
-- 实现订单状态机
-- 0(待支付) -> 1(已支付) -> 2(已发货) -> 3(已完成)
--     |
--     +-> 4(已取消)

-- 要求：
-- 1. 验证状态转换的合法性
-- 2. 记录状态变更时间
-- 3. 触发相关业务逻辑（如支付成功后扣库存）

-- 创建状态变更存储过程
-- （自己实现）
```

---

## 2. 数据分析报表

### 2.1 销售日报
```sql
-- 生成每日销售报表
-- 要求：
-- 1. 订单数、销售额、客单价
-- 2. 新用户数、复购用户数
-- 3. 热销商品TOP10
-- 4. 销售额按分类分布

-- 提示：使用窗口函数、CTE等
-- （自己实现）
```

### 2.2 用户RFM分析
```sql
-- RFM模型分析用户价值
-- R (Recency): 最近购买时间
-- F (Frequency): 购买频次
-- M (Monetary): 购买金额

WITH user_rfm AS (
  SELECT
    user_id,
    DATEDIFF(NOW(), MAX(created_at)) as recency,
    COUNT(*) as frequency,
    SUM(pay_amount) as monetary
  FROM orders
  WHERE status = 3
  GROUP BY user_id
),
rfm_score AS (
  SELECT
    user_id,
    recency,
    frequency,
    monetary,
    -- R分数：越近越好，分数越高
    CASE
      WHEN recency <= 30 THEN 5
      WHEN recency <= 60 THEN 4
      WHEN recency <= 90 THEN 3
      WHEN recency <= 180 THEN 2
      ELSE 1
    END as r_score,
    -- F分数：次数越多越好
    NTILE(5) OVER(ORDER BY frequency) as f_score,
    -- M分数：金额越高越好
    NTILE(5) OVER(ORDER BY monetary) as m_score
  FROM user_rfm
)
SELECT
  user_id,
  recency,
  frequency,
  monetary,
  r_score,
  f_score,
  m_score,
  CONCAT(r_score, f_score, m_score) as rfm_score,
  -- 用户分群
  CASE
    WHEN r_score >= 4 AND f_score >= 4 AND m_score >= 4 THEN '重要价值客户'
    WHEN r_score >= 4 AND f_score >= 4 THEN '重要保持客户'
    WHEN r_score <= 2 AND f_score >= 4 THEN '重要挽留客户'
    WHEN r_score >= 4 AND m_score >= 4 THEN '重要发展客户'
    WHEN r_score <= 2 AND f_score <= 2 AND m_score <= 2 THEN '潜在客户'
    ELSE '一般客户'
  END as user_segment
FROM rfm_score
ORDER BY r_score DESC, f_score DESC, m_score DESC
LIMIT 100;
```

### 2.3 商品关联分析
```sql
-- 找出经常一起购买的商品组合（购物篮分析）

WITH product_pairs AS (
  SELECT
    a.product_id as product_a,
    b.product_id as product_b,
    a.order_id
  FROM order_items a
  JOIN order_items b ON a.order_id = b.order_id AND a.product_id < b.product_id
)
SELECT
  pa.name as product_a_name,
  pb.name as product_b_name,
  COUNT(*) as together_count,
  -- 支持度：一起购买的订单数 / 总订单数
  COUNT(*) * 100.0 / (SELECT COUNT(DISTINCT order_id) FROM orders) as support_pct
FROM product_pairs pp
JOIN products pa ON pp.product_a = pa.id
JOIN products pb ON pp.product_b = pb.id
GROUP BY pp.product_a, pp.product_b, pa.name, pb.name
HAVING together_count >= 5
ORDER BY together_count DESC
LIMIT 20;
```

---

## 3. 性能优化实战

### 3.1 优化热销商品查询
```sql
-- 场景：首页展示热销商品，并发量高

-- 方案1：实时计算（慢）
SELECT
  p.id,
  p.name,
  p.price,
  p.main_image,
  COUNT(oi.id) as order_count,
  SUM(oi.quantity) as total_sold
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
WHERE p.status = 1
GROUP BY p.id, p.name, p.price, p.main_image
ORDER BY total_sold DESC
LIMIT 10;

-- 方案2：创建物化视图（快）
-- 1. 创建汇总表
CREATE TABLE hot_products (
  product_id BIGINT PRIMARY KEY,
  name VARCHAR(200),
  price DECIMAL(10,2),
  main_image VARCHAR(255),
  total_sold INT,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  INDEX idx_sold (total_sold)
);

-- 2. 定期更新（通过定时任务或触发器）
INSERT INTO hot_products (product_id, name, price, main_image, total_sold)
SELECT
  p.id,
  p.name,
  p.price,
  p.main_image,
  IFNULL(SUM(oi.quantity), 0)
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
WHERE p.status = 1
GROUP BY p.id, p.name, p.price, p.main_image
ON DUPLICATE KEY UPDATE
  name = VALUES(name),
  price = VALUES(price),
  total_sold = VALUES(total_sold);

-- 3. 快速查询
SELECT * FROM hot_products ORDER BY total_sold DESC LIMIT 10;

DROP TABLE IF EXISTS hot_products;
```

### 3.2 优化订单列表查询
```sql
-- 场景：用户查看自己的订单列表，支持分页

-- 创建视图简化查询
CREATE VIEW v_user_orders AS
SELECT
  o.id,
  o.order_no,
  o.user_id,
  o.total_amount,
  o.status,
  CASE o.status
    WHEN 0 THEN '待支付'
    WHEN 1 THEN '已支付'
    WHEN 2 THEN '已发货'
    WHEN 3 THEN '已完成'
    WHEN 4 THEN '已取消'
  END as status_name,
  o.created_at,
  GROUP_CONCAT(
    CONCAT(oi.product_name, 'x', oi.quantity)
    SEPARATOR '; '
  ) as items_summary
FROM orders o
LEFT JOIN order_items oi ON o.id = oi.order_id
GROUP BY o.id, o.order_no, o.user_id, o.total_amount, o.status, o.created_at;

-- 使用视图查询
SELECT * FROM v_user_orders
WHERE user_id = 100
ORDER BY created_at DESC
LIMIT 0, 20;

-- 清理
DROP VIEW IF EXISTS v_user_orders;
```

---

## 4. 数据一致性保障

### 4.1 实现分布式锁
```sql
-- 使用数据库实现简单的分布式锁

-- 创建锁表
CREATE TABLE distributed_locks (
  lock_key VARCHAR(100) PRIMARY KEY,
  owner VARCHAR(100) NOT NULL,
  expire_time TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  INDEX idx_expire (expire_time)
);

-- 获取锁
DELIMITER $$

CREATE PROCEDURE AcquireLock(
  IN p_lock_key VARCHAR(100),
  IN p_owner VARCHAR(100),
  IN p_timeout INT,  -- 秒
  OUT p_success BOOLEAN
)
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SET p_success = FALSE;
  END;

  -- 清理过期锁
  DELETE FROM distributed_locks
  WHERE lock_key = p_lock_key AND expire_time < NOW();

  -- 尝试获取锁
  INSERT INTO distributed_locks (lock_key, owner, expire_time)
  VALUES (p_lock_key, p_owner, DATE_ADD(NOW(), INTERVAL p_timeout SECOND));

  SET p_success = TRUE;
END$$

DELIMITER ;

-- 释放锁
DELIMITER $$

CREATE PROCEDURE ReleaseLock(
  IN p_lock_key VARCHAR(100),
  IN p_owner VARCHAR(100),
  OUT p_success BOOLEAN
)
BEGIN
  DELETE FROM distributed_locks
  WHERE lock_key = p_lock_key AND owner = p_owner;

  SET p_success = ROW_COUNT() > 0;
END$$

DELIMITER ;

-- 测试
-- CALL AcquireLock('order:123', 'instance-1', 30, @success);
-- SELECT @success;
-- CALL ReleaseLock('order:123', 'instance-1', @success);
-- SELECT @success;

-- 清理
DROP PROCEDURE IF EXISTS AcquireLock;
DROP PROCEDURE IF EXISTS ReleaseLock;
DROP TABLE IF EXISTS distributed_locks;
```

### 4.2 实现幂等性
```sql
-- 订单支付幂等性处理

-- 支付请求去重表
CREATE TABLE payment_requests (
  request_id VARCHAR(100) PRIMARY KEY,
  order_id BIGINT NOT NULL,
  amount DECIMAL(10,2) NOT NULL,
  status TINYINT DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  processed_at TIMESTAMP NULL,
  INDEX idx_order (order_id)
);

-- 幂等支付处理
DELIMITER $$

CREATE PROCEDURE ProcessPayment(
  IN p_request_id VARCHAR(100),
  IN p_order_id BIGINT,
  IN p_amount DECIMAL(10,2),
  OUT p_success BOOLEAN,
  OUT p_message VARCHAR(200)
)
BEGIN
  DECLARE v_existing_status TINYINT;

  -- 检查是否已处理
  SELECT status INTO v_existing_status
  FROM payment_requests
  WHERE request_id = p_request_id;

  IF v_existing_status IS NOT NULL THEN
    -- 已处理过
    IF v_existing_status = 1 THEN
      SET p_success = TRUE;
      SET p_message = '支付已完成';
    ELSE
      SET p_success = FALSE;
      SET p_message = '支付处理中';
    END IF;
    LEAVE proc_label;
  END IF;

  -- 记录请求
  INSERT INTO payment_requests (request_id, order_id, amount, status)
  VALUES (p_request_id, p_order_id, p_amount, 0);

  -- 处理支付逻辑
  START TRANSACTION;

  -- 更新订单状态
  UPDATE orders SET status = 1, payment_time = NOW()
  WHERE id = p_order_id AND status = 0;

  -- 记录支付成功
  UPDATE payment_requests
  SET status = 1, processed_at = NOW()
  WHERE request_id = p_request_id;

  COMMIT;

  SET p_success = TRUE;
  SET p_message = '支付成功';

  proc_label: BEGIN END;
END$$

DELIMITER ;

-- 清理
DROP PROCEDURE IF EXISTS ProcessPayment;
DROP TABLE IF EXISTS payment_requests;
```

---

## 5. 数据清理与维护

### 5.1 归档历史数据
```sql
-- 将一年前的订单归档到历史表

-- 创建归档表
CREATE TABLE orders_archive LIKE orders;

-- 归档数据
INSERT INTO orders_archive
SELECT * FROM orders
WHERE created_at < DATE_SUB(NOW(), INTERVAL 1 YEAR);

-- 删除已归档数据（谨慎操作）
-- DELETE FROM orders
-- WHERE created_at < DATE_SUB(NOW(), INTERVAL 1 YEAR);

-- 清理
DROP TABLE IF EXISTS orders_archive;
```

### 5.2 数据清理任务
```sql
-- 清理过期的购物车数据
-- 定期执行（如每天凌晨）

DELETE FROM cart_items
WHERE updated_at < DATE_SUB(NOW(), INTERVAL 30 DAY)
LIMIT 1000;  -- 分批删除，避免锁表

-- 清理测试数据
DELETE FROM orders WHERE order_no LIKE 'TEST%';
```

---

## 6. 监控和诊断

### 6.1 慢查询监控
```sql
-- 查看慢查询统计
SELECT
  DIGEST_TEXT as query_pattern,
  COUNT_STAR as exec_count,
  AVG_TIMER_WAIT / 1000000000000 as avg_time_sec,
  MAX_TIMER_WAIT / 1000000000000 as max_time_sec,
  SUM_ROWS_EXAMINED as total_rows_examined,
  SUM_ROWS_SENT as total_rows_sent
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME = 'study_db'
ORDER BY AVG_TIMER_WAIT DESC
LIMIT 20;
```

### 6.2 锁等待监控
```sql
-- MySQL 8.0+: 查看当前锁等待情况
SELECT
  waiting_trx.trx_id as waiting_trx_id,
  waiting_trx.trx_mysql_thread_id as waiting_thread,
  waiting_trx.trx_query as waiting_query,
  waiting_trx.trx_state as waiting_state,
  blocking_trx.trx_id as blocking_trx_id,
  blocking_trx.trx_mysql_thread_id as blocking_thread,
  blocking_trx.trx_query as blocking_query,
  blocking_trx.trx_state as blocking_state,
  wait.requesting_engine_lock_id,
  wait.blocking_engine_lock_id
FROM performance_schema.data_lock_waits wait
JOIN information_schema.innodb_trx waiting_trx
  ON wait.requesting_engine_transaction_id = waiting_trx.trx_id
JOIN information_schema.innodb_trx blocking_trx
  ON wait.blocking_engine_transaction_id = blocking_trx.trx_id;

-- 或者查看锁详情
SELECT
  lock_waits.requesting_thread_id,
  lock_waits.blocking_thread_id,
  locks_waiting.object_schema,
  locks_waiting.object_name,
  locks_waiting.lock_type,
  locks_waiting.lock_mode,
  locks_blocking.lock_mode as blocking_lock_mode
FROM performance_schema.data_lock_waits lock_waits
JOIN performance_schema.data_locks locks_waiting
  ON lock_waits.requesting_engine_lock_id = locks_waiting.engine_lock_id
JOIN performance_schema.data_locks locks_blocking
  ON lock_waits.blocking_engine_lock_id = locks_blocking.engine_lock_id;
```

---

## 7. 综合项目

### 7.1 设计一个优惠券系统
```sql
-- 要求：
-- 1. 支持不同类型的优惠券（满减、折扣、免邮）
-- 2. 支持限量、限时、限用户
-- 3. 防止重复领取和使用
-- 4. 高并发下的一致性

-- 优惠券表
CREATE TABLE coupons (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  type ENUM('amount', 'discount', 'shipping') NOT NULL,
  value DECIMAL(10,2) NOT NULL,
  min_amount DECIMAL(10,2) DEFAULT 0,
  total_count INT,
  remain_count INT,
  per_user_limit INT DEFAULT 1,
  start_time TIMESTAMP,
  end_time TIMESTAMP,
  status TINYINT DEFAULT 1,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 用户优惠券表
CREATE TABLE user_coupons (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  user_id BIGINT NOT NULL,
  coupon_id BIGINT NOT NULL,
  order_id BIGINT,
  status TINYINT DEFAULT 0,  -- 0:未使用, 1:已使用, 2:已过期
  received_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  used_at TIMESTAMP NULL,
  INDEX idx_user (user_id),
  INDEX idx_coupon (coupon_id),
  UNIQUE KEY uk_user_coupon (user_id, coupon_id)
);

-- 实现领取优惠券的存储过程
-- （自己实现，要考虑并发安全）

-- 清理
DROP TABLE IF EXISTS user_coupons;
DROP TABLE IF EXISTS coupons;
```

### 7.2 实现一个简单的推荐系统
```sql
-- 基于用户行为的协同过滤推荐
-- 推荐逻辑：
-- 1. 找出与当前用户购买过相似商品的其他用户
-- 2. 推荐这些用户购买过但当前用户未购买的商品

WITH
-- 当前用户购买的商品
user_products AS (
  SELECT DISTINCT product_id
  FROM orders o
  JOIN order_items oi ON o.id = oi.order_id
  WHERE o.user_id = 1 AND o.status = 3
),
-- 购买过相同商品的其他用户
similar_users AS (
  SELECT o.user_id, COUNT(DISTINCT oi.product_id) as common_count
  FROM orders o
  JOIN order_items oi ON o.id = oi.order_id
  WHERE oi.product_id IN (SELECT product_id FROM user_products)
    AND o.user_id != 1
    AND o.status = 3
  GROUP BY o.user_id
  HAVING common_count >= 2
  ORDER BY common_count DESC
  LIMIT 100
),
-- 这些用户购买的商品
candidate_products AS (
  SELECT oi.product_id, COUNT(DISTINCT o.user_id) as user_count
  FROM orders o
  JOIN order_items oi ON o.id = oi.order_id
  WHERE o.user_id IN (SELECT user_id FROM similar_users)
    AND oi.product_id NOT IN (SELECT product_id FROM user_products)
    AND o.status = 3
  GROUP BY oi.product_id
)
-- 推荐商品
SELECT
  p.id,
  p.name,
  p.price,
  c.user_count as recommend_score
FROM candidate_products c
JOIN products p ON c.product_id = p.id
WHERE p.status = 1
ORDER BY recommend_score DESC
LIMIT 20;
```

---

## 8. 最终挑战

### 8.1 设计秒杀系统
```sql
-- 要求：
-- 1. 高并发处理（万级QPS）
-- 2. 超卖保护
-- 3. 防刷机制
-- 4. 公平性保证

-- 思考：
-- 1. 如何设计数据表？
-- 2. 如何防止超卖？
-- 3. 如何提高性能？
-- 4. 如何限流？
-- 5. 如何处理热点数据？

-- 提示：
-- - 使用Redis缓存
-- - 消息队列削峰
-- - 数据库乐观锁/悲观锁
-- - 分库分表
```

### 8.2 构建实时数据大屏
```sql
-- 实时展示：
-- 1. 今日订单数、销售额
-- 2. 实时订单流水
-- 3. 热销商品TOP10
-- 4. 用户地域分布
-- 5. 支付方式占比

-- 思考：
-- 1. 如何保证实时性？
-- 2. 如何优化查询性能？
-- 3. 如何减少数据库压力？

-- 提示：
-- - 使用物化视图
-- - 增量更新
-- - 缓存热点数据
```

---

## 学习检查点

完成所有练习后，你应该能够：
- [ ] 设计和实现完整的业务功能
- [ ] 编写复杂的数据分析SQL
- [ ] 优化系统性能瓶颈
- [ ] 保障数据一致性
- [ ] 处理高并发场景
- [ ] 设计数据归档方案
- [ ] 监控和诊断数据库问题
- [ ] 独立完成中小型项目的数据库设计和优化

**恭喜你完成了MySQL学习计划！**

继续保持学习和实践，不断提升数据库技能。

建议下一步：
1. 学习MySQL主从复制和高可用
2. 学习分库分表方案
3. 学习NoSQL数据库
4. 参与实际项目实战
