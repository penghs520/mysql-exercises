# 第二阶段：多表连接练习

## 练习说明
- 理解表之间的关系是多表查询的基础
- 注意区分不同类型的 JOIN
- 观察连接条件对结果的影响

---

## 表关系说明

```
users (用户表)
  ├─ orders (订单表) - user_id
  ├─ cart_items (购物车) - user_id
  ├─ user_addresses (地址) - user_id
  └─ product_reviews (评价) - user_id

products (商品表)
  ├─ product_skus (SKU) - product_id
  ├─ order_items (订单明细) - product_id
  ├─ cart_items (购物车) - product_id
  └─ product_reviews (评价) - product_id
  └─ categories (分类) - category_id

orders (订单表)
  ├─ order_items (订单明细) - order_id
  ├─ payments (支付记录) - order_id
  └─ product_reviews (评价) - order_id
```

---

## 1. INNER JOIN 内连接

### 1.1 两表连接
```sql
-- 查询所有订单及对应的用户信息
-- 显示：订单号、用户名、订单金额、订单状态
-- 使用 INNER JOIN

-- inner join 可以省略为 join
select o.order_no, u.username
from orders o
inner join users u
on o.user_id = u.id
limit 10; 
```

⏺ MySQL连接类型区别：

  1. INNER JOIN（内连接）
    - 只返回两表匹配的记录
    - 最常用
  2. LEFT JOIN（左连接）
    - 返回左表所有记录 + 右表匹配的记录
    - 右表无匹配时显示NULL
  3. RIGHT JOIN（右连接）
    - 返回右表所有记录 + 左表匹配的记录
    - 左表无匹配时显示NULL
  4. CROSS JOIN（交叉连接）
    - 笛卡尔积，返回所有可能组合
    - 无ON条件

### 1.2 查看订单详情
```sql
-- 查询订单明细及对应的商品信息
-- 显示：订单ID、商品名称、商品单价、购买数量、小计金额
-- 只查询前50条


SELECT
      oi.order_id,
      p.name AS product_name,
      oi.price,
      oi.quantity,
      oi.total_amount
  FROM order_items oi
  INNER JOIN products p ON oi.product_id = p.id
  LIMIT 50;

```

### 1.3 三表连接
```sql
-- 查询订单、用户、支付信息
-- 显示：订单号、用户名、订单金额、支付方式、支付时间
-- 只查询已支付的订单

select o.order_no, u.username, pay.payment_method, pay.paid_at 
from orders o
inner join users u on o.user_id = u.id
inner join payments pay on o.id = pay.order_id
where o.status = 1;

```

### 1.4 四表连接
```sql
-- 查询完整的订单购买信息
-- 关联：orders, users, order_items, products
-- 显示：用户名、订单号、商品名称、购买数量、订单创建时间
-- 按创建时间降序，限制前30条

select u.username 用户名, o.order_no 订单号, p.name 商品名称, oi.quantity 购买数量, o.created_at 订单创建时间 from orders o
inner join users u on o.user_id = u.id
inner join order_items oi on o.id = oi.order_id
inner join products p on oi.product_id = p.id
order by o.created_at desc
limit 30;

+-----------+---------------------+-----------------------+--------------+---------------------+
| 用户名    | 订单号              | 商品名称              | 购买数量     | 订单创建时间        |
+-----------+---------------------+-----------------------+--------------+---------------------+
| user224   | ORD2025100400019735 | 商品404 - 特惠款      |            1 | 2025-10-04 07:35:01 |
| user224   | ORD2025100400019735 | 商品237 - 新品        |            2 | 2025-10-04 07:35:01 |
| user224   | ORD2025100400019735 | 商品363 - 经典款      |            2 | 2025-10-04 07:35:01 |
| user224   | ORD2025100400019735 | 商品321 - 限量版      |            1 | 2025-10-04 07:35:01 |
| user224   | ORD2025100400019735 | 商品386 - 特惠款      |            3 | 2025-10-04 07:35:01 |
| user224   | ORD2025100400019735 | 商品356 - 特惠款      |            2 | 2025-10-04 07:35:01 |
| user304   | ORD2025100400019436 | 商品211 - 新品        |            1 | 2025-10-04 07:35:01 |
| user187   | ORD2025100400019124 | 商品99 - 热销款       |            1 | 2025-10-04 07:35:01 |
| user890   | ORD2025100400018828 | 商品475 - 热销款      |            3 | 2025-10-04 07:35:01 |
| user890   | ORD2025100400018828 | 商品7 - 热销款        |            1 | 2025-10-04 07:35:01 |
| user890   | ORD2025100400018828 | 商品494 - 热销款      |            1 | 2025-10-04 07:35:01 |
| user606   | ORD2025100400018761 | 商品324 - 特惠款      |            2 | 2025-10-04 07:35:01 |
| user606   | ORD2025100400018761 | 商品480 - 特惠款      |            3 | 2025-10-04 07:35:01 |
| user606   | ORD2025100400018761 | 商品208 - 经典款      |            1 | 2025-10-04 07:35:01 |
| user606   | ORD2025100400018761 | 商品143 - 限量版      |            2 | 2025-10-04 07:35:01 |

```


---

## 2. LEFT JOIN 左外连接

### 2.1 查询所有用户及其订单
```sql
-- 查询所有用户，包括没有下过订单的用户
-- 显示：用户名、邮箱、订单数量
-- 提示：需要用到 COUNT 和 GROUP BY

select u.username ,u.email,count(o.id) from users u 
left join orders o on o.user_id = u.id
group by u.id;
```

### 2.2 查询未支付的订单
```sql
-- 查询所有订单及支付信息
-- 包括还未支付的订单（payments表中没有记录）
-- 显示：订单号、订单金额、支付流水号、支付状态
-- 支付流水号为NULL的表示未支付

select o.order_no, o.pay_amount, pay.payment_no,pay.status 
from orders o 
left join payments pay on o.id = pay.order_id
limit 10;
```

### 2.3 找出没有购买记录的用户
```sql
-- 查询从未下过订单的用户
-- 使用 LEFT JOIN 和 WHERE order_id IS NULL
-- 显示：用户ID、用户名、注册时间

select u.id, u.username,u.created_at
from users u
left join orders o on o.user_id = u.id
where o.id is null ;

```

### 2.4 商品销售情况
```sql
-- 查询所有商品及其销售数量
-- 包括从未被购买过的商品（销售数量为0）
-- 显示：商品名称、销售总数量
-- 提示：LEFT JOIN order_items

select p.id,p.name, oi.quantity
from products p
left join order_items oi
on oi.product_id = p.id
where oi.id is null;
```

---

## 3. RIGHT JOIN 右外连接

### 3.1 练习 RIGHT JOIN
```sql
-- 将上面 1.1 的查询改写为 RIGHT JOIN
-- 从订单表出发，右连接用户表
-- 结果应该相同


-- 查询所有订单及对应的用户信息
-- 显示：订单号、用户名、订单金额、订单状态
-- 使用 INNER JOIN

select o.order_no, u.username
from orders o
inner join users u
on o.user_id = u.id
limit 10; 


select o.order_no, u.username
from orders o
right join users u
on o.user_id = u.id
limit 10; 

```

### 3.2 对比 LEFT 和 RIGHT
```sql
-- 分别使用 LEFT JOIN 和 RIGHT JOIN
-- 查询用户和订单的关系
-- 观察结果差异


select o.order_no, u.username
from orders o
left join users u 
on o.user_id = u.id

select o.order_no, u.username
from orders o
right join users u 
on o.user_id = u.id


```

---

## 4. 自连接

### 4.1 分类层级查询
```sql
-- 查询商品分类及其父分类名称
-- categories 表自关联
-- 显示：分类ID、分类名称、父分类名称
-- 提示：自连接需要使用表别名
```

### 4.2 查找同价商品
```sql
-- 查找相同价格的不同商品
-- products 表自连接
-- 显示：商品1名称、商品2名称、价格
-- 条件：p1.id < p2.id (避免重复)
-- 限制前20条
```

---

## 5. 多表连接综合

### 5.1 用户购买明细
```sql
-- 查询用户的详细购买记录
-- 关联：users, orders, order_items, products
-- 显示：用户名、订单号、商品名称、购买数量、小计、订单状态
-- 按用户ID分组，订单时间降序
-- 限制前100条
```

### 5.2 商品评价详情
```sql
-- 查询商品的评价信息
-- 关联：products, product_reviews, users, orders
-- 显示：商品名称、用户名、评分、评价内容、订单号、评价时间
-- 只显示评分>=4的评价
-- 按评价时间降序，限制前50条
```

### 5.3 热门商品排行
```sql
-- 统计商品的销售情况
-- 关联：products, order_items, categories
-- 显示：商品名称、分类名称、销售总数量、销售总金额
-- 按销售总金额降序
-- 显示前20名
```

### 5.4 用户消费统计
```sql
-- 统计每个用户的消费情况
-- 关联：users, orders
-- 显示：用户名、订单总数、消费总金额、平均订单金额
-- 只统计已完成的订单(status=3)
-- 按消费总金额降序
-- 限制前50名
```

---

## 6. 连接条件优化

### 6.1 使用 USING
```sql
-- 当连接字段名相同时，使用 USING 简化
-- 查询订单和订单明细
-- 对比：ON order_items.order_id = orders.id
--      USING (order_id) -- 需要字段名一致
```

### 6.2 多条件连接
```sql
-- 查询特定价格区间的商品和订单
-- 连接条件包含价格范围
-- orders JOIN order_items JOIN products
-- 额外条件：products.price > 100

-- 错误答案
-- 不要用left join
select o.order_no, p.name, p.price
from orders o
left join order_items oi on o.id = oi.order_id
left join products p on oi.product_id = p.id
where p.price > 100 and o.status = 3;


-- 错误答案：把 p.price > 100 放在on里面，但这里如果是left join的话是错误的
select o.order_no, p.name, p.price
from orders o
left join order_items oi on o.id = oi.order_id
left join products p on oi.product_id = p.id and  p.price > 100
where o.status = 3;


-- 正确答案  和答案1执行计划一样，但看起来更优雅一点
-- inner join 省略为 join
select o.order_no, p.name, p.price
from orders o
join order_items oi on o.id = oi.order_id
join products p on oi.product_id = p.id and  p.price > 100
where o.status = 3;

```

---

## 7. 子查询与连接

### 7.1 用子查询替代连接
```sql
-- 查询购买过商品ID=100的用户
-- 方法1：使用 JOIN
-- 方法2：使用子查询
-- 对比两种方法的可读性


-- 使用 join
-- 要加distinct
select distinct u.username
from users u
join orders o on o.user_id = u.id
join order_items oi on o.id = oi.order_id 
join products p on oi.product_id = p.id and p.id = 100


-- 执行计划
mysql> explain select distinct u.username
    -> from users u
    -> join orders o on o.user_id = u.id
    -> join order_items oi on o.id = oi.order_id 
    -> join products p on oi.product_id = p.id and p.id = 100;
+----+-------------+-------+------------+--------+-----------------------------+----------------+---------+----------------------+------+----------+------------------------------+
| id | select_type | table | partitions | type   | possible_keys               | key            | key_len | ref                  | rows | filtered | Extra                        |
+----+-------------+-------+------------+--------+-----------------------------+----------------+---------+----------------------+------+----------+------------------------------+
|  1 | SIMPLE      | p     | NULL       | const  | PRIMARY                     | PRIMARY        | 8       | const                |    1 |   100.00 | Using index; Using temporary |
|  1 | SIMPLE      | oi    | NULL       | ref    | idx_order_id,idx_product_id | idx_product_id | 8       | const                |   96 |   100.00 | NULL                         |
|  1 | SIMPLE      | o     | NULL       | eq_ref | PRIMARY,idx_user_id         | PRIMARY        | 8       | study_db.oi.order_id |    1 |   100.00 | NULL                         |
|  1 | SIMPLE      | u     | NULL       | eq_ref | PRIMARY,uk_username         | PRIMARY        | 8       | study_db.o.user_id   |    1 |   100.00 | NULL                         |
+----+-------------+-------+------------+--------+-----------------------------+----------------+---------+----------------------+------+----------+------------------------------+

-- 使用子查询
select username
from users 
where id in (
  select user_id from orders where id in (
    select order_id from order_items where product_id = 100 
  )
)

-- 查询计划
mysql> explain select username
    -> from users 
    -> where id in (
    ->   select user_id from orders where id in (
    ->     select order_id from order_items where product_id = 100 
    ->   )
    -> );
+----+--------------+-------------+------------+--------+-----------------------------+----------------+---------+-------------------------------+------+----------+-------+
| id | select_type  | table       | partitions | type   | possible_keys               | key            | key_len | ref                           | rows | filtered | Extra |
+----+--------------+-------------+------------+--------+-----------------------------+----------------+---------+-------------------------------+------+----------+-------+
|  1 | SIMPLE       | <subquery2> | NULL       | ALL    | NULL                        | NULL           | NULL    | NULL                          | NULL |   100.00 | NULL  |
|  1 | SIMPLE       | users       | NULL       | eq_ref | PRIMARY                     | PRIMARY        | 8       | <subquery2>.user_id           |    1 |   100.00 | NULL  |
|  2 | MATERIALIZED | order_items | NULL       | ref    | idx_order_id,idx_product_id | idx_product_id | 8       | const                         |   96 |   100.00 | NULL  |
|  2 | MATERIALIZED | orders      | NULL       | eq_ref | PRIMARY,idx_user_id         | PRIMARY        | 8       | study_db.order_items.order_id |    1 |   100.00 | NULL  |
+----+--------------+-------------+------------+--------+-----------------------------+----------------+---------+-------------------------------+------+----------+-------+
4 rows in set, 1 warning (0.00 sec)


-- 对比：JOIN通常性能更好，但子查询更易读

```

### 7.2 连接替代子查询
```sql
-- 查询订单金额大于用户平均订单金额的订单
-- 尝试使用 JOIN 实现

-- 方案1：子查询
-- 这个结果不对，不是要所有订单的平均金额，而是用户自己的平均订单金额
select * from orders 
where pay_amount > (
  select avg(pay_amount) from orders
)


-- 子查询2
-- 结果正确：但性能最差
--   - DEPENDENT SUBQUERY - 相关子查询
--   - 每一行都要执行一次子查询（19,816次）
--   - 时间复杂度：O(n²)
 SELECT o1.order_no,
  o1.user_id,
  o1.pay_amount
  FROM orders o1
  WHERE o1.pay_amount > (
    SELECT AVG(o2.pay_amount)
    FROM orders o2
    WHERE o2.user_id = o1.user_id  -- 关联外层查询
  );

-- 执行计划
mysql> explain  SELECT o1.order_no,
    ->   o1.user_id,
    ->   o1.pay_amount
    ->   FROM orders o1
    ->   WHERE o1.pay_amount > (
    ->     SELECT AVG(o2.pay_amount)
    ->     FROM orders o2
    ->     WHERE o2.user_id = o1.user_id  -- 关联外层查询
    ->   );
+----+--------------------+-------+------------+------+---------------+-------------+---------+---------------------+-------+----------+-------------+
| id | select_type        | table | partitions | type | possible_keys | key         | key_len | ref                 | rows  | filtered | Extra       |
+----+--------------------+-------+------------+------+---------------+-------------+---------+---------------------+-------+----------+-------------+
|  1 | PRIMARY            | o1    | NULL       | ALL  | NULL          | NULL        | NULL    | NULL                | 19816 |   100.00 | Using where |
|  2 | DEPENDENT SUBQUERY | o2    | NULL       | ref  | idx_user_id   | idx_user_id | 8       | study_db.o1.user_id |    19 |   100.00 | NULL        |
+----+--------------------+-------+------------+------+---------------+-------------+---------+---------------------+-------+----------+-------------+
2 rows in set, 2 warnings (0.00 sec)



-- 方案2：左连接
-- 性能最优
 SELECT o1.order_no, o1.user_id, o1.pay_amount,
         ROUND(avg_orders.avg_amount, 2) as user_avg_amount
  FROM orders o1
  JOIN (
    SELECT user_id, AVG(pay_amount) as avg_amount
    FROM orders
    GROUP BY user_id
  ) avg_orders ON o1.user_id = avg_orders.user_id
  WHERE o1.pay_amount > avg_orders.avg_amount
  ORDER BY o1.user_id, o1.pay_amount DESC;

-- 查询计划
mysql> explain  SELECT o1.order_no, o1.user_id, o1.pay_amount,
    ->          ROUND(avg_orders.avg_amount, 2) as user_avg_amount
    ->   FROM orders o1
    ->   JOIN (
    ->     SELECT user_id, AVG(pay_amount) as avg_amount
    ->     FROM orders
    ->     GROUP BY user_id
    ->   ) avg_orders ON o1.user_id = avg_orders.user_id
    ->   WHERE o1.pay_amount > avg_orders.avg_amount
    ->   ORDER BY o1.user_id, o1.pay_amount DESC;
+----+-------------+------------+------------+-------+---------------+-------------+---------+--------------------+-------+----------+---------------------------------+
| id | select_type | table      | partitions | type  | possible_keys | key         | key_len | ref                | rows  | filtered | Extra                           |
+----+-------------+------------+------------+-------+---------------+-------------+---------+--------------------+-------+----------+---------------------------------+
|  1 | PRIMARY     | <derived2> | NULL       | ALL   | NULL          | NULL        | NULL    | NULL               | 19816 |   100.00 | Using temporary; Using filesort |
|  1 | PRIMARY     | o1         | NULL       | ref   | idx_user_id   | idx_user_id | 8       | avg_orders.user_id |    19 |    33.33 | Using where                     |
|  2 | DERIVED     | orders     | NULL       | index | idx_user_id   | idx_user_id | 8       | NULL               | 19816 |   100.00 | NULL                            |
+----+-------------+------------+------------+-------+---------------+-------------+---------+--------------------+-------+----------+---------------------------------+
3 rows in set, 1 warning (0.00 sec)

-- 方案3：窗口函数
-- 性能中等，最优雅
-- DERIVED + Using filesort
 SELECT order_no, user_id, pay_amount,
         ROUND(user_avg_amount, 2) as user_avg_amount
  FROM (
    SELECT o.*,
           AVG(pay_amount) OVER (PARTITION BY user_id) as user_avg_amount
    FROM orders o
  ) t
  WHERE pay_amount > user_avg_amount
  ORDER BY user_id, pay_amount DESC;

-- 窗口函数介绍
窗口函数（Window Functions）是在一组相关的行上执行计算的函数，但不会将这些行合并成单个输出行（不像GROUP BY）
核心特点：
- 保留原始行的同时添加计算结果
- 使用 OVER() 子句定义窗口范围
- 可以配合 PARTITION BY（分组）和 ORDER BY（排序）

常用窗口函数：

1. 排名函数
  - ROW_NUMBER() - 连续行号
  - RANK() - 排名（有并列，跳号）
  - DENSE_RANK() - 密集排名（有并列，不跳号）
2. 聚合函数
  - SUM(), AVG(), COUNT(), MAX(), MIN()
3. 取值函数
  - LAG() - 前一行的值
  - LEAD() - 后一行的值
  - FIRST_VALUE(), LAST_VALUE()

```

---

## 8. CROSS JOIN 交叉连接

### 8.1 笛卡尔积
```sql
-- 生成商品和颜色的组合
-- 查询前5个商品
-- 与一个包含 ['红', '黑', '白', '蓝', '灰'] 的临时表交叉连接
-- 提示：可以用 UNION 创建临时数据

SELECT
  p.id,
  p.name,
  colors.color
FROM (
  SELECT id, name FROM products WHERE status = 1 LIMIT 5
) p
CROSS JOIN (
  SELECT '红色' as color
  UNION SELECT '黑色'
  UNION SELECT '白色'
  UNION SELECT '蓝色'
  UNION SELECT '灰色'
) colors
ORDER BY p.id, colors.color;

-- 结果：5个商品 × 5个颜色 = 25条记录


交叉连接（CROSS JOIN）返回两个表的笛卡尔积，即第一个表的每一行与第二个表的每一行进行组合。

  特点：
  - 不需要连接条件
  - 结果行数 = 表A行数 × 表B行数
  - 实际业务中较少使用


  语法：
  -- 显式语法
  SELECT * FROM table1 CROSS JOIN table2;

  -- 隐式语法（逗号连接）
  SELECT * FROM table1, table2;


```

---

## 9. 综合实战

### 9.1 订单完整信息查询
```sql
-- 查询订单的完整信息，包括：
-- - 订单基本信息（订单号、金额、状态）
-- - 买家信息（用户名、手机）
-- - 收货地址
-- - 订单商品明细
-- - 支付信息
-- 查询订单号为 'ORD20250101000001' 的订单
-- （可以先查看数据库中实际存在的订单号）
```

### 9.2 商品销售分析
```sql
-- 分析每个分类下商品的销售情况
-- 关联：categories, products, order_items, orders
-- 统计：分类名称、商品数量、总销售量、总销售额
-- 只统计已完成订单
-- 按总销售额降序

SELECT
  c1.name as category_name,
  COUNT(DISTINCT p.id) as product_count,
  SUM(oi.quantity) as total_quantity,
  SUM(oi.total_amount) as total_revenue,
  AVG(oi.price) as avg_price
FROM categories c1
JOIN categories c2 ON c2.parent_id = c1.id  -- c2是二级分类
JOIN products p ON c2.id = p.category_id
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.id AND o.status = 3
WHERE c1.level = 1  -- 只看一级分类
GROUP BY c1.id, c1.name
HAVING total_revenue > 0
ORDER BY total_revenue DESC;
```

### 9.3 用户行为分析
```sql
-- 分析用户的购物行为
-- 关联：users, orders, cart_items, product_reviews
-- 显示：用户名、订单总数、购物车商品数、评价总数、注册时间
-- 只显示有过购买行为的用户
-- 按订单总数降序，限制前100名
```

### 9.4 复购率分析
```sql
-- 查询购买过多次的用户
-- 关联：users, orders
-- 显示：用户ID、用户名、购买次数、首次购买时间、最后购买时间
-- 条件：购买次数 >= 3
-- 按购买次数降序
```

---

## 10. 性能思考

### 10.1 观察执行计划
```sql
-- 使用 EXPLAIN 分析以下查询：
EXPLAIN
SELECT u.username, COUNT(o.id) as order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id;

-- 观察：
-- - type 列（连接类型）
-- - key 列（使用的索引）
-- - rows 列（扫描行数）
```

### 10.2 比较不同写法
```sql
-- 查询购买过商品的用户
-- 方法1：INNER JOIN
-- 方法2：WHERE IN (子查询)
-- 方法3：WHERE EXISTS (子查询)
-- 使用 EXPLAIN 比较性能
```

---

## 学习检查点

完成所有练习后，你应该能够：
- [ ] 理解 INNER JOIN 和 OUTER JOIN 的区别
- [ ] 熟练编写多表连接查询
- [ ] 掌握自连接的使用场景
- [ ] 理解连接条件对结果的影响
- [ ] 能够分析表关系并设计查询
- [ ] 了解何时使用连接，何时使用子查询

**下一步**: 完成后查看 `solutions/02-多表连接.md` 对照答案，然后进入第三阶段学习。
