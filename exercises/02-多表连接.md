# 第二阶段：多表连接练习

## 练习说明
- 理解表之间的关系是多表查询的基础
- 注意区分不同类型的 JOIN
- 观察连接条件对结果的影响

---

## 表关系说明

```
users (用户表)
  ├─ orders (订单表) - user_id
  ├─ cart_items (购物车) - user_id
  ├─ user_addresses (地址) - user_id
  └─ product_reviews (评价) - user_id

products (商品表)
  ├─ product_skus (SKU) - product_id
  ├─ order_items (订单明细) - product_id
  ├─ cart_items (购物车) - product_id
  └─ product_reviews (评价) - product_id
  └─ categories (分类) - category_id

orders (订单表)
  ├─ order_items (订单明细) - order_id
  ├─ payments (支付记录) - order_id
  └─ product_reviews (评价) - order_id
```

---

## 1. INNER JOIN 内连接

### 1.1 两表连接
```sql
-- 查询所有订单及对应的用户信息
-- 显示：订单号、用户名、订单金额、订单状态
-- 使用 INNER JOIN

select o.order_no, u.username
from orders o
inner join users u
on o.user_id = u.id
limit 10; 
```

⏺ MySQL连接类型区别：

  1. INNER JOIN（内连接）
    - 只返回两表匹配的记录
    - 最常用
  2. LEFT JOIN（左连接）
    - 返回左表所有记录 + 右表匹配的记录
    - 右表无匹配时显示NULL
  3. RIGHT JOIN（右连接）
    - 返回右表所有记录 + 左表匹配的记录
    - 左表无匹配时显示NULL
  4. CROSS JOIN（交叉连接）
    - 笛卡尔积，返回所有可能组合
    - 无ON条件

### 1.2 查看订单详情
```sql
-- 查询订单明细及对应的商品信息
-- 显示：订单ID、商品名称、商品单价、购买数量、小计金额
-- 只查询前50条


SELECT
      oi.order_id,
      p.name AS product_name,
      oi.price,
      oi.quantity,
      oi.total_amount
  FROM order_items oi
  INNER JOIN products p ON oi.product_id = p.id
  LIMIT 50;

```

### 1.3 三表连接
```sql
-- 查询订单、用户、支付信息
-- 显示：订单号、用户名、订单金额、支付方式、支付时间
-- 只查询已支付的订单

select o.order_no, u.username, pay.payment_method, pay.paid_at 
from orders o
inner join users u on o.user_id = u.id
inner join payments pay on o.id = pay.order_id
where o.status = 1;

```

### 1.4 四表连接
```sql
-- 查询完整的订单购买信息
-- 关联：orders, users, order_items, products
-- 显示：用户名、订单号、商品名称、购买数量、订单创建时间
-- 按创建时间降序，限制前30条

select u.username 用户名, o.order_no 订单号, p.name 商品名称, oi.quantity 购买数量, o.created_at 订单创建时间 from orders o
inner join users u on o.user_id = u.id
inner join order_items oi on o.id = oi.order_id
inner join products p on oi.product_id = p.id
order by o.created_at desc
limit 30;

+-----------+---------------------+-----------------------+--------------+---------------------+
| 用户名    | 订单号              | 商品名称              | 购买数量     | 订单创建时间        |
+-----------+---------------------+-----------------------+--------------+---------------------+
| user224   | ORD2025100400019735 | 商品404 - 特惠款      |            1 | 2025-10-04 07:35:01 |
| user224   | ORD2025100400019735 | 商品237 - 新品        |            2 | 2025-10-04 07:35:01 |
| user224   | ORD2025100400019735 | 商品363 - 经典款      |            2 | 2025-10-04 07:35:01 |
| user224   | ORD2025100400019735 | 商品321 - 限量版      |            1 | 2025-10-04 07:35:01 |
| user224   | ORD2025100400019735 | 商品386 - 特惠款      |            3 | 2025-10-04 07:35:01 |
| user224   | ORD2025100400019735 | 商品356 - 特惠款      |            2 | 2025-10-04 07:35:01 |
| user304   | ORD2025100400019436 | 商品211 - 新品        |            1 | 2025-10-04 07:35:01 |
| user187   | ORD2025100400019124 | 商品99 - 热销款       |            1 | 2025-10-04 07:35:01 |
| user890   | ORD2025100400018828 | 商品475 - 热销款      |            3 | 2025-10-04 07:35:01 |
| user890   | ORD2025100400018828 | 商品7 - 热销款        |            1 | 2025-10-04 07:35:01 |
| user890   | ORD2025100400018828 | 商品494 - 热销款      |            1 | 2025-10-04 07:35:01 |
| user606   | ORD2025100400018761 | 商品324 - 特惠款      |            2 | 2025-10-04 07:35:01 |
| user606   | ORD2025100400018761 | 商品480 - 特惠款      |            3 | 2025-10-04 07:35:01 |
| user606   | ORD2025100400018761 | 商品208 - 经典款      |            1 | 2025-10-04 07:35:01 |
| user606   | ORD2025100400018761 | 商品143 - 限量版      |            2 | 2025-10-04 07:35:01 |

```


---

## 2. LEFT JOIN 左外连接

### 2.1 查询所有用户及其订单
```sql
-- 查询所有用户，包括没有下过订单的用户
-- 显示：用户名、邮箱、订单数量
-- 提示：需要用到 COUNT 和 GROUP BY

select u.username ,u.email,count(o.id) from users u 
left join orders o on o.user_id = u.id
group by u.id;
```

### 2.2 查询未支付的订单
```sql
-- 查询所有订单及支付信息
-- 包括还未支付的订单（payments表中没有记录）
-- 显示：订单号、订单金额、支付流水号、支付状态
-- 支付流水号为NULL的表示未支付

select o.order_no, o.pay_amount, pay.payment_no,pay.status 
from orders o 
left join payments pay on o.id = pay.order_id
limit 10;
```

### 2.3 找出没有购买记录的用户
```sql
-- 查询从未下过订单的用户
-- 使用 LEFT JOIN 和 WHERE order_id IS NULL
-- 显示：用户ID、用户名、注册时间

select u.id, u.username,u.created_at
from users u
left join orders o on o.user_id = u.id
where o.id is null ;

```

### 2.4 商品销售情况
```sql
-- 查询所有商品及其销售数量
-- 包括从未被购买过的商品（销售数量为0）
-- 显示：商品名称、销售总数量
-- 提示：LEFT JOIN order_items

select p.id,p.name, oi.quantity
from products p
left join order_items oi
on oi.product_id = p.id
where oi.id is null;
```

---

## 3. RIGHT JOIN 右外连接

### 3.1 练习 RIGHT JOIN
```sql
-- 将上面 1.1 的查询改写为 RIGHT JOIN
-- 从订单表出发，右连接用户表
-- 结果应该相同


-- 查询所有订单及对应的用户信息
-- 显示：订单号、用户名、订单金额、订单状态
-- 使用 INNER JOIN

select o.order_no, u.username
from orders o
inner join users u
on o.user_id = u.id
limit 10; 


select o.order_no, u.username
from orders o
right join users u
on o.user_id = u.id
limit 10; 

```

### 3.2 对比 LEFT 和 RIGHT
```sql
-- 分别使用 LEFT JOIN 和 RIGHT JOIN
-- 查询用户和订单的关系
-- 观察结果差异


select o.order_no, u.username
from orders o
left join users u 
on o.user_id = u.id

select o.order_no, u.username
from orders o
right join users u 
on o.user_id = u.id


```

---

## 4. 自连接

### 4.1 分类层级查询
```sql
-- 查询商品分类及其父分类名称
-- categories 表自关联
-- 显示：分类ID、分类名称、父分类名称
-- 提示：自连接需要使用表别名
```

### 4.2 查找同价商品
```sql
-- 查找相同价格的不同商品
-- products 表自连接
-- 显示：商品1名称、商品2名称、价格
-- 条件：p1.id < p2.id (避免重复)
-- 限制前20条
```

---

## 5. 多表连接综合

### 5.1 用户购买明细
```sql
-- 查询用户的详细购买记录
-- 关联：users, orders, order_items, products
-- 显示：用户名、订单号、商品名称、购买数量、小计、订单状态
-- 按用户ID分组，订单时间降序
-- 限制前100条
```

### 5.2 商品评价详情
```sql
-- 查询商品的评价信息
-- 关联：products, product_reviews, users, orders
-- 显示：商品名称、用户名、评分、评价内容、订单号、评价时间
-- 只显示评分>=4的评价
-- 按评价时间降序，限制前50条
```

### 5.3 热门商品排行
```sql
-- 统计商品的销售情况
-- 关联：products, order_items, categories
-- 显示：商品名称、分类名称、销售总数量、销售总金额
-- 按销售总金额降序
-- 显示前20名
```

### 5.4 用户消费统计
```sql
-- 统计每个用户的消费情况
-- 关联：users, orders
-- 显示：用户名、订单总数、消费总金额、平均订单金额
-- 只统计已完成的订单(status=3)
-- 按消费总金额降序
-- 限制前50名
```

---

## 6. 连接条件优化

### 6.1 使用 USING
```sql
-- 当连接字段名相同时，使用 USING 简化
-- 查询订单和订单明细
-- 对比：ON order_items.order_id = orders.id
--      USING (order_id) -- 需要字段名一致
```

### 6.2 多条件连接
```sql
-- 查询特定价格区间的商品和订单
-- 连接条件包含价格范围
-- orders JOIN order_items JOIN products
-- 额外条件：products.price > 100
```

---

## 7. 子查询与连接

### 7.1 用子查询替代连接
```sql
-- 查询购买过商品ID=100的用户
-- 方法1：使用 JOIN
-- 方法2：使用子查询
-- 对比两种方法的可读性
```

### 7.2 连接替代子查询
```sql
-- 查询订单金额大于用户平均订单金额的订单
-- 尝试使用 JOIN 实现
```

---

## 8. CROSS JOIN 交叉连接

### 8.1 笛卡尔积
```sql
-- 生成商品和颜色的组合
-- 查询前5个商品
-- 与一个包含 ['红', '黑', '白', '蓝', '灰'] 的临时表交叉连接
-- 提示：可以用 UNION 创建临时数据
```

---

## 9. 综合实战

### 9.1 订单完整信息查询
```sql
-- 查询订单的完整信息，包括：
-- - 订单基本信息（订单号、金额、状态）
-- - 买家信息（用户名、手机）
-- - 收货地址
-- - 订单商品明细
-- - 支付信息
-- 查询订单号为 'ORD20250101000001' 的订单
-- （可以先查看数据库中实际存在的订单号）
```

### 9.2 商品销售分析
```sql
-- 分析每个分类下商品的销售情况
-- 关联：categories, products, order_items, orders
-- 统计：分类名称、商品数量、总销售量、总销售额
-- 只统计已完成订单
-- 按总销售额降序
```

### 9.3 用户行为分析
```sql
-- 分析用户的购物行为
-- 关联：users, orders, cart_items, product_reviews
-- 显示：用户名、订单总数、购物车商品数、评价总数、注册时间
-- 只显示有过购买行为的用户
-- 按订单总数降序，限制前100名
```

### 9.4 复购率分析
```sql
-- 查询购买过多次的用户
-- 关联：users, orders
-- 显示：用户ID、用户名、购买次数、首次购买时间、最后购买时间
-- 条件：购买次数 >= 3
-- 按购买次数降序
```

---

## 10. 性能思考

### 10.1 观察执行计划
```sql
-- 使用 EXPLAIN 分析以下查询：
EXPLAIN
SELECT u.username, COUNT(o.id) as order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id;

-- 观察：
-- - type 列（连接类型）
-- - key 列（使用的索引）
-- - rows 列（扫描行数）
```

### 10.2 比较不同写法
```sql
-- 查询购买过商品的用户
-- 方法1：INNER JOIN
-- 方法2：WHERE IN (子查询)
-- 方法3：WHERE EXISTS (子查询)
-- 使用 EXPLAIN 比较性能
```

---

## 学习检查点

完成所有练习后，你应该能够：
- [ ] 理解 INNER JOIN 和 OUTER JOIN 的区别
- [ ] 熟练编写多表连接查询
- [ ] 掌握自连接的使用场景
- [ ] 理解连接条件对结果的影响
- [ ] 能够分析表关系并设计查询
- [ ] 了解何时使用连接，何时使用子查询

**下一步**: 完成后查看 `solutions/02-多表连接.md` 对照答案，然后进入第三阶段学习。
