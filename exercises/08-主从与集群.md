# 08 - MySQL主从复制与集群

## 学习目标
- 理解MySQL主从复制原理和配置
- 掌握主从同步延迟排查和优化
- 了解MySQL集群架构和高可用方案
- 实践读写分离和故障切换

## 基础知识

### 主从复制原理
```
主库 -> binlog -> I/O Thread -> relay log -> SQL Thread -> 从库
```

### 复制模式
1. **异步复制**（默认）：主库不等从库确认
2. **半同步复制**：至少一个从库确认
3. **GTID复制**：全局事务ID，简化故障恢复

## 练习题

### 一、主从复制配置（理论）

#### 1. 主库配置
请描述配置MySQL主库需要的关键参数：
```ini
[mysqld]
# 补充必要的配置参数
server-id = ?
log-bin = ?
binlog-format = ?
```

**提示**：考虑server-id、binlog、binlog格式等参数

#### 2. 从库配置
请描述从库需要的关键配置：
```sql
-- 配置从库连接主库
CHANGE MASTER TO
  MASTER_HOST = ?,
  MASTER_USER = ?,
  MASTER_PASSWORD = ?,
  MASTER_LOG_FILE = ?,
  MASTER_LOG_POS = ?;
```

### 二、主从状态监控

#### 3. 查看主库状态
编写SQL查看主库binlog状态：
```sql
-- 查看主库状态
SHOW MASTER STATUS;
```

**任务**：解释结果中各字段的含义（File、Position、Binlog_Do_DB等）

#### 4. 查看从库状态
```sql
-- 查看从库状态
SHOW SLAVE STATUS\G
```

**任务**：重点关注以下字段并解释：
- Slave_IO_Running
- Slave_SQL_Running
- Seconds_Behind_Master
- Last_IO_Error
- Last_SQL_Error

#### 5. 检测同步延迟
编写查询检测主从延迟：
```sql
-- 方法1：查看Seconds_Behind_Master
SHOW SLAVE STATUS\G

-- 方法2：通过心跳表检测
-- 在主库创建心跳表
CREATE TABLE heartbeat (
    id INT PRIMARY KEY AUTO_INCREMENT,
    ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 定期更新心跳（主库）
UPDATE heartbeat SET ts = NOW() WHERE id = 1;

-- 在从库查询延迟
SELECT TIMESTAMPDIFF(SECOND, ts, NOW()) AS delay_seconds
FROM heartbeat WHERE id = 1;
```

### 三、主从同步问题处理

#### 6. 处理同步中断
当主从同步中断时（Slave_SQL_Running: No），如何处理？

```sql
-- 场景1：跳过错误（仅限测试环境）
SET GLOBAL sql_slave_skip_counter = 1;
START SLAVE;

-- 场景2：基于GTID跳过
SET GTID_NEXT = 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx:N';
BEGIN; COMMIT;
SET GTID_NEXT = 'AUTOMATIC';
START SLAVE;
```

**任务**：
1. 什么情况下可以跳过错误？
2. 生产环境的最佳实践是什么？

#### 7. 处理主键冲突
从库报错：`Duplicate entry '1234' for key 'PRIMARY'`

```sql
-- 分析冲突数据
SELECT * FROM 表名 WHERE id = 1234;

-- 处理方案（请补充具体SQL）
-- 方案1：删除从库冲突数据后重新同步
-- 方案2：修改从库数据
-- 方案3：重新搭建从库
```

### 四、GTID复制

#### 8. 启用GTID
配置基于GTID的主从复制：

```ini
# 主库和从库都需要配置
[mysqld]
gtid-mode = ON
enforce-gtid-consistency = ON
```

```sql
-- 从库配置
CHANGE MASTER TO
  MASTER_HOST = '主库IP',
  MASTER_USER = 'repl_user',
  MASTER_PASSWORD = 'password',
  MASTER_AUTO_POSITION = 1;  -- 使用GTID自动定位
```

#### 9. GTID状态查询
```sql
-- 查看已执行的GTID
SHOW GLOBAL VARIABLES LIKE 'gtid_executed';

-- 查看GTID purged（已清理的）
SHOW GLOBAL VARIABLES LIKE 'gtid_purged';

-- 查看复制状态
SELECT * FROM performance_schema.replication_connection_status\G
```

### 五、读写分离场景

#### 10. 设计读写分离架构
假设有以下架构：
- 1个主库（写）
- 2个从库（读）
- 应用通过中间件路由

**任务**：
1. 设计订单查询场景的SQL路由策略
2. 如何处理"写后立即读"的一致性问题？
3. 从库故障时的降级方案

```sql
-- 示例：订单状态查询
-- 场景1：查询自己刚创建的订单（强一致性要求）
SELECT * FROM orders WHERE user_id = ? AND order_id = ?;
-- 应该路由到：主库 / 从库？

-- 场景2：查询历史订单列表（弱一致性）
SELECT * FROM orders WHERE user_id = ? ORDER BY created_at DESC LIMIT 20;
-- 应该路由到：主库 / 从库？
```

### 六、延迟复制（Delayed Replication）

#### 11. 配置延迟从库
用于数据恢复和防止误操作：

```sql
-- 配置延迟30分钟的从库
CHANGE MASTER TO MASTER_DELAY = 1800;

-- 查看延迟配置
SHOW SLAVE STATUS\G
-- 关注字段：SQL_Delay, SQL_Remaining_Delay
```

**任务**：
1. 什么场景需要延迟复制？
2. 如何利用延迟从库恢复误删除的数据？

### 七、半同步复制

#### 12. 启用半同步复制
```sql
-- 主库安装半同步插件
INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';
SET GLOBAL rpl_semi_sync_master_enabled = 1;
SET GLOBAL rpl_semi_sync_master_timeout = 1000; -- 1秒

-- 从库安装半同步插件
INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';
SET GLOBAL rpl_semi_sync_slave_enabled = 1;

-- 查看半同步状态
SHOW STATUS LIKE 'Rpl_semi_sync%';
```

**任务**：解释以下状态变量的含义
- Rpl_semi_sync_master_clients
- Rpl_semi_sync_master_status
- Rpl_semi_sync_master_yes_tx
- Rpl_semi_sync_master_no_tx

### 八、高可用架构

#### 13. MHA故障切换（理论）
描述MHA（Master High Availability）故障切换流程：

1. 监测主库故障
2. 选择新主库的条件
3. 数据补偿（差异日志）
4. 切换步骤
5. 应用层如何感知切换

#### 14. MGR集群（MySQL Group Replication）
```sql
-- 查看MGR集群状态
SELECT * FROM performance_schema.replication_group_members;

-- 查看MGR配置
SHOW VARIABLES LIKE 'group_replication%';
```

**任务**：
1. MGR单主模式和多主模式的区别
2. MGR如何保证数据一致性
3. 如何处理MGR脑裂问题

### 九、复制过滤

#### 15. 配置复制过滤规则
```ini
# 从库配置文件
[mysqld]
# 只复制特定数据库
replicate-do-db = db1
replicate-do-db = db2

# 忽略特定数据库
replicate-ignore-db = test

# 只复制特定表
replicate-do-table = db1.orders
replicate-wild-do-table = db1.order_%

# 忽略特定表
replicate-ignore-table = db1.logs
```

**任务**：
1. 使用复制过滤的风险是什么？
2. 为什么不推荐在生产环境使用表级过滤？

### 十、综合实战

#### 16. 主从切换演练
设计一个主从切换的完整流程：

**场景**：主库故障，需要将slave1提升为新主库

```sql
-- 步骤1：在slave1上停止复制
STOP SLAVE;

-- 步骤2：确认slave1数据完整性
SHOW SLAVE STATUS\G
-- 确认：Seconds_Behind_Master = 0

-- 步骤3：将slave1设置为可写
SET GLOBAL read_only = 0;
SET GLOBAL super_read_only = 0;

-- 步骤4：配置其他从库指向新主库
-- (在slave2上执行)
STOP SLAVE;
CHANGE MASTER TO
  MASTER_HOST = 'slave1_ip',
  MASTER_LOG_FILE = 'binlog文件名',
  MASTER_LOG_POS = 位置;
START SLAVE;

-- 步骤5：应用层切换数据源
-- (应用配置更新)
```

#### 17. 监控告警设计
设计主从复制的监控指标和告警阈值：

| 指标 | 告警阈值 | 处理方案 |
|------|----------|----------|
| 同步延迟 | >10秒 | 检查网络、慢SQL、大事务 |
| IO线程状态 | Stopped | 检查网络连接、主库状态 |
| SQL线程状态 | Stopped | 查看错误日志、数据冲突 |
| 半同步降级 | 主库降为异步 | 检查从库状态、网络 |

#### 18. 数据一致性校验
使用pt-table-checksum校验主从数据一致性：

```bash
# 安装percona-toolkit
# 执行校验
pt-table-checksum \
  --host=主库IP \
  --user=checksum_user \
  --password=password \
  --databases=study_db \
  --replicate=percona.checksums

# 查看不一致的表
SELECT db, tbl, chunk, this_cnt, master_cnt
FROM percona.checksums
WHERE master_cnt <> this_cnt OR master_crc <> this_crc;
```

**任务**：
1. 发现数据不一致后如何修复？
2. 如何避免校验时对业务的影响？

## 拓展思考

1. **多层级复制**：主库 -> 从库1 -> 从库2，这种架构的优缺点？

2. **跨机房复制**：如何优化跨地域的主从复制性能？

3. **异构复制**：MySQL -> MySQL（其他版本）or MySQL -> PostgreSQL，有哪些方案？

4. **binlog格式选择**：
   - STATEMENT：优点、缺点、适用场景
   - ROW：优点、缺点、适用场景
   - MIXED：优点、缺点、适用场景

5. **双主复制**：互为主从的架构，如何避免循环复制和数据冲突？

## 练习提示

- 大部分练习需要在Docker环境中搭建主从架构
- 可以通过docker-compose快速搭建1主2从环境
- 建议先在测试环境充分练习，理解原理后再应用于生产
- 重点关注监控和故障处理，主从复制的稳定性很重要

## 参考资料

- MySQL官方文档：Replication
- 《高性能MySQL》第10章：复制
- Percona工具集文档
- MHA、MGR、Orchestrator等高可用方案文档
