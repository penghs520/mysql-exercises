# 第六阶段：事务处理练习

## 练习说明
- 理解事务的ACID特性
- 掌握不同隔离级别
- 学会处理并发问题

---

## 1. 事务基础

### 1.1 基本事务操作
```sql
-- 开始事务
START TRANSACTION;

-- 插入订单
INSERT INTO orders (order_no, user_id, total_amount, pay_amount, freight, status, receiver_name, receiver_phone, receiver_address, created_at)
VALUES ('TEST001', 1, 100.00, 100.00, 0, 0, '测试用户', '13800138000', '测试地址', NOW());

-- 获取订单ID
SET @order_id = LAST_INSERT_ID();

-- 插入订单明细
INSERT INTO order_items (order_id, product_id, product_name, price, quantity, total_amount)
VALUES (@order_id, 1, '测试商品', 100.00, 1, 100.00);

-- 提交事务
COMMIT;

-- 验证
SELECT * FROM orders WHERE order_no = 'TEST001';
SELECT * FROM order_items WHERE order_id = @order_id;

-- 清理测试数据
DELETE FROM order_items WHERE order_id = @order_id;
DELETE FROM orders WHERE order_no = 'TEST001';
```

### 1.2 事务回滚
```sql
-- 开始事务
START TRANSACTION;

-- 更新商品库存
UPDATE products SET stock = stock - 10 WHERE id = 1;

-- 查看当前值（事务内可见）
SELECT stock FROM products WHERE id = 1;

-- 回滚
ROLLBACK;

-- 再次查看（应该恢复原值）
SELECT stock FROM products WHERE id = 1;
```

### 1.3 自动提交
```sql
-- 查看自动提交状态
SELECT @@autocommit;

-- 关闭自动提交
SET autocommit = 0;

-- 执行更新
UPDATE products SET stock = stock - 1 WHERE id = 1;

-- 需要手动提交
COMMIT;

-- 恢复自动提交
SET autocommit = 1;
```

---

## 2. ACID特性

### 2.1 原子性（Atomicity）
```sql
-- 测试：订单创建失败时，所有操作都应回滚
START TRANSACTION;

-- 操作1：创建订单
INSERT INTO orders (order_no, user_id, total_amount, pay_amount, freight, status, receiver_name, receiver_phone, receiver_address)
VALUES ('TEST002', 1, 200.00, 200.00, 0, 0, '测试用户', '13800138000', '测试地址');

SET @order_id = LAST_INSERT_ID();

-- 操作2：扣减库存
UPDATE products SET stock = stock - 1 WHERE id = 1;

-- 操作3：故意制造错误（例如：插入重复的订单号）
-- INSERT INTO orders (order_no, ...) VALUES ('TEST002', ...);

-- 回滚所有操作
ROLLBACK;

-- 验证：订单未创建，库存未扣减
SELECT * FROM orders WHERE order_no = 'TEST002';
SELECT stock FROM products WHERE id = 1;
```

### 2.2 一致性（Consistency）
```sql
-- 测试：订单金额 = 订单明细总和
START TRANSACTION;

-- 创建订单
INSERT INTO orders (order_no, user_id, total_amount, pay_amount, freight, status, receiver_name, receiver_phone, receiver_address)
VALUES ('TEST003', 1, 300.00, 300.00, 0, 0, '测试用户', '13800138000', '测试地址');

SET @order_id = LAST_INSERT_ID();

-- 添加明细
INSERT INTO order_items (order_id, product_id, product_name, price, quantity, total_amount)
VALUES
  (@order_id, 1, '商品1', 100.00, 1, 100.00),
  (@order_id, 2, '商品2', 200.00, 1, 200.00);

-- 验证一致性
SELECT
  o.total_amount as order_total,
  SUM(oi.total_amount) as items_total,
  o.total_amount = SUM(oi.total_amount) as is_consistent
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
WHERE o.id = @order_id;

COMMIT;

-- 清理
DELETE FROM order_items WHERE order_id = @order_id;
DELETE FROM orders WHERE id = @order_id;
```

### 2.3 隔离性（Isolation）
```sql
-- 在两个终端测试，见下面的隔离级别练习
```

### 2.4 持久性（Durability）
```sql
-- 提交后的数据应该永久保存
-- 即使数据库重启也不会丢失
```

---

## 3. 隔离级别

### 3.1 查看隔离级别
```sql
-- 查看全局隔离级别
SELECT @@global.transaction_isolation;

-- 查看会话隔离级别
SELECT @@session.transaction_isolation;

-- MySQL 8.0 默认是 REPEATABLE-READ
```

### 3.2 设置隔离级别
```sql
-- 设置会话隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

---

## 4. 并发问题模拟（需要两个终端）

### 4.1 脏读（READ UNCOMMITTED）
```sql
-- 终端1：设置隔离级别为READ UNCOMMITTED
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;
SELECT stock FROM products WHERE id = 1;  -- 记录初始值

-- 终端2：
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;
UPDATE products SET stock = 999 WHERE id = 1;
-- 不提交

-- 终端1：读取未提交的数据（脏读）
SELECT stock FROM products WHERE id = 1;  -- 看到999

-- 终端2：回滚
ROLLBACK;

-- 终端1：验证脏读
SELECT stock FROM products WHERE id = 1;  -- 恢复原值
COMMIT;
```

### 4.2 不可重复读（READ COMMITTED）
```sql
-- 终端1：设置隔离级别为READ COMMITTED
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
SELECT stock FROM products WHERE id = 1;  -- 第一次读取

-- 终端2：
START TRANSACTION;
UPDATE products SET stock = stock - 10 WHERE id = 1;
COMMIT;  -- 提交

-- 终端1：再次读取（不可重复读）
SELECT stock FROM products WHERE id = 1;  -- 值已改变
COMMIT;
```

### 4.3 幻读（REPEATABLE READ）
```sql
-- 终端1：
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT COUNT(*) FROM orders WHERE user_id = 1;  -- 第一次查询

-- 终端2：
START TRANSACTION;
INSERT INTO orders (order_no, user_id, total_amount, pay_amount, freight, status, receiver_name, receiver_phone, receiver_address)
VALUES ('PHANTOM001', 1, 100, 100, 0, 0, 'Test', '13800138000', 'Test Address');
COMMIT;

-- 终端1：再次查询
SELECT COUNT(*) FROM orders WHERE user_id = 1;  -- 在REPEATABLE READ下，MySQL使用MVCC，不会出现幻读

-- 但尝试更新：
UPDATE orders SET status = 1 WHERE user_id = 1 AND order_no = 'PHANTOM001';
-- 能更新成功！这是当前读，能看到新插入的行

COMMIT;

-- 清理
DELETE FROM orders WHERE order_no = 'PHANTOM001';
```

---

## 5. 锁机制

### 5.1 共享锁（S锁）
```sql
-- 终端1：加共享锁
START TRANSACTION;
SELECT * FROM products WHERE id = 1 LOCK IN SHARE MODE;

-- 终端2：可以读
SELECT * FROM products WHERE id = 1;

-- 终端2：不能写（会等待）
START TRANSACTION;
UPDATE products SET stock = stock - 1 WHERE id = 1;  -- 阻塞

-- 终端1：释放锁
COMMIT;

-- 终端2：现在可以执行了
COMMIT;
```

### 5.2 排他锁（X锁）
```sql
-- 终端1：加排他锁
START TRANSACTION;
SELECT * FROM products WHERE id = 1 FOR UPDATE;

-- 终端2：读取会阻塞（如果也加锁）
START TRANSACTION;
SELECT * FROM products WHERE id = 1 FOR UPDATE;  -- 阻塞

-- 终端2：普通读取不阻塞（一致性读）
SELECT * FROM products WHERE id = 1;  -- 不阻塞

-- 终端1：释放锁
COMMIT;

-- 终端2：
COMMIT;
```

### 5.3 表锁
```sql
-- 锁定表（读锁）
LOCK TABLES products READ;
SELECT * FROM products WHERE id = 1;  -- 可以读
-- UPDATE products SET stock = 999 WHERE id = 1;  -- 报错

UNLOCK TABLES;

-- 锁定表（写锁）
LOCK TABLES products WRITE;
UPDATE products SET stock = stock - 1 WHERE id = 1;  -- 可以写
UNLOCK TABLES;
```

### 5.4 行锁
```sql
-- InnoDB默认使用行锁
START TRANSACTION;
UPDATE products SET stock = stock - 1 WHERE id = 1;  -- 锁定id=1的行

-- 其他终端可以更新其他行
-- UPDATE products SET stock = stock - 1 WHERE id = 2;  -- 不阻塞

COMMIT;
```

---

## 6. 死锁

### 6.1 制造死锁
```sql
-- 终端1：
START TRANSACTION;
UPDATE products SET stock = stock - 1 WHERE id = 1;  -- 锁住id=1

-- 终端2：
START TRANSACTION;
UPDATE products SET stock = stock - 1 WHERE id = 2;  -- 锁住id=2

-- 终端1：尝试锁id=2
UPDATE products SET stock = stock - 1 WHERE id = 2;  -- 等待

-- 终端2：尝试锁id=1（触发死锁）
UPDATE products SET stock = stock - 1 WHERE id = 1;  -- 死锁！其中一个事务会被回滚

-- 清理
COMMIT;
```

### 6.2 查看死锁信息
```sql
-- 查看最近的死锁信息
SHOW ENGINE INNODB STATUS;
-- 在输出中查找 "LATEST DETECTED DEADLOCK" 部分
```

---

## 7. MVCC（多版本并发控制）

### 7.1 测试快照读
```sql
-- 终端1：
START TRANSACTION;
SELECT * FROM products WHERE id = 1;  -- 快照读，记录当前版本

-- 终端2：
UPDATE products SET stock = 888 WHERE id = 1;

-- 终端1：再次查询
SELECT * FROM products WHERE id = 1;  -- 仍然看到旧版本（REPEATABLE READ）

COMMIT;
```

### 7.2 测试当前读
```sql
-- 终端1：
START TRANSACTION;
SELECT * FROM products WHERE id = 1 FOR UPDATE;  -- 当前读

-- 终端2：
UPDATE products SET stock = 777 WHERE id = 1;  -- 阻塞

-- 终端1：
COMMIT;

-- 终端2：执行成功
```

---

## 8. 实战场景

### 8.1 秒杀场景（库存扣减）
```sql
-- 问题版本：可能超卖
START TRANSACTION;
SELECT stock FROM products WHERE id = 1;  -- 读取库存
-- 应用层判断 stock > 0
UPDATE products SET stock = stock - 1 WHERE id = 1;
COMMIT;

-- 正确版本1：WHERE条件判断
START TRANSACTION;
UPDATE products SET stock = stock - 1 WHERE id = 1 AND stock > 0;
-- 检查影响行数，如果为0说明库存不足
COMMIT;

-- 正确版本2：悲观锁
START TRANSACTION;
SELECT stock FROM products WHERE id = 1 FOR UPDATE;  -- 锁住
-- 判断库存
UPDATE products SET stock = stock - 1 WHERE id = 1;
COMMIT;

-- 正确版本3：乐观锁（需要version字段）
-- UPDATE products SET stock = stock - 1, version = version + 1
-- WHERE id = 1 AND version = @old_version AND stock > 0;
```

### 8.2 转账场景
```sql
-- A转账100元给B
START TRANSACTION;

-- 检查A的余额（假设users表有balance字段）
-- SELECT balance FROM users WHERE id = A FOR UPDATE;

-- 扣减A的余额
-- UPDATE users SET balance = balance - 100 WHERE id = A AND balance >= 100;

-- 增加B的余额
-- UPDATE users SET balance = balance + 100 WHERE id = B;

-- 记录转账日志
-- INSERT INTO transfer_log ...

COMMIT;
```

### 8.3 订单创建场景
```sql
START TRANSACTION;

-- 1. 检查库存并锁定
SELECT stock FROM products WHERE id = @product_id FOR UPDATE;

-- 2. 创建订单
INSERT INTO orders (...) VALUES (...);
SET @order_id = LAST_INSERT_ID();

-- 3. 创建订单明细
INSERT INTO order_items (...) VALUES (...);

-- 4. 扣减库存
UPDATE products SET stock = stock - @quantity WHERE id = @product_id AND stock >= @quantity;

-- 5. 检查影响行数
-- 如果为0，说明库存不足，回滚

COMMIT;
```

---

## 9. 性能优化

### 9.1 减少事务范围
```sql
-- 不好：事务太长
START TRANSACTION;
-- 复杂计算
-- 网络调用
-- 文件操作
UPDATE ...;
COMMIT;

-- 好：事务只包含数据库操作
-- 先做计算和准备
START TRANSACTION;
UPDATE ...;
COMMIT;
```

### 9.2 避免长时间锁定
```sql
-- 不好：FOR UPDATE 锁定时间太长
START TRANSACTION;
SELECT * FROM orders WHERE id = 1 FOR UPDATE;
-- 复杂业务逻辑处理...
UPDATE orders SET status = 1 WHERE id = 1;
COMMIT;

-- 好：缩短锁定时间
-- 先读取数据（快照读）
SELECT * FROM orders WHERE id = 1;
-- 业务逻辑处理...
-- 最后才加锁更新
START TRANSACTION;
UPDATE orders SET status = 1 WHERE id = 1;
COMMIT;
```

---

## 10. 综合练习

### 10.1 模拟完整下单流程
```sql
-- 实现一个完整的下单事务
-- 包括：
-- 1. 检查用户状态
-- 2. 检查商品库存
-- 3. 创建订单
-- 4. 创建订单明细
-- 5. 扣减库存
-- 6. 清空购物车
-- 要求：原子性、一致性、处理并发
```

### 10.2 处理分布式事务
```sql
-- 思考：如果订单表和库存表在不同数据库，如何保证一致性？
-- 方案：
-- 1. 2PC（两阶段提交）
-- 2. TCC（Try-Confirm-Cancel）
-- 3. 本地消息表
-- 4. Saga模式
```

---

## 学习检查点

完成所有练习后，你应该能够：
- [ ] 熟练使用事务的基本操作
- [ ] 理解ACID特性
- [ ] 掌握四种隔离级别的区别
- [ ] 识别并发问题（脏读、不可重复读、幻读）
- [ ] 理解锁机制（共享锁、排他锁、行锁、表锁）
- [ ] 处理死锁问题
- [ ] 理解MVCC原理
- [ ] 在实际场景中正确使用事务

**下一步**: 完成后查看 `solutions/06-事务处理.md` 对照答案，然后进入第七阶段学习。
