# 第七阶段：存储过程与函数练习

## 练习说明
- 存储过程可以封装复杂的业务逻辑
- 函数用于返回计算结果
- 触发器自动响应数据变化

---

## 1. 存储过程基础

### 1.1 创建简单存储过程
```sql
-- 创建：查询指定用户的订单数
DELIMITER $$

CREATE PROCEDURE GetUserOrderCount(IN p_user_id BIGINT)
BEGIN
  SELECT COUNT(*) as order_count
  FROM orders
  WHERE user_id = p_user_id;
END$$

DELIMITER ;

-- 调用
CALL GetUserOrderCount(1);

-- 删除
DROP PROCEDURE IF EXISTS GetUserOrderCount;
```

### 1.2 带多个参数
```sql
DELIMITER $$

CREATE PROCEDURE GetOrdersByStatus(
  IN p_status TINYINT,
  IN p_limit INT
)
BEGIN
  SELECT order_no, user_id, total_amount, created_at
  FROM orders
  WHERE status = p_status
  ORDER BY created_at DESC
  LIMIT p_limit;
END$$

DELIMITER ;

-- 调用
CALL GetOrdersByStatus(1, 10);

DROP PROCEDURE IF EXISTS GetOrdersByStatus;
```

### 1.3 OUT参数
```sql
DELIMITER $$

CREATE PROCEDURE GetUserStats(
  IN p_user_id BIGINT,
  OUT p_order_count INT,
  OUT p_total_amount DECIMAL(10,2)
)
BEGIN
  SELECT
    COUNT(*),
    IFNULL(SUM(pay_amount), 0)
  INTO p_order_count, p_total_amount
  FROM orders
  WHERE user_id = p_user_id AND status = 3;
END$$

DELIMITER ;

-- 调用
CALL GetUserStats(1, @count, @amount);
SELECT @count as order_count, @amount as total_amount;

DROP PROCEDURE IF EXISTS GetUserStats;
```

### 1.4 INOUT参数
```sql
DELIMITER $$

CREATE PROCEDURE IncreasePrice(INOUT p_price DECIMAL(10,2), IN p_rate DECIMAL(5,2))
BEGIN
  SET p_price = p_price * (1 + p_rate / 100);
END$$

DELIMITER ;

-- 调用
SET @price = 100.00;
CALL IncreasePrice(@price, 10);  -- 涨价10%
SELECT @price;  -- 110.00

DROP PROCEDURE IF EXISTS IncreasePrice;
```

---

## 2. 变量和流程控制

### 2.1 变量声明
```sql
DELIMITER $$

CREATE PROCEDURE VariableDemo()
BEGIN
  -- 声明变量
  DECLARE v_count INT DEFAULT 0;
  DECLARE v_total DECIMAL(10,2);
  DECLARE v_avg DECIMAL(10,2);

  -- 赋值
  SELECT COUNT(*), SUM(pay_amount), AVG(pay_amount)
  INTO v_count, v_total, v_avg
  FROM orders
  WHERE status = 3;

  -- 输出
  SELECT v_count as total_orders, v_total as total_amount, v_avg as avg_amount;
END$$

DELIMITER ;

CALL VariableDemo();
DROP PROCEDURE IF EXISTS VariableDemo;
```

### 2.2 IF条件
```sql
DELIMITER $$

CREATE PROCEDURE GetUserLevel(IN p_user_id BIGINT, OUT p_level VARCHAR(20))
BEGIN
  DECLARE v_total DECIMAL(10,2);

  SELECT IFNULL(SUM(pay_amount), 0) INTO v_total
  FROM orders
  WHERE user_id = p_user_id AND status = 3;

  IF v_total >= 10000 THEN
    SET p_level = 'VIP';
  ELSEIF v_total >= 5000 THEN
    SET p_level = '高价值用户';
  ELSEIF v_total >= 1000 THEN
    SET p_level = '普通用户';
  ELSE
    SET p_level = '新用户';
  END IF;
END$$

DELIMITER ;

CALL GetUserLevel(1, @level);
SELECT @level;

DROP PROCEDURE IF EXISTS GetUserLevel;
```

### 2.3 CASE语句
```sql
DELIMITER $$

CREATE PROCEDURE GetOrderStatusName(IN p_status TINYINT, OUT p_status_name VARCHAR(20))
BEGIN
  CASE p_status
    WHEN 0 THEN SET p_status_name = '待支付';
    WHEN 1 THEN SET p_status_name = '已支付';
    WHEN 2 THEN SET p_status_name = '已发货';
    WHEN 3 THEN SET p_status_name = '已完成';
    WHEN 4 THEN SET p_status_name = '已取消';
    ELSE SET p_status_name = '未知状态';
  END CASE;
END$$

DELIMITER ;

CALL GetOrderStatusName(1, @name);
SELECT @name;

DROP PROCEDURE IF EXISTS GetOrderStatusName;
```

### 2.4 WHILE循环
```sql
DELIMITER $$

CREATE PROCEDURE WhileDemo()
BEGIN
  DECLARE v_counter INT DEFAULT 1;
  DECLARE v_sum INT DEFAULT 0;

  WHILE v_counter <= 10 DO
    SET v_sum = v_sum + v_counter;
    SET v_counter = v_counter + 1;
  END WHILE;

  SELECT v_sum as sum_1_to_10;
END$$

DELIMITER ;

CALL WhileDemo();
DROP PROCEDURE IF EXISTS WhileDemo;
```

### 2.5 REPEAT循环
```sql
DELIMITER $$

CREATE PROCEDURE RepeatDemo()
BEGIN
  DECLARE v_counter INT DEFAULT 1;
  DECLARE v_sum INT DEFAULT 0;

  REPEAT
    SET v_sum = v_sum + v_counter;
    SET v_counter = v_counter + 1;
  UNTIL v_counter > 10
  END REPEAT;

  SELECT v_sum as sum_1_to_10;
END$$

DELIMITER ;

CALL RepeatDemo();
DROP PROCEDURE IF EXISTS RepeatDemo;
```

### 2.6 LOOP循环
```sql
DELIMITER $$

CREATE PROCEDURE LoopDemo()
BEGIN
  DECLARE v_counter INT DEFAULT 1;
  DECLARE v_sum INT DEFAULT 0;

  my_loop: LOOP
    SET v_sum = v_sum + v_counter;
    SET v_counter = v_counter + 1;

    IF v_counter > 10 THEN
      LEAVE my_loop;
    END IF;
  END LOOP;

  SELECT v_sum as sum_1_to_10;
END$$

DELIMITER ;

CALL LoopDemo();
DROP PROCEDURE IF EXISTS LoopDemo;
```

---

## 3. 游标

### 3.1 基础游标使用
```sql
DELIMITER $$

CREATE PROCEDURE CursorDemo()
BEGIN
  DECLARE done INT DEFAULT FALSE;
  DECLARE v_id BIGINT;
  DECLARE v_name VARCHAR(200);
  DECLARE v_price DECIMAL(10,2);

  -- 声明游标
  DECLARE cur CURSOR FOR
    SELECT id, name, price FROM products WHERE status = 1 LIMIT 10;

  -- 声明handler
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

  -- 打开游标
  OPEN cur;

  -- 循环读取
  read_loop: LOOP
    FETCH cur INTO v_id, v_name, v_price;

    IF done THEN
      LEAVE read_loop;
    END IF;

    -- 处理数据（这里只是输出）
    SELECT v_id, v_name, v_price;
  END LOOP;

  -- 关闭游标
  CLOSE cur;
END$$

DELIMITER ;

CALL CursorDemo();
DROP PROCEDURE IF EXISTS CursorDemo;
```

### 3.2 游标批量处理
```sql
DELIMITER $$

CREATE PROCEDURE UpdateProductPrices()
BEGIN
  DECLARE done INT DEFAULT FALSE;
  DECLARE v_id BIGINT;
  DECLARE v_price DECIMAL(10,2);
  DECLARE v_new_price DECIMAL(10,2);

  DECLARE cur CURSOR FOR
    SELECT id, price FROM products WHERE status = 1;

  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

  OPEN cur;

  read_loop: LOOP
    FETCH cur INTO v_id, v_price;

    IF done THEN
      LEAVE read_loop;
    END IF;

    -- 根据价格区间调整
    IF v_price < 100 THEN
      SET v_new_price = v_price * 1.1;  -- 涨价10%
    ELSEIF v_price < 500 THEN
      SET v_new_price = v_price * 1.05;  -- 涨价5%
    ELSE
      SET v_new_price = v_price;  -- 不涨价
    END IF;

    -- 更新（实际使用时取消注释）
    -- UPDATE products SET price = v_new_price WHERE id = v_id;
  END LOOP;

  CLOSE cur;

  SELECT 'Price update completed' as message;
END$$

DELIMITER ;

-- CALL UpdateProductPrices();
DROP PROCEDURE IF EXISTS UpdateProductPrices;
```

---

## 4. 函数

### 4.1 创建函数
```sql
DELIMITER $$

CREATE FUNCTION CalcOrderTotal(p_order_id BIGINT)
RETURNS DECIMAL(10,2)
DETERMINISTIC
READS SQL DATA
BEGIN
  DECLARE v_total DECIMAL(10,2);

  SELECT IFNULL(SUM(total_amount), 0) INTO v_total
  FROM order_items
  WHERE order_id = p_order_id;

  RETURN v_total;
END$$

DELIMITER ;

-- 使用函数
SELECT order_no, CalcOrderTotal(id) as calculated_total
FROM orders
LIMIT 10;

DROP FUNCTION IF EXISTS CalcOrderTotal;
```

### 4.2 字符串处理函数
```sql
DELIMITER $$

CREATE FUNCTION MaskPhone(p_phone VARCHAR(20))
RETURNS VARCHAR(20)
DETERMINISTIC
BEGIN
  IF LENGTH(p_phone) = 11 THEN
    RETURN CONCAT(SUBSTRING(p_phone, 1, 3), '****', SUBSTRING(p_phone, 8, 4));
  ELSE
    RETURN p_phone;
  END IF;
END$$

DELIMITER ;

SELECT username, MaskPhone(phone) as masked_phone
FROM users
LIMIT 10;

DROP FUNCTION IF EXISTS MaskPhone;
```

### 4.3 日期处理函数
```sql
DELIMITER $$

CREATE FUNCTION GetDaysSinceOrder(p_order_date TIMESTAMP)
RETURNS INT
DETERMINISTIC
BEGIN
  RETURN DATEDIFF(NOW(), p_order_date);
END$$

DELIMITER ;

SELECT order_no, created_at, GetDaysSinceOrder(created_at) as days_ago
FROM orders
ORDER BY created_at DESC
LIMIT 10;

DROP FUNCTION IF EXISTS GetDaysSinceOrder;
```

---

## 5. 触发器

### 5.1 BEFORE INSERT 触发器
```sql
DELIMITER $$

CREATE TRIGGER before_order_insert
BEFORE INSERT ON orders
FOR EACH ROW
BEGIN
  -- 自动生成订单号（如果为空）
  IF NEW.order_no IS NULL OR NEW.order_no = '' THEN
    SET NEW.order_no = CONCAT('ORD', DATE_FORMAT(NOW(), '%Y%m%d%H%i%s'), LPAD(FLOOR(RAND() * 10000), 4, '0'));
  END IF;

  -- 设置创建时间
  IF NEW.created_at IS NULL THEN
    SET NEW.created_at = NOW();
  END IF;
END$$

DELIMITER ;

-- 测试（不设置order_no）
-- INSERT INTO orders (user_id, total_amount, pay_amount, freight, status, receiver_name, receiver_phone, receiver_address)
-- VALUES (1, 100, 100, 0, 0, 'Test', '13800138000', 'Test Addr');

-- 删除触发器
DROP TRIGGER IF EXISTS before_order_insert;
```

### 5.2 AFTER INSERT 触发器
```sql
-- 创建日志表
CREATE TABLE IF NOT EXISTS order_logs (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  order_id BIGINT,
  action VARCHAR(50),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

DELIMITER $$

CREATE TRIGGER after_order_insert
AFTER INSERT ON orders
FOR EACH ROW
BEGIN
  INSERT INTO order_logs (order_id, action)
  VALUES (NEW.id, 'ORDER_CREATED');
END$$

DELIMITER ;

-- 测试
-- INSERT INTO orders ...

-- 删除
DROP TRIGGER IF EXISTS after_order_insert;
DROP TABLE IF EXISTS order_logs;
```

### 5.3 BEFORE UPDATE 触发器
```sql
DELIMITER $$

CREATE TRIGGER before_order_update
BEFORE UPDATE ON orders
FOR EACH ROW
BEGIN
  -- 记录支付时间
  IF OLD.status = 0 AND NEW.status = 1 AND NEW.payment_time IS NULL THEN
    SET NEW.payment_time = NOW();
  END IF;

  -- 记录发货时间
  IF OLD.status = 1 AND NEW.status = 2 AND NEW.delivery_time IS NULL THEN
    SET NEW.delivery_time = NOW();
  END IF;

  -- 记录完成时间
  IF OLD.status = 2 AND NEW.status = 3 AND NEW.finish_time IS NULL THEN
    SET NEW.finish_time = NOW();
  END IF;

  -- 更新修改时间
  SET NEW.updated_at = NOW();
END$$

DELIMITER ;

-- 测试
-- UPDATE orders SET status = 1 WHERE id = 1;

DROP TRIGGER IF EXISTS before_order_update;
```

### 5.4 AFTER UPDATE 触发器
```sql
DELIMITER $$

CREATE TRIGGER after_order_status_update
AFTER UPDATE ON orders
FOR EACH ROW
BEGIN
  IF OLD.status != NEW.status THEN
    -- 记录状态变更日志
    -- INSERT INTO order_logs (order_id, action) VALUES (...);

    -- 如果订单完成，更新商品销量
    IF NEW.status = 3 THEN
      UPDATE products p
      JOIN order_items oi ON p.id = oi.product_id
      SET p.sales = p.sales + oi.quantity
      WHERE oi.order_id = NEW.id;
    END IF;
  END IF;
END$$

DELIMITER ;

DROP TRIGGER IF EXISTS after_order_status_update;
```

### 5.5 BEFORE DELETE 触发器
```sql
DELIMITER $$

CREATE TRIGGER before_order_delete
BEFORE DELETE ON orders
FOR EACH ROW
BEGIN
  -- 防止删除已支付的订单
  IF OLD.status >= 1 THEN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = '不能删除已支付的订单';
  END IF;
END$$

DELIMITER ;

-- 测试（会失败）
-- DELETE FROM orders WHERE id = 1 AND status = 1;

DROP TRIGGER IF EXISTS before_order_delete;
```

---

## 6. 异常处理

### 6.1 DECLARE HANDLER
```sql
DELIMITER $$

CREATE PROCEDURE SafeDivide(IN p_a INT, IN p_b INT, OUT p_result DECIMAL(10,2))
BEGIN
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
  BEGIN
    SET p_result = NULL;
  END;

  SET p_result = p_a / p_b;
END$$

DELIMITER ;

CALL SafeDivide(10, 2, @result);
SELECT @result;  -- 5.00

CALL SafeDivide(10, 0, @result);
SELECT @result;  -- NULL

DROP PROCEDURE IF EXISTS SafeDivide;
```

### 6.2 SIGNAL 抛出异常
```sql
DELIMITER $$

CREATE PROCEDURE CreateOrder(IN p_user_id BIGINT, IN p_amount DECIMAL(10,2))
BEGIN
  -- 检查金额
  IF p_amount <= 0 THEN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = '订单金额必须大于0';
  END IF;

  -- 检查用户是否存在
  IF NOT EXISTS(SELECT 1 FROM users WHERE id = p_user_id) THEN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = '用户不存在';
  END IF;

  -- 创建订单
  INSERT INTO orders (order_no, user_id, total_amount, pay_amount, freight, status, receiver_name, receiver_phone, receiver_address)
  VALUES (CONCAT('TEST', p_user_id), p_user_id, p_amount, p_amount, 0, 0, 'Test', '13800138000', 'Test');

  SELECT 'Order created' as message;
END$$

DELIMITER ;

-- CALL CreateOrder(1, 100);
-- CALL CreateOrder(1, -100);  -- 会抛出异常

DROP PROCEDURE IF EXISTS CreateOrder;
```

---

## 7. 实战练习

### 7.1 库存扣减存储过程
```sql
DELIMITER $$

CREATE PROCEDURE DeductStock(
  IN p_product_id BIGINT,
  IN p_quantity INT,
  OUT p_success BOOLEAN,
  OUT p_message VARCHAR(100)
)
BEGIN
  DECLARE v_stock INT;

  -- 查询当前库存
  SELECT stock INTO v_stock
  FROM products
  WHERE id = p_product_id
  FOR UPDATE;

  -- 检查库存
  IF v_stock >= p_quantity THEN
    UPDATE products
    SET stock = stock - p_quantity
    WHERE id = p_product_id;

    SET p_success = TRUE;
    SET p_message = '库存扣减成功';
  ELSE
    SET p_success = FALSE;
    SET p_message = CONCAT('库存不足，当前库存: ', v_stock);
  END IF;
END$$

DELIMITER ;

-- 测试
START TRANSACTION;
CALL DeductStock(1, 5, @success, @message);
SELECT @success, @message;
ROLLBACK;

DROP PROCEDURE IF EXISTS DeductStock;
```

### 7.2 用户消费统计存储过程
```sql
DELIMITER $$

CREATE PROCEDURE AnalyzeUserPurchase(IN p_user_id BIGINT)
BEGIN
  -- 基本统计
  SELECT
    COUNT(*) as total_orders,
    SUM(pay_amount) as total_amount,
    AVG(pay_amount) as avg_amount,
    MAX(pay_amount) as max_amount,
    MIN(created_at) as first_order_date,
    MAX(created_at) as last_order_date
  FROM orders
  WHERE user_id = p_user_id AND status = 3;

  -- 按状态分组
  SELECT status, COUNT(*) as count
  FROM orders
  WHERE user_id = p_user_id
  GROUP BY status;

  -- 购买的商品分类
  SELECT c.name as category, COUNT(DISTINCT oi.product_id) as product_count, SUM(oi.quantity) as total_quantity
  FROM orders o
  JOIN order_items oi ON o.id = oi.order_id
  JOIN products p ON oi.product_id = p.id
  JOIN categories c ON p.category_id = c.id
  WHERE o.user_id = p_user_id AND o.status = 3
  GROUP BY c.id, c.name
  ORDER BY total_quantity DESC;
END$$

DELIMITER ;

CALL AnalyzeUserPurchase(1);

DROP PROCEDURE IF EXISTS AnalyzeUserPurchase;
```

---

## 8. 综合实战

### 8.1 完整下单流程
```sql
-- 练习：创建一个存储过程实现完整的下单流程
-- 要求：
-- 1. 检查商品库存
-- 2. 创建订单
-- 3. 创建订单明细
-- 4. 扣减库存
-- 5. 清空购物车（可选）
-- 6. 返回订单ID
-- 7. 异常处理和事务回滚
```

---

## 学习检查点

完成所有练习后，你应该能够：
- [ ] 创建和调用存储过程
- [ ] 使用IN/OUT/INOUT参数
- [ ] 掌握流程控制（IF/CASE/WHILE/LOOP）
- [ ] 使用游标处理结果集
- [ ] 创建和使用函数
- [ ] 编写触发器响应数据变化
- [ ] 处理异常和错误
- [ ] 封装复杂的业务逻辑

**下一步**: 完成后查看 `solutions/07-存储过程.md` 对照答案，然后进入第八阶段学习。
