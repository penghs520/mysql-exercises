# 第九阶段：性能优化练习

## 练习说明
- 性能优化是数据库的核心技能
- 理解慢查询的成因
- 掌握系统的优化方法

---

## 1. 慢查询日志

### 1.1 开启慢查询日志
```sql
-- 查看慢查询配置
SHOW VARIABLES LIKE 'slow_query%';
SHOW VARIABLES LIKE 'long_query_time';

-- 开启慢查询日志（需要权限）
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;  -- 超过1秒的查询记录

-- 查看慢查询日志位置
SHOW VARIABLES LIKE 'slow_query_log_file';
```

### 1.2 分析慢查询
```sql
-- 执行一个慢查询
SELECT *
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
WHERE o.created_at > DATE_SUB(NOW(), INTERVAL 1 YEAR)
ORDER BY o.created_at DESC;

-- 使用mysqldumpslow分析（在终端执行）
-- mysqldumpslow -s t -t 10 /path/to/slow-query.log
```

---

## 2. EXPLAIN 深度分析

### 2.1 理解type列
```sql
-- system/const: 最快（常量查询）
EXPLAIN SELECT * FROM users WHERE id = 1;

-- eq_ref: 唯一索引连接
EXPLAIN SELECT o.*, u.username
FROM orders o
JOIN users u ON o.user_id = u.id
LIMIT 10;

-- ref: 非唯一索引查询
EXPLAIN SELECT * FROM orders WHERE user_id = 100;

-- range: 范围查询
EXPLAIN SELECT * FROM orders WHERE created_at > '2024-01-01';

-- index: 索引全扫描
EXPLAIN SELECT id FROM products;

-- ALL: 全表扫描（最慢）
EXPLAIN SELECT * FROM products WHERE description LIKE '%测试%';
```

### 2.2 分析Extra列
```sql
-- Using index: 覆盖索引（好）
EXPLAIN SELECT user_id FROM orders WHERE user_id = 1;

-- Using where: WHERE过滤
EXPLAIN SELECT * FROM orders WHERE status = 1;

-- Using temporary: 使用临时表（需要优化）
EXPLAIN SELECT DISTINCT user_id FROM orders;

-- Using filesort: 文件排序（需要优化）
EXPLAIN SELECT * FROM products ORDER BY sales DESC;

-- Using index condition: 索引条件下推
EXPLAIN SELECT * FROM orders WHERE user_id > 100 AND status = 1;
```

### 2.3 分析key和rows
```sql
-- 对比使用索引前后
-- 无索引
EXPLAIN SELECT * FROM orders WHERE status = 1;

-- 创建索引
CREATE INDEX idx_status ON orders(status);

-- 再次分析
EXPLAIN SELECT * FROM orders WHERE status = 1;

-- 观察key（使用的索引）和rows（扫描行数）的变化

-- 清理
DROP INDEX idx_status ON orders;
```

---

## 3. 查询优化技巧

### 3.1 避免SELECT *
```sql
-- 不好：查询所有字段
SELECT * FROM products WHERE id = 1;

-- 好：只查询需要的字段
SELECT id, name, price, stock FROM products WHERE id = 1;

-- 对比执行计划
EXPLAIN SELECT * FROM products WHERE id IN (1,2,3,4,5);
EXPLAIN SELECT id, name, price FROM products WHERE id IN (1,2,3,4,5);
```

### 3.2 优化JOIN
```sql
-- 不好：大表在前
EXPLAIN SELECT *
FROM order_items oi  -- 50000行
JOIN products p ON oi.product_id = p.id  -- 500行
LIMIT 10;

-- 好：小表驱动大表
EXPLAIN SELECT *
FROM products p  -- 500行
JOIN order_items oi ON p.id = oi.product_id  -- 50000行
LIMIT 10;

-- 确保连接字段有索引
SHOW INDEX FROM order_items WHERE Key_name LIKE '%product%';
```

### 3.3 优化OR条件
```sql
-- 不好：OR可能导致索引失效
EXPLAIN SELECT * FROM orders WHERE user_id = 1 OR status = 1;

-- 好：改用UNION
EXPLAIN
SELECT * FROM orders WHERE user_id = 1
UNION
SELECT * FROM orders WHERE status = 1;

-- 或用IN
EXPLAIN SELECT * FROM orders WHERE status IN (1, 2, 3);
```

### 3.4 避免函数导致索引失效
```sql
-- 不好：对索引列使用函数
EXPLAIN SELECT * FROM orders WHERE DATE(created_at) = '2024-01-01';

-- 好：改写条件
EXPLAIN SELECT * FROM orders
WHERE created_at >= '2024-01-01 00:00:00'
  AND created_at < '2024-01-02 00:00:00';
```

### 3.5 优化LIKE查询
```sql
-- 不好：前导模糊查询
EXPLAIN SELECT * FROM products WHERE name LIKE '%手机%';

-- 好：后缀模糊可以用索引
EXPLAIN SELECT * FROM products WHERE name LIKE '手机%';

-- 对于全文搜索，考虑使用全文索引
-- ALTER TABLE products ADD FULLTEXT INDEX ft_name(name);
-- SELECT * FROM products WHERE MATCH(name) AGAINST('手机');
```

---

## 4. 分页优化

### 4.1 传统分页问题
```sql
-- 问题：深度分页很慢
EXPLAIN SELECT * FROM orders ORDER BY id LIMIT 10000, 20;
-- 需要扫描10020行，然后丢弃前10000行

-- 测试性能
SELECT * FROM orders ORDER BY id LIMIT 0, 20;
SELECT * FROM orders ORDER BY id LIMIT 10000, 20;
-- 对比执行时间
```

### 4.2 优化方案1：延迟关联
```sql
-- 优化：先查主键，再关联
EXPLAIN SELECT o.*
FROM orders o
JOIN (
  SELECT id FROM orders ORDER BY id LIMIT 10000, 20
) t ON o.id = t.id;

-- 对比性能
```

### 4.3 优化方案2：记录上次位置
```sql
-- 第一页
SELECT * FROM orders WHERE id > 0 ORDER BY id LIMIT 20;

-- 第二页（假设上一页最后一条id是20）
SELECT * FROM orders WHERE id > 20 ORDER BY id LIMIT 20;

-- 第三页（假设上一页最后一条id是40）
SELECT * FROM orders WHERE id > 40 ORDER BY id LIMIT 20;

-- 优势：性能稳定，不随页数增加而变慢
-- 缺点：不能跳页
```

### 4.4 优化方案3：WHERE条件分页
```sql
-- 如果有时间范围等条件，利用它们
SELECT * FROM orders
WHERE created_at >= '2024-01-01'
  AND created_at < '2024-02-01'
ORDER BY created_at DESC
LIMIT 20;

-- 比全表分页快很多
```

---

## 5. 子查询优化

### 5.1 子查询改写为JOIN
```sql
-- 不好：关联子查询（每行都执行一次）
EXPLAIN SELECT *
FROM products p
WHERE (SELECT COUNT(*) FROM order_items WHERE product_id = p.id) > 10;

-- 好：改写为JOIN
EXPLAIN SELECT p.*
FROM products p
JOIN (
  SELECT product_id, COUNT(*) as cnt
  FROM order_items
  GROUP BY product_id
  HAVING cnt > 10
) t ON p.id = t.product_id;
```

### 5.2 IN子查询优化
```sql
-- 不好：IN子查询可能很慢
EXPLAIN SELECT * FROM users
WHERE id IN (SELECT user_id FROM orders WHERE status = 3);

-- 好：改写为EXISTS（如果子查询结果很大）
EXPLAIN SELECT * FROM users u
WHERE EXISTS (
  SELECT 1 FROM orders o WHERE o.user_id = u.id AND o.status = 3
);

-- 或改写为JOIN
EXPLAIN SELECT DISTINCT u.*
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.status = 3;
```

---

## 6. GROUP BY优化

### 6.1 索引优化GROUP BY
```sql
-- 不好：GROUP BY字段无索引
EXPLAIN SELECT status, COUNT(*) FROM orders GROUP BY status;

-- 创建索引
CREATE INDEX idx_status ON orders(status);

-- 再次分析
EXPLAIN SELECT status, COUNT(*) FROM orders GROUP BY status;

-- 清理
DROP INDEX idx_status ON orders;
```

### 6.2 避免不必要的排序
```sql
-- GROUP BY默认会排序
EXPLAIN SELECT user_id, COUNT(*) FROM orders GROUP BY user_id;

-- 如果不需要排序，使用ORDER BY NULL
EXPLAIN SELECT user_id, COUNT(*) FROM orders GROUP BY user_id ORDER BY NULL;
```

### 6.3 优化HAVING
```sql
-- 不好：HAVING做数据过滤
SELECT user_id, COUNT(*) as cnt
FROM orders
GROUP BY user_id
HAVING user_id > 100;

-- 好：能用WHERE就用WHERE
SELECT user_id, COUNT(*) as cnt
FROM orders
WHERE user_id > 100
GROUP BY user_id;
```

---

## 7. COUNT优化

### 7.1 COUNT(*)性能
```sql
-- InnoDB中COUNT(*)需要全表扫描
EXPLAIN SELECT COUNT(*) FROM orders;

-- 如果只是统计总数，考虑：
-- 1. 缓存结果
-- 2. 使用近似值
-- 3. 维护计数表
```

### 7.2 带条件的COUNT优化
```sql
-- 不好：多次查询
SELECT COUNT(*) FROM orders WHERE status = 0;
SELECT COUNT(*) FROM orders WHERE status = 1;
SELECT COUNT(*) FROM orders WHERE status = 2;

-- 好：一次查询
SELECT
  SUM(CASE WHEN status = 0 THEN 1 ELSE 0 END) as status_0,
  SUM(CASE WHEN status = 1 THEN 1 ELSE 0 END) as status_1,
  SUM(CASE WHEN status = 2 THEN 1 ELSE 0 END) as status_2
FROM orders;
```

---

## 8. 索引设计优化

### 8.1 覆盖索引设计
```sql
-- 查询：经常查询用户的订单号列表
SELECT order_no FROM orders WHERE user_id = 100;

-- 创建覆盖索引
CREATE INDEX idx_user_orderno ON orders(user_id, order_no);

-- 验证使用覆盖索引
EXPLAIN SELECT order_no FROM orders WHERE user_id = 100;
-- Extra应该显示"Using index"

DROP INDEX idx_user_orderno ON orders;
```

### 8.2 组合索引顺序
```sql
-- 查询模式：
-- WHERE user_id = ? AND status = ? ORDER BY created_at

-- 方案1：(user_id, status, created_at)
CREATE INDEX idx_1 ON orders(user_id, status, created_at);
EXPLAIN SELECT * FROM orders
WHERE user_id = 100 AND status = 1
ORDER BY created_at DESC
LIMIT 10;
DROP INDEX idx_1 ON orders;

-- 方案2：(user_id, created_at, status)
CREATE INDEX idx_2 ON orders(user_id, created_at, status);
EXPLAIN SELECT * FROM orders
WHERE user_id = 100 AND status = 1
ORDER BY created_at DESC
LIMIT 10;
DROP INDEX idx_2 ON orders;

-- 对比哪个方案更好
```

### 8.3 前缀索引
```sql
-- 对于长字符串，使用前缀索引
-- 查看字符串长度分布
SELECT
  AVG(LENGTH(receiver_address)) as avg_len,
  MAX(LENGTH(receiver_address)) as max_len
FROM orders;

-- 创建前缀索引
CREATE INDEX idx_address_prefix ON orders(receiver_address(20));

-- 验证选择性
SELECT
  COUNT(DISTINCT receiver_address) as full_cardinality,
  COUNT(DISTINCT LEFT(receiver_address, 20)) as prefix_cardinality,
  COUNT(DISTINCT LEFT(receiver_address, 20)) / COUNT(DISTINCT receiver_address) as selectivity
FROM orders;

DROP INDEX idx_address_prefix ON orders;
```

---

## 9. 批量操作优化

### 9.1 批量INSERT
```sql
-- 不好：逐条插入
-- INSERT INTO table VALUES (1);
-- INSERT INTO table VALUES (2);
-- ...

-- 好：批量插入
-- INSERT INTO table VALUES (1), (2), (3), ... (1000);

-- 测试：创建临时表
CREATE TABLE test_insert (
  id INT AUTO_INCREMENT PRIMARY KEY,
  value INT
);

-- 方法1：逐条插入（慢）
SET @start = NOW(6);
-- 循环插入100条...
SET @end = NOW(6);
SELECT TIMESTAMPDIFF(MICROSECOND, @start, @end) as time_us;

-- 方法2：批量插入（快）
SET @start = NOW(6);
INSERT INTO test_insert (value) VALUES
(1), (2), (3), ..., (100);  -- 一次性插入
SET @end = NOW(6);
SELECT TIMESTAMPDIFF(MICROSECOND, @start, @end) as time_us;

DROP TABLE test_insert;
```

### 9.2 批量UPDATE
```sql
-- 不好：循环更新
-- UPDATE products SET stock = stock - 1 WHERE id = 1;
-- UPDATE products SET stock = stock - 1 WHERE id = 2;
-- ...

-- 好：使用CASE批量更新
UPDATE products
SET stock = CASE id
  WHEN 1 THEN stock - 1
  WHEN 2 THEN stock - 2
  WHEN 3 THEN stock - 3
END
WHERE id IN (1, 2, 3);
```

---

## 10. 综合优化实战

### 10.1 优化慢查询案例
```sql
-- 场景：查询用户的购买历史，包含商品信息
-- 原始查询（慢）
SELECT
  o.order_no,
  o.created_at,
  p.name as product_name,
  oi.quantity,
  oi.price
FROM users u
JOIN orders o ON u.id = o.user_id
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
WHERE u.username = 'user100'
ORDER BY o.created_at DESC;

-- 分析问题
EXPLAIN SELECT ...;

-- 优化步骤：
-- 1. 检查索引
SHOW INDEX FROM users WHERE Column_name = 'username';
SHOW INDEX FROM orders WHERE Column_name = 'user_id';
SHOW INDEX FROM order_items WHERE Column_name = 'order_id';

-- 2. 添加缺失的索引
-- CREATE INDEX IF NOT EXISTS idx_username ON users(username);
-- CREATE INDEX IF NOT EXISTS idx_user_id ON orders(user_id);
-- CREATE INDEX IF NOT EXISTS idx_order_id ON order_items(order_id);

-- 3. 再次分析
EXPLAIN SELECT ...;

-- 4. 如果还慢，考虑：
-- - 添加LIMIT限制返回行数
-- - 使用覆盖索引
-- - 分页查询
```

### 10.2 优化大数据量统计
```sql
-- 场景：统计每个商品的销售情况
-- 原始查询（可能很慢）
SELECT
  p.id,
  p.name,
  COUNT(DISTINCT o.id) as order_count,
  SUM(oi.quantity) as total_quantity,
  SUM(oi.total_amount) as total_amount
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.id AND o.status = 3
GROUP BY p.id, p.name;

-- 优化方案：
-- 1. 分批次统计
-- 2. 创建汇总表（定期更新）
CREATE TABLE product_sales_summary (
  product_id BIGINT PRIMARY KEY,
  order_count INT,
  total_quantity INT,
  total_amount DECIMAL(15,2),
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 3. 定期更新汇总表（通过定时任务）
-- INSERT INTO product_sales_summary ...
-- ON DUPLICATE KEY UPDATE ...
```

### 10.3 读写分离场景
```sql
-- 思考：
-- 1. 哪些查询适合在从库执行？
--    - 报表查询
--    - 统计分析
--    - 数据导出

-- 2. 哪些操作必须在主库执行？
--    - INSERT/UPDATE/DELETE
--    - 实时性要求高的查询

-- 3. 如何处理主从延迟？
--    - 重要查询强制主库
--    - 容忍短暂的数据延迟
```

---

## 学习检查点

完成所有练习后，你应该能够：
- [ ] 开启和分析慢查询日志
- [ ] 深度理解EXPLAIN输出
- [ ] 掌握各种查询优化技巧
- [ ] 优化分页查询
- [ ] 优化子查询和JOIN
- [ ] 设计高效的索引
- [ ] 优化批量操作
- [ ] 分析和解决实际性能问题

**下一步**: 完成后查看 `solutions/09-性能优化.md` 对照答案，然后进入第十阶段学习。
