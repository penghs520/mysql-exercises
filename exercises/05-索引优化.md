# 第五阶段：索引优化练习

## 练习说明
- 索引是数据库性能的关键
- 理解B+Tree索引原理
- 学会分析执行计划

---

## 1. 查看现有索引

### 1.1 查看表索引
```sql
-- 查看users表的所有索引
SHOW INDEX FROM users;

-- 查看products表的索引
SHOW INDEX FROM products;

-- 理解输出字段：
-- Table: 表名
-- Key_name: 索引名
-- Column_name: 列名
-- Index_type: 索引类型（BTREE, HASH等）
-- Cardinality: 基数（唯一值数量）
```

---

## 2. EXPLAIN 执行计划

### 2.1 基础EXPLAIN
```sql
-- 分析简单查询
EXPLAIN SELECT * FROM users WHERE username = 'user100';

-- 观察输出字段：
-- id: 查询序号
-- select_type: 查询类型（SIMPLE, SUBQUERY等）
-- table: 表名
-- type: 访问类型（system, const, eq_ref, ref, range, index, ALL）
-- possible_keys: 可能使用的索引
-- key: 实际使用的索引
-- rows: 扫描行数
-- Extra: 额外信息
```

### 2.2 对比有无索引
```sql
-- 查询1：使用索引（username有唯一索引）
EXPLAIN SELECT * FROM users WHERE username = 'user500';

-- 查询2：不使用索引（avatar无索引）
EXPLAIN SELECT * FROM users WHERE avatar LIKE '%avatar%';

-- 对比 type 和 rows 字段
```

### 2.3 分析连接查询
```sql
-- 分析两表连接
EXPLAIN
SELECT o.order_no, u.username
FROM orders o
JOIN users u ON o.user_id = u.id
WHERE o.status = 1
LIMIT 10;

-- 观察：
-- 1. 驱动表是谁？
-- 2. 使用了哪些索引？
-- 3. 连接类型是什么？
```

---

## 3. 索引类型

### 3.1 主键索引
```sql
-- 主键索引自动创建
-- 观察主键查询的性能
EXPLAIN SELECT * FROM products WHERE id = 100;
-- type 应该是 const
```

### 3.2 唯一索引
```sql
-- 唯一索引查询
EXPLAIN SELECT * FROM users WHERE email = 'user100@example.com';
-- type 应该是 const 或 eq_ref
```

### 3.3 普通索引
```sql
-- 普通索引查询
EXPLAIN SELECT * FROM users WHERE phone = '13912345678';

```

### 3.4 全文索引（实验）
```sql
-- 创建全文索引
ALTER TABLE products ADD FULLTEXT INDEX ft_name (name);

-- 使用全文索引
EXPLAIN SELECT * FROM products
WHERE MATCH(name) AGAINST('经典款' IN NATURAL LANGUAGE MODE);

-- 删除索引
ALTER TABLE products DROP INDEX ft_name;
```

---

## 4. 创建和删除索引

### 4.1 创建单列索引
```sql
-- 为order_items的product_id创建索引（如果不存在）
CREATE INDEX idx_product_id ON order_items(product_id);

-- 查看索引是否创建成功
SHOW INDEX FROM order_items;
```

### 4.2 创建组合索引
```sql
-- 创建组合索引示例
-- 在orders表上创建(user_id, status, created_at)组合索引
CREATE INDEX idx_user_status_time ON orders(user_id, status, created_at);

-- 测试是否生效
EXPLAIN SELECT * FROM orders
WHERE user_id = 1 AND status = 1 AND created_at > '2024-01-01';
```

### 4.3 删除索引
```sql
-- 删除刚创建的索引
DROP INDEX idx_user_status_time ON orders;
```

---

## 5. 最左前缀原则

### 5.1 理解最左前缀
口诀：带头大哥不能丢，中间弟兄都跟上
```sql
-- orders表已有索引：idx_user_id (user_id)
-- 以下查询能用到索引：
EXPLAIN SELECT * FROM orders WHERE user_id = 1;

-- 假设有组合索引 (user_id, status, created_at)
-- 测试以下查询：

-- 1. 使用user_id（能用到）
EXPLAIN SELECT * FROM orders WHERE user_id = 1;

-- 2. 使用user_id + status（能用到）
EXPLAIN SELECT * FROM orders WHERE user_id = 1 AND status = 1;

-- 3. 使用user_id + status + created_at（能用到）
EXPLAIN SELECT * FROM orders
WHERE user_id = 1 AND status = 1 AND created_at > '2024-01-01';

-- 4. 只使用status（不能用到组合索引）
EXPLAIN SELECT * FROM orders WHERE status = 1;

-- 5. 只使用created_at（不能用到组合索引）
EXPLAIN SELECT * FROM orders WHERE created_at > '2024-01-01';
```

---

## 6. 覆盖索引

### 6.1 理解覆盖索引
```sql
-- 查询只需要索引列，不需要回表
create index idx_user_id_status on orders(user_id,status);

EXPLAIN SELECT user_id, status FROM orders WHERE user_id = 1;

drop index idx_user_id_status on orders;

-- Extra 显示 "Using index" 表示使用了覆盖索引

-- 对比：需要回表
EXPLAIN SELECT * FROM orders WHERE user_id = 1;
-- 需要获取索引外的其他列，要回表
```

### 6.2 利用覆盖索引优化
```sql
-- 查询用户的订单号列表
-- 方法1：可能需要回表
SELECT order_no FROM orders WHERE user_id = 100;

mysql> explain SELECT order_no FROM orders WHERE user_id = 100;
+----+-------------+--------+------------+------+---------------+-------------+---------+-------+------+----------+-------+
| id | select_type | table  | partitions | type | possible_keys | key         | key_len | ref   | rows | filtered | Extra |
+----+-------------+--------+------------+------+---------------+-------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | orders | NULL       | ref  | idx_user_id   | idx_user_id | 8       | const |   30 |   100.00 | NULL  |
+----+-------------+--------+------------+------+---------------+-------------+---------+-------+------+----------+-------+

-- extra 是null

-- 方法2：创建覆盖索引
CREATE INDEX idx_user_orderno ON orders(user_id, order_no);

-- 再次查询，观察是否用到覆盖索引
EXPLAIN SELECT order_no FROM orders WHERE user_id = 100;

mysql> explain SELECT order_no FROM orders WHERE user_id = 100;
+----+-------------+--------+------------+------+------------------------------+------------------+---------+-------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys                | key              | key_len | ref   | rows | filtered | Extra       |
+----+-------------+--------+------------+------+------------------------------+------------------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | orders | NULL       | ref  | idx_user_id,idx_user_orderno | idx_user_orderno | 8       | const |   30 |   100.00 | Using index |
+----+-------------+--------+------------+------+------------------------------+------------------+---------+-------+------+----------+-------------+

-- extra 是 Using index，说明利用了覆盖索引

-- 清理
DROP INDEX idx_user_orderno ON||
orders;

```

---

## 7. 索引失效场景

### 7.1 函数导致索引失效
```sql
-- 不走索引：对索引列使用函数
EXPLAIN SELECT * FROM users WHERE YEAR(created_at) = 2024;

-- 走索引：改写条件
EXPLAIN SELECT * FROM users
WHERE created_at >= '2024-01-01' AND created_at < '2025-01-01';
```

### 7.2 隐式类型转换
```sql
-- phone字段是VARCHAR类型
-- 不走索引：数字查询
EXPLAIN SELECT * FROM users WHERE phone = 13912345678;

-- 走索引：字符串查询
EXPLAIN SELECT * FROM users WHERE phone = '13912345678';
```

### 7.3 前导模糊查询
```sql
-- 不走索引：前导模糊
EXPLAIN SELECT * FROM users WHERE username LIKE '%100';

-- 走索引：后缀模糊
EXPLAIN SELECT * FROM users WHERE username LIKE 'user%';
```

### 7.4 OR 条件
```sql
-- 可能不走索引：OR连接的条件中有无索引的字段
EXPLAIN SELECT * FROM products WHERE id = 100 OR description LIKE '%test%';

-- 走索引：OR两边都有索引
EXPLAIN SELECT * FROM users WHERE username = 'user100' OR email = 'user100@example.com';
```

### 7.5 不等于
```sql
-- 可能不走索引：!= 或 <>
EXPLAIN SELECT * FROM orders WHERE status != 0;

-- 对比：使用IN
EXPLAIN SELECT * FROM orders WHERE status IN (1,2,3,4);
```

---

## 8. 索引选择性

### 8.1 计算索引选择性
```sql
-- 选择性 = 唯一值数 / 总记录数
-- 选择性越高，索引效果越好

-- 检查status字段的选择性（低）
SELECT
  COUNT(DISTINCT status) as unique_values,
  COUNT(*) as total_rows,
  COUNT(DISTINCT status) / COUNT(*) as selectivity
FROM orders;
-- 结果可能是 0.00025（5个不同值 / 20000条记录）

-- 检查order_no字段的选择性（高）
SELECT
  COUNT(DISTINCT order_no) as unique_values,
  COUNT(*) as total_rows,
  COUNT(DISTINCT order_no) / COUNT(*) as selectivity
FROM orders;
-- 结果应该接近 1.0（唯一）
```

### 8.2 组合索引顺序
```sql
-- 组合索引应该将选择性高的字段放在前面
-- 检查哪个字段应该在前：

SELECT 'user_id' as field, COUNT(DISTINCT user_id) as cardinality FROM orders
UNION ALL
SELECT 'status', COUNT(DISTINCT status) FROM orders
UNION ALL
SELECT 'payment_method', COUNT(DISTINCT payment_method) FROM orders;

-- 建议顺序：user_id > payment_method > status
```

---

## 9. 索引监控

### 9.1 查看索引使用情况
```sql
-- MySQL 5.7+
SELECT * FROM sys.schema_unused_indexes WHERE object_schema = 'study_db';

-- 或查看索引统计
SELECT
  TABLE_NAME,
  INDEX_NAME,
  CARDINALITY,
  SEQ_IN_INDEX
FROM information_schema.STATISTICS
WHERE TABLE_SCHEMA = 'study_db'
  AND TABLE_NAME = 'orders';
```

---

## 10. 实战优化

### 10.1 优化慢查询
```sql
-- 问题查询：查找用户的最近订单
SELECT * FROM orders
WHERE user_id = 100
ORDER BY created_at DESC
LIMIT 10;

-- 分析
EXPLAIN SELECT * FROM orders
WHERE user_id = 100
ORDER BY created_at DESC
LIMIT 10;

-- 优化：创建合适的索引
CREATE INDEX idx_user_time ON orders(user_id, created_at);

-- 再次分析
EXPLAIN SELECT * FROM orders
WHERE user_id = 100
ORDER BY created_at DESC
LIMIT 10;

-- 清理
DROP INDEX idx_user_time ON orders;
```

### 10.2 分页查询优化
```sql
-- 问题：深度分页很慢
EXPLAIN SELECT * FROM orders ORDER BY id LIMIT 10000, 20;
-- 需要扫描10020行

-- 优化1：使用WHERE id > ?
EXPLAIN SELECT * FROM orders WHERE id > 10000 ORDER BY id LIMIT 20;

-- 优化2：延迟关联
EXPLAIN SELECT o.* FROM orders o
JOIN (SELECT id FROM orders ORDER BY id LIMIT 10000, 20) t
ON o.id = t.id;
```

### 10.3 JOIN优化
```sql
-- 确保连接字段有索引
-- 查询订单和用户信息
EXPLAIN SELECT o.*, u.username
FROM orders o
JOIN users u ON o.user_id = u.id
WHERE o.status = 1;

-- 检查：
-- 1. user_id字段有索引吗？
-- 2. status字段需要索引吗？
-- 3. 连接类型是否高效？
```

### 10.4 统计查询优化
```sql
-- 问题：COUNT(*) 很慢
EXPLAIN SELECT COUNT(*) FROM orders WHERE status = 3;

-- 优化：使用覆盖索引
CREATE INDEX idx_status ON orders(status);

EXPLAIN SELECT COUNT(*) FROM orders WHERE status = 3;
-- 应该显示 "Using index"

DROP INDEX idx_status ON orders;
```

---

## 学习检查点

完成所有练习后，你应该能够：
- [ ] 熟练使用EXPLAIN分析查询
- [ ] 理解不同索引类型的应用场景
- [ ] 掌握最左前缀原则
- [ ] 识别索引失效的场景
- [ ] 计算索引选择性
- [ ] 设计合理的组合索引
- [ ] 优化慢查询和分页查询
- [ ] 权衡索引的收益和成本

**下一步**: 完成后查看 `solutions/05-索引优化.md` 对照答案，然后进入第六阶段学习。
